{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Lexer = exports.LexerDefinitionErrorType = void 0;\nvar lexer_1 = require(\"./lexer\");\nvar noop_1 = __importDefault(require(\"lodash/noop\"));\nvar isEmpty_1 = __importDefault(require(\"lodash/isEmpty\"));\nvar isArray_1 = __importDefault(require(\"lodash/isArray\"));\nvar last_1 = __importDefault(require(\"lodash/last\"));\nvar reject_1 = __importDefault(require(\"lodash/reject\"));\nvar map_1 = __importDefault(require(\"lodash/map\"));\nvar forEach_1 = __importDefault(require(\"lodash/forEach\"));\nvar keys_1 = __importDefault(require(\"lodash/keys\"));\nvar isUndefined_1 = __importDefault(require(\"lodash/isUndefined\"));\nvar identity_1 = __importDefault(require(\"lodash/identity\"));\nvar assign_1 = __importDefault(require(\"lodash/assign\"));\nvar reduce_1 = __importDefault(require(\"lodash/reduce\"));\nvar clone_1 = __importDefault(require(\"lodash/clone\"));\nvar utils_1 = require(\"@chevrotain/utils\");\nvar tokens_1 = require(\"./tokens\");\nvar lexer_errors_public_1 = require(\"./lexer_errors_public\");\nvar reg_exp_parser_1 = require(\"./reg_exp_parser\");\nvar LexerDefinitionErrorType;\n(function (LexerDefinitionErrorType) {\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"MISSING_PATTERN\"] = 0] = \"MISSING_PATTERN\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"INVALID_PATTERN\"] = 1] = \"INVALID_PATTERN\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"EOI_ANCHOR_FOUND\"] = 2] = \"EOI_ANCHOR_FOUND\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"UNSUPPORTED_FLAGS_FOUND\"] = 3] = \"UNSUPPORTED_FLAGS_FOUND\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"DUPLICATE_PATTERNS_FOUND\"] = 4] = \"DUPLICATE_PATTERNS_FOUND\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"INVALID_GROUP_TYPE_FOUND\"] = 5] = \"INVALID_GROUP_TYPE_FOUND\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"PUSH_MODE_DOES_NOT_EXIST\"] = 6] = \"PUSH_MODE_DOES_NOT_EXIST\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\"] = 7] = \"MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\"] = 8] = \"MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\"] = 9] = \"MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\"] = 10] = \"LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"SOI_ANCHOR_FOUND\"] = 11] = \"SOI_ANCHOR_FOUND\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"EMPTY_MATCH_PATTERN\"] = 12] = \"EMPTY_MATCH_PATTERN\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"NO_LINE_BREAKS_FLAGS\"] = 13] = \"NO_LINE_BREAKS_FLAGS\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"UNREACHABLE_PATTERN\"] = 14] = \"UNREACHABLE_PATTERN\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"IDENTIFY_TERMINATOR\"] = 15] = \"IDENTIFY_TERMINATOR\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"CUSTOM_LINE_BREAK\"] = 16] = \"CUSTOM_LINE_BREAK\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE\"] = 17] = \"MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE\";\n})(LexerDefinitionErrorType = exports.LexerDefinitionErrorType || (exports.LexerDefinitionErrorType = {}));\nvar DEFAULT_LEXER_CONFIG = {\n  deferDefinitionErrorsHandling: false,\n  positionTracking: \"full\",\n  lineTerminatorsPattern: /\\n|\\r\\n?/g,\n  lineTerminatorCharacters: [\"\\n\", \"\\r\"],\n  ensureOptimizations: false,\n  safeMode: false,\n  errorMessageProvider: lexer_errors_public_1.defaultLexerErrorProvider,\n  traceInitPerf: false,\n  skipValidations: false,\n  recoveryEnabled: true\n};\nObject.freeze(DEFAULT_LEXER_CONFIG);\nvar Lexer = /** @class */function () {\n  function Lexer(lexerDefinition, config) {\n    if (config === void 0) {\n      config = DEFAULT_LEXER_CONFIG;\n    }\n    var _this = this;\n    this.lexerDefinition = lexerDefinition;\n    this.lexerDefinitionErrors = [];\n    this.lexerDefinitionWarning = [];\n    this.patternIdxToConfig = {};\n    this.charCodeToPatternIdxToConfig = {};\n    this.modes = [];\n    this.emptyGroups = {};\n    this.trackStartLines = true;\n    this.trackEndLines = true;\n    this.hasCustom = false;\n    this.canModeBeOptimized = {};\n    // Duplicated from the parser's perf trace trait to allow future extraction\n    // of the lexer to a separate package.\n    this.TRACE_INIT = function (phaseDesc, phaseImpl) {\n      // No need to optimize this using NOOP pattern because\n      // It is not called in a hot spot...\n      if (_this.traceInitPerf === true) {\n        _this.traceInitIndent++;\n        var indent = new Array(_this.traceInitIndent + 1).join(\"\\t\");\n        if (_this.traceInitIndent < _this.traceInitMaxIdent) {\n          console.log(\"\".concat(indent, \"--> <\").concat(phaseDesc, \">\"));\n        }\n        var _a = (0, utils_1.timer)(phaseImpl),\n          time = _a.time,\n          value = _a.value;\n        /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */\n        var traceMethod = time > 10 ? console.warn : console.log;\n        if (_this.traceInitIndent < _this.traceInitMaxIdent) {\n          traceMethod(\"\".concat(indent, \"<-- <\").concat(phaseDesc, \"> time: \").concat(time, \"ms\"));\n        }\n        _this.traceInitIndent--;\n        return value;\n      } else {\n        return phaseImpl();\n      }\n    };\n    if (typeof config === \"boolean\") {\n      throw Error(\"The second argument to the Lexer constructor is now an ILexerConfig Object.\\n\" + \"a boolean 2nd argument is no longer supported\");\n    }\n    // todo: defaults func?\n    this.config = (0, assign_1.default)({}, DEFAULT_LEXER_CONFIG, config);\n    var traceInitVal = this.config.traceInitPerf;\n    if (traceInitVal === true) {\n      this.traceInitMaxIdent = Infinity;\n      this.traceInitPerf = true;\n    } else if (typeof traceInitVal === \"number\") {\n      this.traceInitMaxIdent = traceInitVal;\n      this.traceInitPerf = true;\n    }\n    this.traceInitIndent = -1;\n    this.TRACE_INIT(\"Lexer Constructor\", function () {\n      var actualDefinition;\n      var hasOnlySingleMode = true;\n      _this.TRACE_INIT(\"Lexer Config handling\", function () {\n        if (_this.config.lineTerminatorsPattern === DEFAULT_LEXER_CONFIG.lineTerminatorsPattern) {\n          // optimized built-in implementation for the defaults definition of lineTerminators\n          _this.config.lineTerminatorsPattern = lexer_1.LineTerminatorOptimizedTester;\n        } else {\n          if (_this.config.lineTerminatorCharacters === DEFAULT_LEXER_CONFIG.lineTerminatorCharacters) {\n            throw Error(\"Error: Missing <lineTerminatorCharacters> property on the Lexer config.\\n\" + \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS\");\n          }\n        }\n        if (config.safeMode && config.ensureOptimizations) {\n          throw Error('\"safeMode\" and \"ensureOptimizations\" flags are mutually exclusive.');\n        }\n        _this.trackStartLines = /full|onlyStart/i.test(_this.config.positionTracking);\n        _this.trackEndLines = /full/i.test(_this.config.positionTracking);\n        // Convert SingleModeLexerDefinition into a IMultiModeLexerDefinition.\n        if ((0, isArray_1.default)(lexerDefinition)) {\n          actualDefinition = {\n            modes: {\n              defaultMode: (0, clone_1.default)(lexerDefinition)\n            },\n            defaultMode: lexer_1.DEFAULT_MODE\n          };\n        } else {\n          // no conversion needed, input should already be a IMultiModeLexerDefinition\n          hasOnlySingleMode = false;\n          actualDefinition = (0, clone_1.default)(lexerDefinition);\n        }\n      });\n      if (_this.config.skipValidations === false) {\n        _this.TRACE_INIT(\"performRuntimeChecks\", function () {\n          _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat((0, lexer_1.performRuntimeChecks)(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));\n        });\n        _this.TRACE_INIT(\"performWarningRuntimeChecks\", function () {\n          _this.lexerDefinitionWarning = _this.lexerDefinitionWarning.concat((0, lexer_1.performWarningRuntimeChecks)(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));\n        });\n      }\n      // for extra robustness to avoid throwing an none informative error message\n      actualDefinition.modes = actualDefinition.modes ? actualDefinition.modes : {};\n      // an error of undefined TokenTypes will be detected in \"performRuntimeChecks\" above.\n      // this transformation is to increase robustness in the case of partially invalid lexer definition.\n      (0, forEach_1.default)(actualDefinition.modes, function (currModeValue, currModeName) {\n        actualDefinition.modes[currModeName] = (0, reject_1.default)(currModeValue, function (currTokType) {\n          return (0, isUndefined_1.default)(currTokType);\n        });\n      });\n      var allModeNames = (0, keys_1.default)(actualDefinition.modes);\n      (0, forEach_1.default)(actualDefinition.modes, function (currModDef, currModName) {\n        _this.TRACE_INIT(\"Mode: <\".concat(currModName, \"> processing\"), function () {\n          _this.modes.push(currModName);\n          if (_this.config.skipValidations === false) {\n            _this.TRACE_INIT(\"validatePatterns\", function () {\n              _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat((0, lexer_1.validatePatterns)(currModDef, allModeNames));\n            });\n          }\n          // If definition errors were encountered, the analysis phase may fail unexpectedly/\n          // Considering a lexer with definition errors may never be used, there is no point\n          // to performing the analysis anyhow...\n          if ((0, isEmpty_1.default)(_this.lexerDefinitionErrors)) {\n            (0, tokens_1.augmentTokenTypes)(currModDef);\n            var currAnalyzeResult_1;\n            _this.TRACE_INIT(\"analyzeTokenTypes\", function () {\n              currAnalyzeResult_1 = (0, lexer_1.analyzeTokenTypes)(currModDef, {\n                lineTerminatorCharacters: _this.config.lineTerminatorCharacters,\n                positionTracking: config.positionTracking,\n                ensureOptimizations: config.ensureOptimizations,\n                safeMode: config.safeMode,\n                tracer: _this.TRACE_INIT\n              });\n            });\n            _this.patternIdxToConfig[currModName] = currAnalyzeResult_1.patternIdxToConfig;\n            _this.charCodeToPatternIdxToConfig[currModName] = currAnalyzeResult_1.charCodeToPatternIdxToConfig;\n            _this.emptyGroups = (0, assign_1.default)({}, _this.emptyGroups, currAnalyzeResult_1.emptyGroups);\n            _this.hasCustom = currAnalyzeResult_1.hasCustom || _this.hasCustom;\n            _this.canModeBeOptimized[currModName] = currAnalyzeResult_1.canBeOptimized;\n          }\n        });\n      });\n      _this.defaultMode = actualDefinition.defaultMode;\n      if (!(0, isEmpty_1.default)(_this.lexerDefinitionErrors) && !_this.config.deferDefinitionErrorsHandling) {\n        var allErrMessages = (0, map_1.default)(_this.lexerDefinitionErrors, function (error) {\n          return error.message;\n        });\n        var allErrMessagesString = allErrMessages.join(\"-----------------------\\n\");\n        throw new Error(\"Errors detected in definition of Lexer:\\n\" + allErrMessagesString);\n      }\n      // Only print warning if there are no errors, This will avoid pl\n      (0, forEach_1.default)(_this.lexerDefinitionWarning, function (warningDescriptor) {\n        (0, utils_1.PRINT_WARNING)(warningDescriptor.message);\n      });\n      _this.TRACE_INIT(\"Choosing sub-methods implementations\", function () {\n        // Choose the relevant internal implementations for this specific parser.\n        // These implementations should be in-lined by the JavaScript engine\n        // to provide optimal performance in each scenario.\n        if (lexer_1.SUPPORT_STICKY) {\n          _this.chopInput = identity_1.default;\n          _this.match = _this.matchWithTest;\n        } else {\n          _this.updateLastIndex = noop_1.default;\n          _this.match = _this.matchWithExec;\n        }\n        if (hasOnlySingleMode) {\n          _this.handleModes = noop_1.default;\n        }\n        if (_this.trackStartLines === false) {\n          _this.computeNewColumn = identity_1.default;\n        }\n        if (_this.trackEndLines === false) {\n          _this.updateTokenEndLineColumnLocation = noop_1.default;\n        }\n        if (/full/i.test(_this.config.positionTracking)) {\n          _this.createTokenInstance = _this.createFullToken;\n        } else if (/onlyStart/i.test(_this.config.positionTracking)) {\n          _this.createTokenInstance = _this.createStartOnlyToken;\n        } else if (/onlyOffset/i.test(_this.config.positionTracking)) {\n          _this.createTokenInstance = _this.createOffsetOnlyToken;\n        } else {\n          throw Error(\"Invalid <positionTracking> config option: \\\"\".concat(_this.config.positionTracking, \"\\\"\"));\n        }\n        if (_this.hasCustom) {\n          _this.addToken = _this.addTokenUsingPush;\n          _this.handlePayload = _this.handlePayloadWithCustom;\n        } else {\n          _this.addToken = _this.addTokenUsingMemberAccess;\n          _this.handlePayload = _this.handlePayloadNoCustom;\n        }\n      });\n      _this.TRACE_INIT(\"Failed Optimization Warnings\", function () {\n        var unOptimizedModes = (0, reduce_1.default)(_this.canModeBeOptimized, function (cannotBeOptimized, canBeOptimized, modeName) {\n          if (canBeOptimized === false) {\n            cannotBeOptimized.push(modeName);\n          }\n          return cannotBeOptimized;\n        }, []);\n        if (config.ensureOptimizations && !(0, isEmpty_1.default)(unOptimizedModes)) {\n          throw Error(\"Lexer Modes: < \".concat(unOptimizedModes.join(\", \"), \" > cannot be optimized.\\n\") + '\\t Disable the \"ensureOptimizations\" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\\n' + \"\\t Or inspect the console log for details on how to resolve these issues.\");\n        }\n      });\n      _this.TRACE_INIT(\"clearRegExpParserCache\", function () {\n        (0, reg_exp_parser_1.clearRegExpParserCache)();\n      });\n      _this.TRACE_INIT(\"toFastProperties\", function () {\n        (0, utils_1.toFastProperties)(_this);\n      });\n    });\n  }\n  Lexer.prototype.tokenize = function (text, initialMode) {\n    if (initialMode === void 0) {\n      initialMode = this.defaultMode;\n    }\n    if (!(0, isEmpty_1.default)(this.lexerDefinitionErrors)) {\n      var allErrMessages = (0, map_1.default)(this.lexerDefinitionErrors, function (error) {\n        return error.message;\n      });\n      var allErrMessagesString = allErrMessages.join(\"-----------------------\\n\");\n      throw new Error(\"Unable to Tokenize because Errors detected in definition of Lexer:\\n\" + allErrMessagesString);\n    }\n    return this.tokenizeInternal(text, initialMode);\n  };\n  // There is quite a bit of duplication between this and \"tokenizeInternalLazy\"\n  // This is intentional due to performance considerations.\n  // this method also used quite a bit of `!` none null assertions because it is too optimized\n  // for `tsc` to always understand it is \"safe\"\n  Lexer.prototype.tokenizeInternal = function (text, initialMode) {\n    var _this = this;\n    var i, j, k, matchAltImage, longerAlt, matchedImage, payload, altPayload, imageLength, group, tokType, newToken, errLength, droppedChar, msg, match;\n    var orgText = text;\n    var orgLength = orgText.length;\n    var offset = 0;\n    var matchedTokensIndex = 0;\n    // initializing the tokensArray to the \"guessed\" size.\n    // guessing too little will still reduce the number of array re-sizes on pushes.\n    // guessing too large (Tested by guessing x4 too large) may cost a bit more of memory\n    // but would still have a faster runtime by avoiding (All but one) array resizing.\n    var guessedNumberOfTokens = this.hasCustom ? 0 // will break custom token pattern APIs the matchedTokens array will contain undefined elements.\n    : Math.floor(text.length / 10);\n    var matchedTokens = new Array(guessedNumberOfTokens);\n    var errors = [];\n    var line = this.trackStartLines ? 1 : undefined;\n    var column = this.trackStartLines ? 1 : undefined;\n    var groups = (0, lexer_1.cloneEmptyGroups)(this.emptyGroups);\n    var trackLines = this.trackStartLines;\n    var lineTerminatorPattern = this.config.lineTerminatorsPattern;\n    var currModePatternsLength = 0;\n    var patternIdxToConfig = [];\n    var currCharCodeToPatternIdxToConfig = [];\n    var modeStack = [];\n    var emptyArray = [];\n    Object.freeze(emptyArray);\n    var getPossiblePatterns;\n    function getPossiblePatternsSlow() {\n      return patternIdxToConfig;\n    }\n    function getPossiblePatternsOptimized(charCode) {\n      var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(charCode);\n      var possiblePatterns = currCharCodeToPatternIdxToConfig[optimizedCharIdx];\n      if (possiblePatterns === undefined) {\n        return emptyArray;\n      } else {\n        return possiblePatterns;\n      }\n    }\n    var pop_mode = function (popToken) {\n      // TODO: perhaps avoid this error in the edge case there is no more input?\n      if (modeStack.length === 1 &&\n      // if we have both a POP_MODE and a PUSH_MODE this is in-fact a \"transition\"\n      // So no error should occur.\n      popToken.tokenType.PUSH_MODE === undefined) {\n        // if we try to pop the last mode there lexer will no longer have ANY mode.\n        // thus the pop is ignored, an error will be created and the lexer will continue parsing in the previous mode.\n        var msg_1 = _this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(popToken);\n        errors.push({\n          offset: popToken.startOffset,\n          line: popToken.startLine,\n          column: popToken.startColumn,\n          length: popToken.image.length,\n          message: msg_1\n        });\n      } else {\n        modeStack.pop();\n        var newMode = (0, last_1.default)(modeStack);\n        patternIdxToConfig = _this.patternIdxToConfig[newMode];\n        currCharCodeToPatternIdxToConfig = _this.charCodeToPatternIdxToConfig[newMode];\n        currModePatternsLength = patternIdxToConfig.length;\n        var modeCanBeOptimized = _this.canModeBeOptimized[newMode] && _this.config.safeMode === false;\n        if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n          getPossiblePatterns = getPossiblePatternsOptimized;\n        } else {\n          getPossiblePatterns = getPossiblePatternsSlow;\n        }\n      }\n    };\n    function push_mode(newMode) {\n      modeStack.push(newMode);\n      currCharCodeToPatternIdxToConfig = this.charCodeToPatternIdxToConfig[newMode];\n      patternIdxToConfig = this.patternIdxToConfig[newMode];\n      currModePatternsLength = patternIdxToConfig.length;\n      currModePatternsLength = patternIdxToConfig.length;\n      var modeCanBeOptimized = this.canModeBeOptimized[newMode] && this.config.safeMode === false;\n      if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n        getPossiblePatterns = getPossiblePatternsOptimized;\n      } else {\n        getPossiblePatterns = getPossiblePatternsSlow;\n      }\n    }\n    // this pattern seems to avoid a V8 de-optimization, although that de-optimization does not\n    // seem to matter performance wise.\n    push_mode.call(this, initialMode);\n    var currConfig;\n    var recoveryEnabled = this.config.recoveryEnabled;\n    while (offset < orgLength) {\n      matchedImage = null;\n      var nextCharCode = orgText.charCodeAt(offset);\n      var chosenPatternIdxToConfig = getPossiblePatterns(nextCharCode);\n      var chosenPatternsLength = chosenPatternIdxToConfig.length;\n      for (i = 0; i < chosenPatternsLength; i++) {\n        currConfig = chosenPatternIdxToConfig[i];\n        var currPattern = currConfig.pattern;\n        payload = null;\n        // manually in-lined because > 600 chars won't be in-lined in V8\n        var singleCharCode = currConfig.short;\n        if (singleCharCode !== false) {\n          if (nextCharCode === singleCharCode) {\n            // single character string\n            matchedImage = currPattern;\n          }\n        } else if (currConfig.isCustom === true) {\n          match = currPattern.exec(orgText, offset, matchedTokens, groups);\n          if (match !== null) {\n            matchedImage = match[0];\n            if (match.payload !== undefined) {\n              payload = match.payload;\n            }\n          } else {\n            matchedImage = null;\n          }\n        } else {\n          this.updateLastIndex(currPattern, offset);\n          matchedImage = this.match(currPattern, text, offset);\n        }\n        if (matchedImage !== null) {\n          // even though this pattern matched we must try a another longer alternative.\n          // this can be used to prioritize keywords over identifiers\n          longerAlt = currConfig.longerAlt;\n          if (longerAlt !== undefined) {\n            // TODO: micro optimize, avoid extra prop access\n            // by saving/linking longerAlt on the original config?\n            var longerAltLength = longerAlt.length;\n            for (k = 0; k < longerAltLength; k++) {\n              var longerAltConfig = patternIdxToConfig[longerAlt[k]];\n              var longerAltPattern = longerAltConfig.pattern;\n              altPayload = null;\n              // single Char can never be a longer alt so no need to test it.\n              // manually in-lined because > 600 chars won't be in-lined in V8\n              if (longerAltConfig.isCustom === true) {\n                match = longerAltPattern.exec(orgText, offset, matchedTokens, groups);\n                if (match !== null) {\n                  matchAltImage = match[0];\n                  if (match.payload !== undefined) {\n                    altPayload = match.payload;\n                  }\n                } else {\n                  matchAltImage = null;\n                }\n              } else {\n                this.updateLastIndex(longerAltPattern, offset);\n                matchAltImage = this.match(longerAltPattern, text, offset);\n              }\n              if (matchAltImage && matchAltImage.length > matchedImage.length) {\n                matchedImage = matchAltImage;\n                payload = altPayload;\n                currConfig = longerAltConfig;\n                // Exit the loop early after matching one of the longer alternatives\n                // The first matched alternative takes precedence\n                break;\n              }\n            }\n          }\n          break;\n        }\n      }\n      // successful match\n      if (matchedImage !== null) {\n        imageLength = matchedImage.length;\n        group = currConfig.group;\n        if (group !== undefined) {\n          tokType = currConfig.tokenTypeIdx;\n          // TODO: \"offset + imageLength\" and the new column may be computed twice in case of \"full\" location information inside\n          // createFullToken method\n          newToken = this.createTokenInstance(matchedImage, offset, tokType, currConfig.tokenType, line, column, imageLength);\n          this.handlePayload(newToken, payload);\n          // TODO: optimize NOOP in case there are no special groups?\n          if (group === false) {\n            matchedTokensIndex = this.addToken(matchedTokens, matchedTokensIndex, newToken);\n          } else {\n            groups[group].push(newToken);\n          }\n        }\n        text = this.chopInput(text, imageLength);\n        offset = offset + imageLength;\n        // TODO: with newlines the column may be assigned twice\n        column = this.computeNewColumn(column, imageLength);\n        if (trackLines === true && currConfig.canLineTerminator === true) {\n          var numOfLTsInMatch = 0;\n          var foundTerminator = void 0;\n          var lastLTEndOffset = void 0;\n          lineTerminatorPattern.lastIndex = 0;\n          do {\n            foundTerminator = lineTerminatorPattern.test(matchedImage);\n            if (foundTerminator === true) {\n              lastLTEndOffset = lineTerminatorPattern.lastIndex - 1;\n              numOfLTsInMatch++;\n            }\n          } while (foundTerminator === true);\n          if (numOfLTsInMatch !== 0) {\n            line = line + numOfLTsInMatch;\n            column = imageLength - lastLTEndOffset;\n            this.updateTokenEndLineColumnLocation(newToken, group, lastLTEndOffset, numOfLTsInMatch, line, column, imageLength);\n          }\n        }\n        // will be NOOP if no modes present\n        this.handleModes(currConfig, pop_mode, push_mode, newToken);\n      } else {\n        // error recovery, drop characters until we identify a valid token's start point\n        var errorStartOffset = offset;\n        var errorLine = line;\n        var errorColumn = column;\n        var foundResyncPoint = recoveryEnabled === false;\n        while (foundResyncPoint === false && offset < orgLength) {\n          // Identity Func (when sticky flag is enabled)\n          text = this.chopInput(text, 1);\n          offset++;\n          for (j = 0; j < currModePatternsLength; j++) {\n            var currConfig_1 = patternIdxToConfig[j];\n            var currPattern = currConfig_1.pattern;\n            // manually in-lined because > 600 chars won't be in-lined in V8\n            var singleCharCode = currConfig_1.short;\n            if (singleCharCode !== false) {\n              if (orgText.charCodeAt(offset) === singleCharCode) {\n                // single character string\n                foundResyncPoint = true;\n              }\n            } else if (currConfig_1.isCustom === true) {\n              foundResyncPoint = currPattern.exec(orgText, offset, matchedTokens, groups) !== null;\n            } else {\n              this.updateLastIndex(currPattern, offset);\n              foundResyncPoint = currPattern.exec(text) !== null;\n            }\n            if (foundResyncPoint === true) {\n              break;\n            }\n          }\n        }\n        errLength = offset - errorStartOffset;\n        // at this point we either re-synced or reached the end of the input text\n        msg = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(orgText, errorStartOffset, errLength, errorLine, errorColumn);\n        errors.push({\n          offset: errorStartOffset,\n          line: errorLine,\n          column: errorColumn,\n          length: errLength,\n          message: msg\n        });\n        if (recoveryEnabled === false) {\n          break;\n        }\n      }\n    }\n    // if we do have custom patterns which push directly into the\n    // TODO: custom tokens should not push directly??\n    if (!this.hasCustom) {\n      // if we guessed a too large size for the tokens array this will shrink it to the right size.\n      matchedTokens.length = matchedTokensIndex;\n    }\n    return {\n      tokens: matchedTokens,\n      groups: groups,\n      errors: errors\n    };\n  };\n  Lexer.prototype.handleModes = function (config, pop_mode, push_mode, newToken) {\n    if (config.pop === true) {\n      // need to save the PUSH_MODE property as if the mode is popped\n      // patternIdxToPopMode is updated to reflect the new mode after popping the stack\n      var pushMode = config.push;\n      pop_mode(newToken);\n      if (pushMode !== undefined) {\n        push_mode.call(this, pushMode);\n      }\n    } else if (config.push !== undefined) {\n      push_mode.call(this, config.push);\n    }\n  };\n  Lexer.prototype.chopInput = function (text, length) {\n    return text.substring(length);\n  };\n  Lexer.prototype.updateLastIndex = function (regExp, newLastIndex) {\n    regExp.lastIndex = newLastIndex;\n  };\n  // TODO: decrease this under 600 characters? inspect stripping comments option in TSC compiler\n  Lexer.prototype.updateTokenEndLineColumnLocation = function (newToken, group, lastLTIdx, numOfLTsInMatch, line, column, imageLength) {\n    var lastCharIsLT, fixForEndingInLT;\n    if (group !== undefined) {\n      // a none skipped multi line Token, need to update endLine/endColumn\n      lastCharIsLT = lastLTIdx === imageLength - 1;\n      fixForEndingInLT = lastCharIsLT ? -1 : 0;\n      if (!(numOfLTsInMatch === 1 && lastCharIsLT === true)) {\n        // if a token ends in a LT that last LT only affects the line numbering of following Tokens\n        newToken.endLine = line + fixForEndingInLT;\n        // the last LT in a token does not affect the endColumn either as the [columnStart ... columnEnd)\n        // inclusive to exclusive range.\n        newToken.endColumn = column - 1 + -fixForEndingInLT;\n      }\n      // else single LT in the last character of a token, no need to modify the endLine/EndColumn\n    }\n  };\n\n  Lexer.prototype.computeNewColumn = function (oldColumn, imageLength) {\n    return oldColumn + imageLength;\n  };\n  Lexer.prototype.createOffsetOnlyToken = function (image, startOffset, tokenTypeIdx, tokenType) {\n    return {\n      image: image,\n      startOffset: startOffset,\n      tokenTypeIdx: tokenTypeIdx,\n      tokenType: tokenType\n    };\n  };\n  Lexer.prototype.createStartOnlyToken = function (image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn) {\n    return {\n      image: image,\n      startOffset: startOffset,\n      startLine: startLine,\n      startColumn: startColumn,\n      tokenTypeIdx: tokenTypeIdx,\n      tokenType: tokenType\n    };\n  };\n  Lexer.prototype.createFullToken = function (image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn, imageLength) {\n    return {\n      image: image,\n      startOffset: startOffset,\n      endOffset: startOffset + imageLength - 1,\n      startLine: startLine,\n      endLine: startLine,\n      startColumn: startColumn,\n      endColumn: startColumn + imageLength - 1,\n      tokenTypeIdx: tokenTypeIdx,\n      tokenType: tokenType\n    };\n  };\n  Lexer.prototype.addTokenUsingPush = function (tokenVector, index, tokenToAdd) {\n    tokenVector.push(tokenToAdd);\n    return index;\n  };\n  Lexer.prototype.addTokenUsingMemberAccess = function (tokenVector, index, tokenToAdd) {\n    tokenVector[index] = tokenToAdd;\n    index++;\n    return index;\n  };\n  Lexer.prototype.handlePayloadNoCustom = function (token, payload) {};\n  Lexer.prototype.handlePayloadWithCustom = function (token, payload) {\n    if (payload !== null) {\n      token.payload = payload;\n    }\n  };\n  Lexer.prototype.matchWithTest = function (pattern, text, offset) {\n    var found = pattern.test(text);\n    if (found === true) {\n      return text.substring(offset, pattern.lastIndex);\n    }\n    return null;\n  };\n  Lexer.prototype.matchWithExec = function (pattern, text) {\n    var regExpArray = pattern.exec(text);\n    return regExpArray !== null ? regExpArray[0] : null;\n  };\n  Lexer.SKIPPED = \"This marks a skipped Token pattern, this means each token identified by it will\" + \"be consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.\";\n  Lexer.NA = /NOT_APPLICABLE/;\n  return Lexer;\n}();\nexports.Lexer = Lexer;","map":{"version":3,"names":["lexer_1","require","noop_1","__importDefault","isEmpty_1","isArray_1","last_1","reject_1","map_1","forEach_1","keys_1","isUndefined_1","identity_1","assign_1","reduce_1","clone_1","utils_1","tokens_1","lexer_errors_public_1","reg_exp_parser_1","LexerDefinitionErrorType","exports","DEFAULT_LEXER_CONFIG","deferDefinitionErrorsHandling","positionTracking","lineTerminatorsPattern","lineTerminatorCharacters","ensureOptimizations","safeMode","errorMessageProvider","defaultLexerErrorProvider","traceInitPerf","skipValidations","recoveryEnabled","Object","freeze","Lexer","lexerDefinition","config","_this","lexerDefinitionErrors","lexerDefinitionWarning","patternIdxToConfig","charCodeToPatternIdxToConfig","modes","emptyGroups","trackStartLines","trackEndLines","hasCustom","canModeBeOptimized","TRACE_INIT","phaseDesc","phaseImpl","traceInitIndent","indent","Array","join","traceInitMaxIdent","console","log","concat","_a","timer","time","value","traceMethod","warn","Error","default","traceInitVal","Infinity","actualDefinition","hasOnlySingleMode","LineTerminatorOptimizedTester","test","defaultMode","DEFAULT_MODE","performRuntimeChecks","performWarningRuntimeChecks","currModeValue","currModeName","currTokType","allModeNames","currModDef","currModName","push","validatePatterns","augmentTokenTypes","currAnalyzeResult_1","analyzeTokenTypes","tracer","canBeOptimized","allErrMessages","error","message","allErrMessagesString","warningDescriptor","PRINT_WARNING","SUPPORT_STICKY","chopInput","match","matchWithTest","updateLastIndex","matchWithExec","handleModes","computeNewColumn","updateTokenEndLineColumnLocation","createTokenInstance","createFullToken","createStartOnlyToken","createOffsetOnlyToken","addToken","addTokenUsingPush","handlePayload","handlePayloadWithCustom","addTokenUsingMemberAccess","handlePayloadNoCustom","unOptimizedModes","cannotBeOptimized","modeName","clearRegExpParserCache","toFastProperties","prototype","tokenize","text","initialMode","tokenizeInternal","i","j","k","matchAltImage","longerAlt","matchedImage","payload","altPayload","imageLength","group","tokType","newToken","errLength","droppedChar","msg","orgText","orgLength","length","offset","matchedTokensIndex","guessedNumberOfTokens","Math","floor","matchedTokens","errors","line","undefined","column","groups","cloneEmptyGroups","trackLines","lineTerminatorPattern","currModePatternsLength","currCharCodeToPatternIdxToConfig","modeStack","emptyArray","getPossiblePatterns","getPossiblePatternsSlow","getPossiblePatternsOptimized","charCode","optimizedCharIdx","charCodeToOptimizedIndex","possiblePatterns","pop_mode","popToken","tokenType","PUSH_MODE","msg_1","buildUnableToPopLexerModeMessage","startOffset","startLine","startColumn","image","pop","newMode","modeCanBeOptimized","push_mode","call","currConfig","nextCharCode","charCodeAt","chosenPatternIdxToConfig","chosenPatternsLength","currPattern","pattern","singleCharCode","short","isCustom","exec","longerAltLength","longerAltConfig","longerAltPattern","tokenTypeIdx","canLineTerminator","numOfLTsInMatch","foundTerminator","lastLTEndOffset","lastIndex","errorStartOffset","errorLine","errorColumn","foundResyncPoint","currConfig_1","buildUnexpectedCharactersMessage","tokens","pushMode","substring","regExp","newLastIndex","lastLTIdx","lastCharIsLT","fixForEndingInLT","endLine","endColumn","oldColumn","endOffset","tokenVector","index","tokenToAdd","token","found","regExpArray","SKIPPED","NA"],"sources":["/Users/rociopichardo/Desktop/PFhenryFront/restaurante-pf-front/node_modules/chevrotain/src/scan/lexer_public.ts"],"sourcesContent":["import {\n  analyzeTokenTypes,\n  charCodeToOptimizedIndex,\n  cloneEmptyGroups,\n  DEFAULT_MODE,\n  IAnalyzeResult,\n  IPatternConfig,\n  LineTerminatorOptimizedTester,\n  performRuntimeChecks,\n  performWarningRuntimeChecks,\n  SUPPORT_STICKY,\n  validatePatterns\n} from \"./lexer\"\nimport noop from \"lodash/noop\"\nimport isEmpty from \"lodash/isEmpty\"\nimport isArray from \"lodash/isArray\"\nimport last from \"lodash/last\"\nimport reject from \"lodash/reject\"\nimport map from \"lodash/map\"\nimport forEach from \"lodash/forEach\"\nimport keys from \"lodash/keys\"\nimport isUndefined from \"lodash/isUndefined\"\nimport identity from \"lodash/identity\"\nimport assign from \"lodash/assign\"\nimport reduce from \"lodash/reduce\"\nimport clone from \"lodash/clone\"\nimport { PRINT_WARNING, timer, toFastProperties } from \"@chevrotain/utils\"\nimport { augmentTokenTypes } from \"./tokens\"\nimport {\n  CustomPatternMatcherFunc,\n  CustomPatternMatcherReturn,\n  ILexerConfig,\n  ILexerDefinitionError,\n  ILexingError,\n  IMultiModeLexerDefinition,\n  IToken,\n  TokenType\n} from \"@chevrotain/types\"\nimport { defaultLexerErrorProvider } from \"./lexer_errors_public\"\nimport { clearRegExpParserCache } from \"./reg_exp_parser\"\n\nexport interface ILexingResult {\n  tokens: IToken[]\n  groups: { [groupName: string]: IToken[] }\n  errors: ILexingError[]\n}\n\nexport enum LexerDefinitionErrorType {\n  MISSING_PATTERN,\n  INVALID_PATTERN,\n  EOI_ANCHOR_FOUND,\n  UNSUPPORTED_FLAGS_FOUND,\n  DUPLICATE_PATTERNS_FOUND,\n  INVALID_GROUP_TYPE_FOUND,\n  PUSH_MODE_DOES_NOT_EXIST,\n  MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE,\n  MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY,\n  MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST,\n  LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED,\n  SOI_ANCHOR_FOUND,\n  EMPTY_MATCH_PATTERN,\n  NO_LINE_BREAKS_FLAGS,\n  UNREACHABLE_PATTERN,\n  IDENTIFY_TERMINATOR,\n  CUSTOM_LINE_BREAK,\n  MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE\n}\n\nexport interface IRegExpExec {\n  exec: CustomPatternMatcherFunc\n}\n\nconst DEFAULT_LEXER_CONFIG: Required<ILexerConfig> = {\n  deferDefinitionErrorsHandling: false,\n  positionTracking: \"full\",\n  lineTerminatorsPattern: /\\n|\\r\\n?/g,\n  lineTerminatorCharacters: [\"\\n\", \"\\r\"],\n  ensureOptimizations: false,\n  safeMode: false,\n  errorMessageProvider: defaultLexerErrorProvider,\n  traceInitPerf: false,\n  skipValidations: false,\n  recoveryEnabled: true\n}\n\nObject.freeze(DEFAULT_LEXER_CONFIG)\n\nexport class Lexer {\n  public static SKIPPED =\n    \"This marks a skipped Token pattern, this means each token identified by it will\" +\n    \"be consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.\"\n\n  public static NA = /NOT_APPLICABLE/\n  public lexerDefinitionErrors: ILexerDefinitionError[] = []\n  public lexerDefinitionWarning: ILexerDefinitionError[] = []\n\n  protected patternIdxToConfig: Record<string, IPatternConfig[]> = {}\n  protected charCodeToPatternIdxToConfig: {\n    [modeName: string]: { [charCode: number]: IPatternConfig[] }\n  } = {}\n\n  protected modes: string[] = []\n  protected defaultMode!: string\n  protected emptyGroups: { [groupName: string]: IToken } = {}\n\n  private config: Required<ILexerConfig>\n  private trackStartLines: boolean = true\n  private trackEndLines: boolean = true\n  private hasCustom: boolean = false\n  private canModeBeOptimized: Record<string, boolean> = {}\n\n  private traceInitPerf!: boolean | number\n  private traceInitMaxIdent!: number\n  private traceInitIndent: number\n\n  constructor(\n    protected lexerDefinition: TokenType[] | IMultiModeLexerDefinition,\n    config: ILexerConfig = DEFAULT_LEXER_CONFIG\n  ) {\n    if (typeof config === \"boolean\") {\n      throw Error(\n        \"The second argument to the Lexer constructor is now an ILexerConfig Object.\\n\" +\n          \"a boolean 2nd argument is no longer supported\"\n      )\n    }\n\n    // todo: defaults func?\n    this.config = assign({}, DEFAULT_LEXER_CONFIG, config) as any\n\n    const traceInitVal = this.config.traceInitPerf\n    if (traceInitVal === true) {\n      this.traceInitMaxIdent = Infinity\n      this.traceInitPerf = true\n    } else if (typeof traceInitVal === \"number\") {\n      this.traceInitMaxIdent = traceInitVal\n      this.traceInitPerf = true\n    }\n    this.traceInitIndent = -1\n\n    this.TRACE_INIT(\"Lexer Constructor\", () => {\n      let actualDefinition!: IMultiModeLexerDefinition\n      let hasOnlySingleMode = true\n      this.TRACE_INIT(\"Lexer Config handling\", () => {\n        if (\n          this.config.lineTerminatorsPattern ===\n          DEFAULT_LEXER_CONFIG.lineTerminatorsPattern\n        ) {\n          // optimized built-in implementation for the defaults definition of lineTerminators\n          this.config.lineTerminatorsPattern = LineTerminatorOptimizedTester\n        } else {\n          if (\n            this.config.lineTerminatorCharacters ===\n            DEFAULT_LEXER_CONFIG.lineTerminatorCharacters\n          ) {\n            throw Error(\n              \"Error: Missing <lineTerminatorCharacters> property on the Lexer config.\\n\" +\n                \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS\"\n            )\n          }\n        }\n\n        if (config.safeMode && config.ensureOptimizations) {\n          throw Error(\n            '\"safeMode\" and \"ensureOptimizations\" flags are mutually exclusive.'\n          )\n        }\n\n        this.trackStartLines = /full|onlyStart/i.test(\n          this.config.positionTracking\n        )\n        this.trackEndLines = /full/i.test(this.config.positionTracking)\n\n        // Convert SingleModeLexerDefinition into a IMultiModeLexerDefinition.\n        if (isArray(lexerDefinition)) {\n          actualDefinition = {\n            modes: { defaultMode: clone(lexerDefinition) },\n            defaultMode: DEFAULT_MODE\n          }\n        } else {\n          // no conversion needed, input should already be a IMultiModeLexerDefinition\n          hasOnlySingleMode = false\n          actualDefinition = clone(<IMultiModeLexerDefinition>lexerDefinition)\n        }\n      })\n\n      if (this.config.skipValidations === false) {\n        this.TRACE_INIT(\"performRuntimeChecks\", () => {\n          this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(\n            performRuntimeChecks(\n              actualDefinition,\n              this.trackStartLines,\n              this.config.lineTerminatorCharacters\n            )\n          )\n        })\n\n        this.TRACE_INIT(\"performWarningRuntimeChecks\", () => {\n          this.lexerDefinitionWarning = this.lexerDefinitionWarning.concat(\n            performWarningRuntimeChecks(\n              actualDefinition,\n              this.trackStartLines,\n              this.config.lineTerminatorCharacters\n            )\n          )\n        })\n      }\n\n      // for extra robustness to avoid throwing an none informative error message\n      actualDefinition.modes = actualDefinition.modes\n        ? actualDefinition.modes\n        : {}\n\n      // an error of undefined TokenTypes will be detected in \"performRuntimeChecks\" above.\n      // this transformation is to increase robustness in the case of partially invalid lexer definition.\n      forEach(actualDefinition.modes, (currModeValue, currModeName) => {\n        actualDefinition.modes[currModeName] = reject<TokenType>(\n          currModeValue,\n          (currTokType) => isUndefined(currTokType)\n        )\n      })\n\n      const allModeNames = keys(actualDefinition.modes)\n\n      forEach(\n        actualDefinition.modes,\n        (currModDef: TokenType[], currModName) => {\n          this.TRACE_INIT(`Mode: <${currModName}> processing`, () => {\n            this.modes.push(currModName)\n\n            if (this.config.skipValidations === false) {\n              this.TRACE_INIT(`validatePatterns`, () => {\n                this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(\n                  validatePatterns(currModDef, allModeNames)\n                )\n              })\n            }\n\n            // If definition errors were encountered, the analysis phase may fail unexpectedly/\n            // Considering a lexer with definition errors may never be used, there is no point\n            // to performing the analysis anyhow...\n            if (isEmpty(this.lexerDefinitionErrors)) {\n              augmentTokenTypes(currModDef)\n\n              let currAnalyzeResult!: IAnalyzeResult\n              this.TRACE_INIT(`analyzeTokenTypes`, () => {\n                currAnalyzeResult = analyzeTokenTypes(currModDef, {\n                  lineTerminatorCharacters:\n                    this.config.lineTerminatorCharacters,\n                  positionTracking: config.positionTracking,\n                  ensureOptimizations: config.ensureOptimizations,\n                  safeMode: config.safeMode,\n                  tracer: this.TRACE_INIT\n                })\n              })\n\n              this.patternIdxToConfig[currModName] =\n                currAnalyzeResult.patternIdxToConfig\n\n              this.charCodeToPatternIdxToConfig[currModName] =\n                currAnalyzeResult.charCodeToPatternIdxToConfig\n\n              this.emptyGroups = assign(\n                {},\n                this.emptyGroups,\n                currAnalyzeResult.emptyGroups\n              ) as any\n\n              this.hasCustom = currAnalyzeResult.hasCustom || this.hasCustom\n\n              this.canModeBeOptimized[currModName] =\n                currAnalyzeResult.canBeOptimized\n            }\n          })\n        }\n      )\n\n      this.defaultMode = actualDefinition.defaultMode\n\n      if (\n        !isEmpty(this.lexerDefinitionErrors) &&\n        !this.config.deferDefinitionErrorsHandling\n      ) {\n        const allErrMessages = map(this.lexerDefinitionErrors, (error) => {\n          return error.message\n        })\n        const allErrMessagesString = allErrMessages.join(\n          \"-----------------------\\n\"\n        )\n        throw new Error(\n          \"Errors detected in definition of Lexer:\\n\" + allErrMessagesString\n        )\n      }\n\n      // Only print warning if there are no errors, This will avoid pl\n      forEach(this.lexerDefinitionWarning, (warningDescriptor) => {\n        PRINT_WARNING(warningDescriptor.message)\n      })\n\n      this.TRACE_INIT(\"Choosing sub-methods implementations\", () => {\n        // Choose the relevant internal implementations for this specific parser.\n        // These implementations should be in-lined by the JavaScript engine\n        // to provide optimal performance in each scenario.\n        if (SUPPORT_STICKY) {\n          this.chopInput = <any>identity\n          this.match = this.matchWithTest\n        } else {\n          this.updateLastIndex = noop\n          this.match = this.matchWithExec\n        }\n\n        if (hasOnlySingleMode) {\n          this.handleModes = noop\n        }\n\n        if (this.trackStartLines === false) {\n          this.computeNewColumn = identity\n        }\n\n        if (this.trackEndLines === false) {\n          this.updateTokenEndLineColumnLocation = noop\n        }\n\n        if (/full/i.test(this.config.positionTracking)) {\n          this.createTokenInstance = this.createFullToken\n        } else if (/onlyStart/i.test(this.config.positionTracking)) {\n          this.createTokenInstance = this.createStartOnlyToken\n        } else if (/onlyOffset/i.test(this.config.positionTracking)) {\n          this.createTokenInstance = this.createOffsetOnlyToken\n        } else {\n          throw Error(\n            `Invalid <positionTracking> config option: \"${this.config.positionTracking}\"`\n          )\n        }\n\n        if (this.hasCustom) {\n          this.addToken = this.addTokenUsingPush\n          this.handlePayload = this.handlePayloadWithCustom\n        } else {\n          this.addToken = this.addTokenUsingMemberAccess\n          this.handlePayload = this.handlePayloadNoCustom\n        }\n      })\n\n      this.TRACE_INIT(\"Failed Optimization Warnings\", () => {\n        const unOptimizedModes = reduce(\n          this.canModeBeOptimized,\n          (cannotBeOptimized, canBeOptimized, modeName) => {\n            if (canBeOptimized === false) {\n              cannotBeOptimized.push(modeName)\n            }\n            return cannotBeOptimized\n          },\n          [] as string[]\n        )\n\n        if (config.ensureOptimizations && !isEmpty(unOptimizedModes)) {\n          throw Error(\n            `Lexer Modes: < ${unOptimizedModes.join(\n              \", \"\n            )} > cannot be optimized.\\n` +\n              '\\t Disable the \"ensureOptimizations\" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\\n' +\n              \"\\t Or inspect the console log for details on how to resolve these issues.\"\n          )\n        }\n      })\n\n      this.TRACE_INIT(\"clearRegExpParserCache\", () => {\n        clearRegExpParserCache()\n      })\n\n      this.TRACE_INIT(\"toFastProperties\", () => {\n        toFastProperties(this)\n      })\n    })\n  }\n\n  public tokenize(\n    text: string,\n    initialMode: string = this.defaultMode\n  ): ILexingResult {\n    if (!isEmpty(this.lexerDefinitionErrors)) {\n      const allErrMessages = map(this.lexerDefinitionErrors, (error) => {\n        return error.message\n      })\n      const allErrMessagesString = allErrMessages.join(\n        \"-----------------------\\n\"\n      )\n      throw new Error(\n        \"Unable to Tokenize because Errors detected in definition of Lexer:\\n\" +\n          allErrMessagesString\n      )\n    }\n\n    return this.tokenizeInternal(text, initialMode)\n  }\n\n  // There is quite a bit of duplication between this and \"tokenizeInternalLazy\"\n  // This is intentional due to performance considerations.\n  // this method also used quite a bit of `!` none null assertions because it is too optimized\n  // for `tsc` to always understand it is \"safe\"\n  private tokenizeInternal(text: string, initialMode: string): ILexingResult {\n    let i,\n      j,\n      k,\n      matchAltImage,\n      longerAlt,\n      matchedImage: string | null,\n      payload,\n      altPayload,\n      imageLength,\n      group,\n      tokType,\n      newToken: IToken,\n      errLength,\n      droppedChar,\n      msg,\n      match\n    const orgText = text\n    const orgLength = orgText.length\n    let offset = 0\n    let matchedTokensIndex = 0\n    // initializing the tokensArray to the \"guessed\" size.\n    // guessing too little will still reduce the number of array re-sizes on pushes.\n    // guessing too large (Tested by guessing x4 too large) may cost a bit more of memory\n    // but would still have a faster runtime by avoiding (All but one) array resizing.\n    const guessedNumberOfTokens = this.hasCustom\n      ? 0 // will break custom token pattern APIs the matchedTokens array will contain undefined elements.\n      : Math.floor(text.length / 10)\n    const matchedTokens = new Array(guessedNumberOfTokens)\n    const errors: ILexingError[] = []\n    let line = this.trackStartLines ? 1 : undefined\n    let column = this.trackStartLines ? 1 : undefined\n    const groups: any = cloneEmptyGroups(this.emptyGroups)\n    const trackLines = this.trackStartLines\n    const lineTerminatorPattern = this.config.lineTerminatorsPattern\n\n    let currModePatternsLength = 0\n    let patternIdxToConfig: IPatternConfig[] = []\n    let currCharCodeToPatternIdxToConfig: {\n      [charCode: number]: IPatternConfig[]\n    } = []\n\n    const modeStack: string[] = []\n\n    const emptyArray: IPatternConfig[] = []\n    Object.freeze(emptyArray)\n    let getPossiblePatterns!: (charCode: number) => IPatternConfig[]\n\n    function getPossiblePatternsSlow() {\n      return patternIdxToConfig\n    }\n\n    function getPossiblePatternsOptimized(charCode: number): IPatternConfig[] {\n      const optimizedCharIdx = charCodeToOptimizedIndex(charCode)\n      const possiblePatterns =\n        currCharCodeToPatternIdxToConfig[optimizedCharIdx]\n      if (possiblePatterns === undefined) {\n        return emptyArray\n      } else {\n        return possiblePatterns\n      }\n    }\n\n    const pop_mode = (popToken: IToken) => {\n      // TODO: perhaps avoid this error in the edge case there is no more input?\n      if (\n        modeStack.length === 1 &&\n        // if we have both a POP_MODE and a PUSH_MODE this is in-fact a \"transition\"\n        // So no error should occur.\n        popToken.tokenType.PUSH_MODE === undefined\n      ) {\n        // if we try to pop the last mode there lexer will no longer have ANY mode.\n        // thus the pop is ignored, an error will be created and the lexer will continue parsing in the previous mode.\n        const msg =\n          this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(\n            popToken\n          )\n\n        errors.push({\n          offset: popToken.startOffset,\n          line: popToken.startLine,\n          column: popToken.startColumn,\n          length: popToken.image.length,\n          message: msg\n        })\n      } else {\n        modeStack.pop()\n        const newMode = last(modeStack)!\n        patternIdxToConfig = this.patternIdxToConfig[newMode]\n        currCharCodeToPatternIdxToConfig =\n          this.charCodeToPatternIdxToConfig[newMode]\n        currModePatternsLength = patternIdxToConfig.length\n        const modeCanBeOptimized =\n          this.canModeBeOptimized[newMode] && this.config.safeMode === false\n\n        if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n          getPossiblePatterns = getPossiblePatternsOptimized\n        } else {\n          getPossiblePatterns = getPossiblePatternsSlow\n        }\n      }\n    }\n\n    function push_mode(this: Lexer, newMode: string) {\n      modeStack.push(newMode)\n      currCharCodeToPatternIdxToConfig =\n        this.charCodeToPatternIdxToConfig[newMode]\n\n      patternIdxToConfig = this.patternIdxToConfig[newMode]\n      currModePatternsLength = patternIdxToConfig.length\n\n      currModePatternsLength = patternIdxToConfig.length\n      const modeCanBeOptimized =\n        this.canModeBeOptimized[newMode] && this.config.safeMode === false\n\n      if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n        getPossiblePatterns = getPossiblePatternsOptimized\n      } else {\n        getPossiblePatterns = getPossiblePatternsSlow\n      }\n    }\n\n    // this pattern seems to avoid a V8 de-optimization, although that de-optimization does not\n    // seem to matter performance wise.\n    push_mode.call(this, initialMode)\n\n    let currConfig!: IPatternConfig\n\n    const recoveryEnabled = this.config.recoveryEnabled\n\n    while (offset < orgLength) {\n      matchedImage = null\n\n      const nextCharCode = orgText.charCodeAt(offset)\n      const chosenPatternIdxToConfig = getPossiblePatterns(nextCharCode)\n      const chosenPatternsLength = chosenPatternIdxToConfig.length\n\n      for (i = 0; i < chosenPatternsLength; i++) {\n        currConfig = chosenPatternIdxToConfig[i]\n        const currPattern = currConfig.pattern\n        payload = null\n\n        // manually in-lined because > 600 chars won't be in-lined in V8\n        const singleCharCode = currConfig.short\n        if (singleCharCode !== false) {\n          if (nextCharCode === singleCharCode) {\n            // single character string\n            matchedImage = currPattern as string\n          }\n        } else if (currConfig.isCustom === true) {\n          match = (currPattern as IRegExpExec).exec(\n            orgText,\n            offset,\n            matchedTokens,\n            groups\n          )\n          if (match !== null) {\n            matchedImage = match[0]\n            if ((match as CustomPatternMatcherReturn).payload !== undefined) {\n              payload = (match as CustomPatternMatcherReturn).payload\n            }\n          } else {\n            matchedImage = null\n          }\n        } else {\n          this.updateLastIndex(currPattern as RegExp, offset)\n          matchedImage = this.match(currPattern as RegExp, text, offset)\n        }\n\n        if (matchedImage !== null) {\n          // even though this pattern matched we must try a another longer alternative.\n          // this can be used to prioritize keywords over identifiers\n          longerAlt = currConfig.longerAlt\n          if (longerAlt !== undefined) {\n            // TODO: micro optimize, avoid extra prop access\n            // by saving/linking longerAlt on the original config?\n            const longerAltLength = longerAlt.length\n            for (k = 0; k < longerAltLength; k++) {\n              const longerAltConfig = patternIdxToConfig[longerAlt[k]]\n              const longerAltPattern = longerAltConfig.pattern\n              altPayload = null\n\n              // single Char can never be a longer alt so no need to test it.\n              // manually in-lined because > 600 chars won't be in-lined in V8\n              if (longerAltConfig.isCustom === true) {\n                match = (longerAltPattern as IRegExpExec).exec(\n                  orgText,\n                  offset,\n                  matchedTokens,\n                  groups\n                )\n                if (match !== null) {\n                  matchAltImage = match[0]\n                  if (\n                    (match as CustomPatternMatcherReturn).payload !== undefined\n                  ) {\n                    altPayload = (match as CustomPatternMatcherReturn).payload\n                  }\n                } else {\n                  matchAltImage = null\n                }\n              } else {\n                this.updateLastIndex(longerAltPattern as RegExp, offset)\n                matchAltImage = this.match(\n                  longerAltPattern as RegExp,\n                  text,\n                  offset\n                )\n              }\n\n              if (matchAltImage && matchAltImage.length > matchedImage.length) {\n                matchedImage = matchAltImage\n                payload = altPayload\n                currConfig = longerAltConfig\n                // Exit the loop early after matching one of the longer alternatives\n                // The first matched alternative takes precedence\n                break\n              }\n            }\n          }\n          break\n        }\n      }\n\n      // successful match\n      if (matchedImage !== null) {\n        imageLength = matchedImage.length\n        group = currConfig.group\n        if (group !== undefined) {\n          tokType = currConfig.tokenTypeIdx\n          // TODO: \"offset + imageLength\" and the new column may be computed twice in case of \"full\" location information inside\n          // createFullToken method\n          newToken = this.createTokenInstance(\n            matchedImage,\n            offset,\n            tokType,\n            currConfig.tokenType,\n            line,\n            column,\n            imageLength\n          )\n\n          this.handlePayload(newToken, payload)\n\n          // TODO: optimize NOOP in case there are no special groups?\n          if (group === false) {\n            matchedTokensIndex = this.addToken(\n              matchedTokens,\n              matchedTokensIndex,\n              newToken\n            )\n          } else {\n            groups[group].push(newToken)\n          }\n        }\n        text = this.chopInput(text, imageLength)\n        offset = offset + imageLength\n\n        // TODO: with newlines the column may be assigned twice\n        column = this.computeNewColumn(column!, imageLength)\n\n        if (trackLines === true && currConfig.canLineTerminator === true) {\n          let numOfLTsInMatch = 0\n          let foundTerminator\n          let lastLTEndOffset: number\n          lineTerminatorPattern.lastIndex = 0\n          do {\n            foundTerminator = lineTerminatorPattern.test(matchedImage)\n            if (foundTerminator === true) {\n              lastLTEndOffset = lineTerminatorPattern.lastIndex - 1\n              numOfLTsInMatch++\n            }\n          } while (foundTerminator === true)\n\n          if (numOfLTsInMatch !== 0) {\n            line = line! + numOfLTsInMatch\n            column = imageLength - lastLTEndOffset!\n            this.updateTokenEndLineColumnLocation(\n              newToken!,\n              group!,\n              lastLTEndOffset!,\n              numOfLTsInMatch,\n              line,\n              column,\n              imageLength\n            )\n          }\n        }\n        // will be NOOP if no modes present\n        this.handleModes(currConfig, pop_mode, push_mode, newToken!)\n      } else {\n        // error recovery, drop characters until we identify a valid token's start point\n        const errorStartOffset = offset\n        const errorLine = line\n        const errorColumn = column\n        let foundResyncPoint = recoveryEnabled === false\n\n        while (foundResyncPoint === false && offset < orgLength) {\n          // Identity Func (when sticky flag is enabled)\n          text = this.chopInput(text, 1)\n          offset++\n          for (j = 0; j < currModePatternsLength; j++) {\n            const currConfig = patternIdxToConfig[j]\n            const currPattern = currConfig.pattern\n\n            // manually in-lined because > 600 chars won't be in-lined in V8\n            const singleCharCode = currConfig.short\n            if (singleCharCode !== false) {\n              if (orgText.charCodeAt(offset) === singleCharCode) {\n                // single character string\n                foundResyncPoint = true\n              }\n            } else if (currConfig.isCustom === true) {\n              foundResyncPoint =\n                (currPattern as IRegExpExec).exec(\n                  orgText,\n                  offset,\n                  matchedTokens,\n                  groups\n                ) !== null\n            } else {\n              this.updateLastIndex(currPattern as RegExp, offset)\n              foundResyncPoint = (currPattern as RegExp).exec(text) !== null\n            }\n\n            if (foundResyncPoint === true) {\n              break\n            }\n          }\n        }\n\n        errLength = offset - errorStartOffset\n        // at this point we either re-synced or reached the end of the input text\n        msg = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(\n          orgText,\n          errorStartOffset,\n          errLength,\n          errorLine,\n          errorColumn\n        )\n        errors.push({\n          offset: errorStartOffset,\n          line: errorLine,\n          column: errorColumn,\n          length: errLength,\n          message: msg\n        })\n\n        if (recoveryEnabled === false) {\n          break\n        }\n      }\n    }\n\n    // if we do have custom patterns which push directly into the\n    // TODO: custom tokens should not push directly??\n    if (!this.hasCustom) {\n      // if we guessed a too large size for the tokens array this will shrink it to the right size.\n      matchedTokens.length = matchedTokensIndex\n    }\n\n    return {\n      tokens: matchedTokens,\n      groups: groups,\n      errors: errors\n    }\n  }\n\n  private handleModes(\n    config: IPatternConfig,\n    pop_mode: (tok: IToken) => void,\n    push_mode: (this: Lexer, pushMode: string) => void,\n    newToken: IToken\n  ) {\n    if (config.pop === true) {\n      // need to save the PUSH_MODE property as if the mode is popped\n      // patternIdxToPopMode is updated to reflect the new mode after popping the stack\n      const pushMode = config.push\n      pop_mode(newToken)\n      if (pushMode !== undefined) {\n        push_mode.call(this, pushMode)\n      }\n    } else if (config.push !== undefined) {\n      push_mode.call(this, config.push)\n    }\n  }\n\n  private chopInput(text: string, length: number): string {\n    return text.substring(length)\n  }\n\n  private updateLastIndex(regExp: RegExp, newLastIndex: number): void {\n    regExp.lastIndex = newLastIndex\n  }\n\n  // TODO: decrease this under 600 characters? inspect stripping comments option in TSC compiler\n  private updateTokenEndLineColumnLocation(\n    newToken: IToken,\n    group: string | false,\n    lastLTIdx: number,\n    numOfLTsInMatch: number,\n    line: number,\n    column: number,\n    imageLength: number\n  ): void {\n    let lastCharIsLT, fixForEndingInLT\n    if (group !== undefined) {\n      // a none skipped multi line Token, need to update endLine/endColumn\n      lastCharIsLT = lastLTIdx === imageLength - 1\n      fixForEndingInLT = lastCharIsLT ? -1 : 0\n      if (!(numOfLTsInMatch === 1 && lastCharIsLT === true)) {\n        // if a token ends in a LT that last LT only affects the line numbering of following Tokens\n        newToken.endLine = line + fixForEndingInLT\n        // the last LT in a token does not affect the endColumn either as the [columnStart ... columnEnd)\n        // inclusive to exclusive range.\n        newToken.endColumn = column - 1 + -fixForEndingInLT\n      }\n      // else single LT in the last character of a token, no need to modify the endLine/EndColumn\n    }\n  }\n\n  private computeNewColumn(oldColumn: number, imageLength: number) {\n    return oldColumn + imageLength\n  }\n\n  // Place holder, will be replaced by the correct variant according to the locationTracking option at runtime.\n  /* istanbul ignore next - place holder */\n  private createTokenInstance!: (...args: any[]) => IToken\n\n  private createOffsetOnlyToken(\n    image: string,\n    startOffset: number,\n    tokenTypeIdx: number,\n    tokenType: TokenType\n  ) {\n    return {\n      image,\n      startOffset,\n      tokenTypeIdx,\n      tokenType\n    }\n  }\n\n  private createStartOnlyToken(\n    image: string,\n    startOffset: number,\n    tokenTypeIdx: number,\n    tokenType: TokenType,\n    startLine: number,\n    startColumn: number\n  ) {\n    return {\n      image,\n      startOffset,\n      startLine,\n      startColumn,\n      tokenTypeIdx,\n      tokenType\n    }\n  }\n\n  private createFullToken(\n    image: string,\n    startOffset: number,\n    tokenTypeIdx: number,\n    tokenType: TokenType,\n    startLine: number,\n    startColumn: number,\n    imageLength: number\n  ): IToken {\n    return {\n      image,\n      startOffset,\n      endOffset: startOffset + imageLength - 1,\n      startLine,\n      endLine: startLine,\n      startColumn,\n      endColumn: startColumn + imageLength - 1,\n      tokenTypeIdx,\n      tokenType\n    }\n  }\n\n  // Place holder, will be replaced by the correct variant according to the locationTracking option at runtime.\n  /* istanbul ignore next - place holder */\n  private addToken!: (\n    tokenVector: IToken[],\n    index: number,\n    tokenToAdd: IToken\n  ) => number\n\n  private addTokenUsingPush(\n    tokenVector: IToken[],\n    index: number,\n    tokenToAdd: IToken\n  ): number {\n    tokenVector.push(tokenToAdd)\n    return index\n  }\n\n  private addTokenUsingMemberAccess(\n    tokenVector: IToken[],\n    index: number,\n    tokenToAdd: IToken\n  ): number {\n    tokenVector[index] = tokenToAdd\n    index++\n    return index\n  }\n\n  // Place holder, will be replaced by the correct variant according to the hasCustom flag option at runtime.\n  private handlePayload: (token: IToken, payload: any) => void\n\n  private handlePayloadNoCustom(token: IToken, payload: any): void {}\n\n  private handlePayloadWithCustom(token: IToken, payload: any): void {\n    if (payload !== null) {\n      token.payload = payload\n    }\n  }\n\n  // place holder to be replaced with chosen alternative at runtime\n  private match!: (\n    pattern: RegExp,\n    text: string,\n    offset: number\n  ) => string | null\n\n  private matchWithTest(\n    pattern: RegExp,\n    text: string,\n    offset: number\n  ): string | null {\n    const found = pattern.test(text)\n    if (found === true) {\n      return text.substring(offset, pattern.lastIndex)\n    }\n    return null\n  }\n\n  private matchWithExec(pattern: RegExp, text: string): string | null {\n    const regExpArray = pattern.exec(text)\n    return regExpArray !== null ? regExpArray[0] : null\n  }\n\n  // Duplicated from the parser's perf trace trait to allow future extraction\n  // of the lexer to a separate package.\n  TRACE_INIT = <T>(phaseDesc: string, phaseImpl: () => T): T => {\n    // No need to optimize this using NOOP pattern because\n    // It is not called in a hot spot...\n    if (this.traceInitPerf === true) {\n      this.traceInitIndent++\n      const indent = new Array(this.traceInitIndent + 1).join(\"\\t\")\n      if (this.traceInitIndent < this.traceInitMaxIdent) {\n        console.log(`${indent}--> <${phaseDesc}>`)\n      }\n      const { time, value } = timer(phaseImpl)\n      /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */\n      const traceMethod = time > 10 ? console.warn : console.log\n      if (this.traceInitIndent < this.traceInitMaxIdent) {\n        traceMethod(`${indent}<-- <${phaseDesc}> time: ${time}ms`)\n      }\n      this.traceInitIndent--\n      return value\n    } else {\n      return phaseImpl()\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}