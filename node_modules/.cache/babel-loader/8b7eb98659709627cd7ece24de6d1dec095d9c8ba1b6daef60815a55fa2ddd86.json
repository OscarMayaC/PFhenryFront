{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.serializeProduction = exports.serializeGrammar = exports.Terminal = exports.Alternation = exports.RepetitionWithSeparator = exports.Repetition = exports.RepetitionMandatoryWithSeparator = exports.RepetitionMandatory = exports.Option = exports.Alternative = exports.Rule = exports.NonTerminal = exports.AbstractProduction = void 0;\nvar map_1 = __importDefault(require(\"lodash/map\"));\nvar forEach_1 = __importDefault(require(\"lodash/forEach\"));\nvar isString_1 = __importDefault(require(\"lodash/isString\"));\nvar isRegExp_1 = __importDefault(require(\"lodash/isRegExp\"));\nvar pickBy_1 = __importDefault(require(\"lodash/pickBy\"));\nvar assign_1 = __importDefault(require(\"lodash/assign\"));\n// TODO: duplicated code to avoid extracting another sub-package -- how to avoid?\nfunction tokenLabel(tokType) {\n  if (hasTokenLabel(tokType)) {\n    return tokType.LABEL;\n  } else {\n    return tokType.name;\n  }\n}\n// TODO: duplicated code to avoid extracting another sub-package -- how to avoid?\nfunction hasTokenLabel(obj) {\n  return (0, isString_1.default)(obj.LABEL) && obj.LABEL !== \"\";\n}\nvar AbstractProduction = /** @class */function () {\n  function AbstractProduction(_definition) {\n    this._definition = _definition;\n  }\n  Object.defineProperty(AbstractProduction.prototype, \"definition\", {\n    get: function () {\n      return this._definition;\n    },\n    set: function (value) {\n      this._definition = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  AbstractProduction.prototype.accept = function (visitor) {\n    visitor.visit(this);\n    (0, forEach_1.default)(this.definition, function (prod) {\n      prod.accept(visitor);\n    });\n  };\n  return AbstractProduction;\n}();\nexports.AbstractProduction = AbstractProduction;\nvar NonTerminal = /** @class */function (_super) {\n  __extends(NonTerminal, _super);\n  function NonTerminal(options) {\n    var _this = _super.call(this, []) || this;\n    _this.idx = 1;\n    (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function (v) {\n      return v !== undefined;\n    }));\n    return _this;\n  }\n  Object.defineProperty(NonTerminal.prototype, \"definition\", {\n    get: function () {\n      if (this.referencedRule !== undefined) {\n        return this.referencedRule.definition;\n      }\n      return [];\n    },\n    set: function (definition) {\n      // immutable\n    },\n    enumerable: false,\n    configurable: true\n  });\n  NonTerminal.prototype.accept = function (visitor) {\n    visitor.visit(this);\n    // don't visit children of a reference, we will get cyclic infinite loops if we do so\n  };\n\n  return NonTerminal;\n}(AbstractProduction);\nexports.NonTerminal = NonTerminal;\nvar Rule = /** @class */function (_super) {\n  __extends(Rule, _super);\n  function Rule(options) {\n    var _this = _super.call(this, options.definition) || this;\n    _this.orgText = \"\";\n    (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function (v) {\n      return v !== undefined;\n    }));\n    return _this;\n  }\n  return Rule;\n}(AbstractProduction);\nexports.Rule = Rule;\nvar Alternative = /** @class */function (_super) {\n  __extends(Alternative, _super);\n  function Alternative(options) {\n    var _this = _super.call(this, options.definition) || this;\n    _this.ignoreAmbiguities = false;\n    (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function (v) {\n      return v !== undefined;\n    }));\n    return _this;\n  }\n  return Alternative;\n}(AbstractProduction);\nexports.Alternative = Alternative;\nvar Option = /** @class */function (_super) {\n  __extends(Option, _super);\n  function Option(options) {\n    var _this = _super.call(this, options.definition) || this;\n    _this.idx = 1;\n    (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function (v) {\n      return v !== undefined;\n    }));\n    return _this;\n  }\n  return Option;\n}(AbstractProduction);\nexports.Option = Option;\nvar RepetitionMandatory = /** @class */function (_super) {\n  __extends(RepetitionMandatory, _super);\n  function RepetitionMandatory(options) {\n    var _this = _super.call(this, options.definition) || this;\n    _this.idx = 1;\n    (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function (v) {\n      return v !== undefined;\n    }));\n    return _this;\n  }\n  return RepetitionMandatory;\n}(AbstractProduction);\nexports.RepetitionMandatory = RepetitionMandatory;\nvar RepetitionMandatoryWithSeparator = /** @class */function (_super) {\n  __extends(RepetitionMandatoryWithSeparator, _super);\n  function RepetitionMandatoryWithSeparator(options) {\n    var _this = _super.call(this, options.definition) || this;\n    _this.idx = 1;\n    (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function (v) {\n      return v !== undefined;\n    }));\n    return _this;\n  }\n  return RepetitionMandatoryWithSeparator;\n}(AbstractProduction);\nexports.RepetitionMandatoryWithSeparator = RepetitionMandatoryWithSeparator;\nvar Repetition = /** @class */function (_super) {\n  __extends(Repetition, _super);\n  function Repetition(options) {\n    var _this = _super.call(this, options.definition) || this;\n    _this.idx = 1;\n    (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function (v) {\n      return v !== undefined;\n    }));\n    return _this;\n  }\n  return Repetition;\n}(AbstractProduction);\nexports.Repetition = Repetition;\nvar RepetitionWithSeparator = /** @class */function (_super) {\n  __extends(RepetitionWithSeparator, _super);\n  function RepetitionWithSeparator(options) {\n    var _this = _super.call(this, options.definition) || this;\n    _this.idx = 1;\n    (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function (v) {\n      return v !== undefined;\n    }));\n    return _this;\n  }\n  return RepetitionWithSeparator;\n}(AbstractProduction);\nexports.RepetitionWithSeparator = RepetitionWithSeparator;\nvar Alternation = /** @class */function (_super) {\n  __extends(Alternation, _super);\n  function Alternation(options) {\n    var _this = _super.call(this, options.definition) || this;\n    _this.idx = 1;\n    _this.ignoreAmbiguities = false;\n    _this.hasPredicates = false;\n    (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function (v) {\n      return v !== undefined;\n    }));\n    return _this;\n  }\n  Object.defineProperty(Alternation.prototype, \"definition\", {\n    get: function () {\n      return this._definition;\n    },\n    set: function (value) {\n      this._definition = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return Alternation;\n}(AbstractProduction);\nexports.Alternation = Alternation;\nvar Terminal = /** @class */function () {\n  function Terminal(options) {\n    this.idx = 1;\n    (0, assign_1.default)(this, (0, pickBy_1.default)(options, function (v) {\n      return v !== undefined;\n    }));\n  }\n  Terminal.prototype.accept = function (visitor) {\n    visitor.visit(this);\n  };\n  return Terminal;\n}();\nexports.Terminal = Terminal;\nfunction serializeGrammar(topRules) {\n  return (0, map_1.default)(topRules, serializeProduction);\n}\nexports.serializeGrammar = serializeGrammar;\nfunction serializeProduction(node) {\n  function convertDefinition(definition) {\n    return (0, map_1.default)(definition, serializeProduction);\n  }\n  /* istanbul ignore else */\n  if (node instanceof NonTerminal) {\n    var serializedNonTerminal = {\n      type: \"NonTerminal\",\n      name: node.nonTerminalName,\n      idx: node.idx\n    };\n    if ((0, isString_1.default)(node.label)) {\n      serializedNonTerminal.label = node.label;\n    }\n    return serializedNonTerminal;\n  } else if (node instanceof Alternative) {\n    return {\n      type: \"Alternative\",\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof Option) {\n    return {\n      type: \"Option\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof RepetitionMandatory) {\n    return {\n      type: \"RepetitionMandatory\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof RepetitionMandatoryWithSeparator) {\n    return {\n      type: \"RepetitionMandatoryWithSeparator\",\n      idx: node.idx,\n      separator: serializeProduction(new Terminal({\n        terminalType: node.separator\n      })),\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof RepetitionWithSeparator) {\n    return {\n      type: \"RepetitionWithSeparator\",\n      idx: node.idx,\n      separator: serializeProduction(new Terminal({\n        terminalType: node.separator\n      })),\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof Repetition) {\n    return {\n      type: \"Repetition\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof Alternation) {\n    return {\n      type: \"Alternation\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof Terminal) {\n    var serializedTerminal = {\n      type: \"Terminal\",\n      name: node.terminalType.name,\n      label: tokenLabel(node.terminalType),\n      idx: node.idx\n    };\n    if ((0, isString_1.default)(node.label)) {\n      serializedTerminal.terminalLabel = node.label;\n    }\n    var pattern = node.terminalType.PATTERN;\n    if (node.terminalType.PATTERN) {\n      serializedTerminal.pattern = (0, isRegExp_1.default)(pattern) ? pattern.source : pattern;\n    }\n    return serializedTerminal;\n  } else if (node instanceof Rule) {\n    return {\n      type: \"Rule\",\n      name: node.name,\n      orgText: node.orgText,\n      definition: convertDefinition(node.definition)\n    };\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\nexports.serializeProduction = serializeProduction;","map":{"version":3,"names":["map_1","__importDefault","require","forEach_1","isString_1","isRegExp_1","pickBy_1","assign_1","tokenLabel","tokType","hasTokenLabel","LABEL","name","obj","default","AbstractProduction","_definition","Object","defineProperty","prototype","get","set","value","accept","visitor","visit","definition","prod","exports","NonTerminal","_super","__extends","options","_this","call","idx","v","undefined","referencedRule","Rule","orgText","Alternative","ignoreAmbiguities","Option","RepetitionMandatory","RepetitionMandatoryWithSeparator","Repetition","RepetitionWithSeparator","Alternation","hasPredicates","Terminal","serializeGrammar","topRules","serializeProduction","node","convertDefinition","serializedNonTerminal","type","nonTerminalName","label","separator","terminalType","serializedTerminal","terminalLabel","pattern","PATTERN","source","Error"],"sources":["/Users/rociopichardo/Desktop/PFhenryFront/node_modules/@chevrotain/gast/src/model.ts"],"sourcesContent":["import map from \"lodash/map\"\nimport forEach from \"lodash/forEach\"\nimport isString from \"lodash/isString\"\nimport isRegExp from \"lodash/isRegExp\"\nimport pickBy from \"lodash/pickBy\"\nimport assign from \"lodash/assign\"\nimport {\n  IGASTVisitor,\n  IProduction,\n  IProductionWithOccurrence,\n  ISerializedGast,\n  TokenType\n} from \"@chevrotain/types\"\n\n// TODO: duplicated code to avoid extracting another sub-package -- how to avoid?\nfunction tokenLabel(tokType: TokenType): string {\n  if (hasTokenLabel(tokType)) {\n    return tokType.LABEL\n  } else {\n    return tokType.name\n  }\n}\n\n// TODO: duplicated code to avoid extracting another sub-package -- how to avoid?\nfunction hasTokenLabel(\n  obj: TokenType\n): obj is TokenType & Pick<Required<TokenType>, \"LABEL\"> {\n  return isString(obj.LABEL) && obj.LABEL !== \"\"\n}\n\nexport abstract class AbstractProduction<T extends IProduction = IProduction>\n  implements IProduction\n{\n  public get definition(): T[] {\n    return this._definition\n  }\n  public set definition(value: T[]) {\n    this._definition = value\n  }\n\n  constructor(protected _definition: T[]) {}\n\n  accept(visitor: IGASTVisitor): void {\n    visitor.visit(this)\n    forEach(this.definition, (prod) => {\n      prod.accept(visitor)\n    })\n  }\n}\n\nexport class NonTerminal\n  extends AbstractProduction\n  implements IProductionWithOccurrence\n{\n  public nonTerminalName!: string\n  public label?: string\n  public referencedRule!: Rule\n  public idx: number = 1\n\n  constructor(options: {\n    nonTerminalName: string\n    label?: string\n    referencedRule?: Rule\n    idx?: number\n  }) {\n    super([])\n    assign(\n      this,\n      pickBy(options, (v) => v !== undefined)\n    )\n  }\n\n  set definition(definition: IProduction[]) {\n    // immutable\n  }\n\n  get definition(): IProduction[] {\n    if (this.referencedRule !== undefined) {\n      return this.referencedRule.definition\n    }\n    return []\n  }\n\n  accept(visitor: IGASTVisitor): void {\n    visitor.visit(this)\n    // don't visit children of a reference, we will get cyclic infinite loops if we do so\n  }\n}\n\nexport class Rule extends AbstractProduction {\n  public name!: string\n  public orgText: string = \"\"\n\n  constructor(options: {\n    name: string\n    definition: IProduction[]\n    orgText?: string\n  }) {\n    super(options.definition)\n    assign(\n      this,\n      pickBy(options, (v) => v !== undefined)\n    )\n  }\n}\n\nexport class Alternative extends AbstractProduction {\n  public ignoreAmbiguities: boolean = false\n\n  constructor(options: {\n    definition: IProduction[]\n    ignoreAmbiguities?: boolean\n  }) {\n    super(options.definition)\n    assign(\n      this,\n      pickBy(options, (v) => v !== undefined)\n    )\n  }\n}\n\nexport class Option\n  extends AbstractProduction\n  implements IProductionWithOccurrence\n{\n  public idx: number = 1\n  public maxLookahead?: number\n\n  constructor(options: {\n    definition: IProduction[]\n    idx?: number\n    maxLookahead?: number\n  }) {\n    super(options.definition)\n    assign(\n      this,\n      pickBy(options, (v) => v !== undefined)\n    )\n  }\n}\n\nexport class RepetitionMandatory\n  extends AbstractProduction\n  implements IProductionWithOccurrence\n{\n  public idx: number = 1\n  public maxLookahead?: number\n\n  constructor(options: {\n    definition: IProduction[]\n    idx?: number\n    maxLookahead?: number\n  }) {\n    super(options.definition)\n    assign(\n      this,\n      pickBy(options, (v) => v !== undefined)\n    )\n  }\n}\n\nexport class RepetitionMandatoryWithSeparator\n  extends AbstractProduction\n  implements IProductionWithOccurrence\n{\n  public separator!: TokenType\n  public idx: number = 1\n  public maxLookahead?: number\n\n  constructor(options: {\n    definition: IProduction[]\n    separator: TokenType\n    idx?: number\n  }) {\n    super(options.definition)\n    assign(\n      this,\n      pickBy(options, (v) => v !== undefined)\n    )\n  }\n}\n\nexport class Repetition\n  extends AbstractProduction\n  implements IProductionWithOccurrence\n{\n  public separator!: TokenType\n  public idx: number = 1\n  public maxLookahead?: number\n\n  constructor(options: {\n    definition: IProduction[]\n    idx?: number\n    maxLookahead?: number\n  }) {\n    super(options.definition)\n    assign(\n      this,\n      pickBy(options, (v) => v !== undefined)\n    )\n  }\n}\n\nexport class RepetitionWithSeparator\n  extends AbstractProduction\n  implements IProductionWithOccurrence\n{\n  public separator!: TokenType\n  public idx: number = 1\n  public maxLookahead?: number\n\n  constructor(options: {\n    definition: IProduction[]\n    separator: TokenType\n    idx?: number\n  }) {\n    super(options.definition)\n    assign(\n      this,\n      pickBy(options, (v) => v !== undefined)\n    )\n  }\n}\n\nexport class Alternation\n  extends AbstractProduction<Alternative>\n  implements IProductionWithOccurrence\n{\n  public idx: number = 1\n  public ignoreAmbiguities: boolean = false\n  public hasPredicates: boolean = false\n  public maxLookahead?: number\n\n  public get definition(): Alternative[] {\n    return this._definition\n  }\n  public set definition(value: Alternative[]) {\n    this._definition = value\n  }\n\n  constructor(options: {\n    definition: Alternative[]\n    idx?: number\n    ignoreAmbiguities?: boolean\n    hasPredicates?: boolean\n    maxLookahead?: number\n  }) {\n    super(options.definition)\n    assign(\n      this,\n      pickBy(options, (v) => v !== undefined)\n    )\n  }\n}\n\nexport class Terminal implements IProductionWithOccurrence {\n  public terminalType!: TokenType\n  public label?: string\n  public idx: number = 1\n\n  constructor(options: {\n    terminalType: TokenType\n    label?: string\n    idx?: number\n  }) {\n    assign(\n      this,\n      pickBy(options, (v) => v !== undefined)\n    )\n  }\n\n  accept(visitor: IGASTVisitor): void {\n    visitor.visit(this)\n  }\n}\n\nexport interface ISerializedBasic extends ISerializedGast {\n  type:\n    | \"Alternative\"\n    | \"Option\"\n    | \"RepetitionMandatory\"\n    | \"Repetition\"\n    | \"Alternation\"\n  idx?: number\n}\n\nexport interface ISerializedGastRule extends ISerializedGast {\n  type: \"Rule\"\n  name: string\n  orgText: string\n}\n\nexport interface ISerializedNonTerminal extends ISerializedGast {\n  type: \"NonTerminal\"\n  name: string\n  label?: string\n  idx: number\n}\n\nexport interface ISerializedTerminal extends ISerializedGast {\n  type: \"Terminal\"\n  name: string\n  terminalLabel?: string\n  label?: string\n  pattern?: string\n  idx: number\n}\n\nexport interface ISerializedTerminalWithSeparator extends ISerializedGast {\n  type: \"RepetitionMandatoryWithSeparator\" | \"RepetitionWithSeparator\"\n  idx: number\n  separator: ISerializedTerminal\n}\n\nexport type ISerializedGastAny =\n  | ISerializedBasic\n  | ISerializedGastRule\n  | ISerializedNonTerminal\n  | ISerializedTerminal\n  | ISerializedTerminalWithSeparator\n\nexport function serializeGrammar(topRules: Rule[]): ISerializedGast[] {\n  return map(topRules, serializeProduction)\n}\n\nexport function serializeProduction(node: IProduction): ISerializedGast {\n  function convertDefinition(definition: IProduction[]): ISerializedGast[] {\n    return map(definition, serializeProduction)\n  }\n  /* istanbul ignore else */\n  if (node instanceof NonTerminal) {\n    const serializedNonTerminal: ISerializedNonTerminal = {\n      type: \"NonTerminal\",\n      name: node.nonTerminalName,\n      idx: node.idx\n    }\n\n    if (isString(node.label)) {\n      serializedNonTerminal.label = node.label\n    }\n\n    return serializedNonTerminal\n  } else if (node instanceof Alternative) {\n    return <ISerializedBasic>{\n      type: \"Alternative\",\n      definition: convertDefinition(node.definition)\n    }\n  } else if (node instanceof Option) {\n    return <ISerializedBasic>{\n      type: \"Option\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    }\n  } else if (node instanceof RepetitionMandatory) {\n    return <ISerializedBasic>{\n      type: \"RepetitionMandatory\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    }\n  } else if (node instanceof RepetitionMandatoryWithSeparator) {\n    return <ISerializedTerminalWithSeparator>{\n      type: \"RepetitionMandatoryWithSeparator\",\n      idx: node.idx,\n      separator: <ISerializedTerminal>(\n        serializeProduction(new Terminal({ terminalType: node.separator }))\n      ),\n      definition: convertDefinition(node.definition)\n    }\n  } else if (node instanceof RepetitionWithSeparator) {\n    return <ISerializedTerminalWithSeparator>{\n      type: \"RepetitionWithSeparator\",\n      idx: node.idx,\n      separator: <ISerializedTerminal>(\n        serializeProduction(new Terminal({ terminalType: node.separator }))\n      ),\n      definition: convertDefinition(node.definition)\n    }\n  } else if (node instanceof Repetition) {\n    return <ISerializedBasic>{\n      type: \"Repetition\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    }\n  } else if (node instanceof Alternation) {\n    return <ISerializedBasic>{\n      type: \"Alternation\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    }\n  } else if (node instanceof Terminal) {\n    const serializedTerminal = <ISerializedTerminal>{\n      type: \"Terminal\",\n      name: node.terminalType.name,\n      label: tokenLabel(node.terminalType),\n      idx: node.idx\n    }\n\n    if (isString(node.label)) {\n      serializedTerminal.terminalLabel = node.label\n    }\n\n    const pattern = node.terminalType.PATTERN\n    if (node.terminalType.PATTERN) {\n      serializedTerminal.pattern = isRegExp(pattern)\n        ? (<any>pattern).source\n        : pattern\n    }\n\n    return serializedTerminal\n  } else if (node instanceof Rule) {\n    return <ISerializedGastRule>{\n      type: \"Rule\",\n      name: node.name,\n      orgText: node.orgText,\n      definition: convertDefinition(node.definition)\n    }\n  } else {\n    throw Error(\"non exhaustive match\")\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}