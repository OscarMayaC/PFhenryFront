{"ast":null,"code":"import PropertyNode from './core/PropertyNode.js';\nimport VarNode from './core/VarNode.js';\nimport AttributeNode from './core/AttributeNode.js';\nimport ConstNode from './core/ConstNode.js';\nimport UniformNode from './core/UniformNode.js';\nimport BufferNode from './accessors/BufferNode.js';\nimport PositionNode from './accessors/PositionNode.js';\nimport NormalNode from './accessors/NormalNode.js';\nimport CameraNode from './accessors/CameraNode.js';\nimport ModelNode from './accessors/ModelNode.js';\nimport TextureNode from './accessors/TextureNode.js';\nimport UVNode from './accessors/UVNode.js';\nimport OperatorNode from './math/OperatorNode.js';\nimport CondNode from './math/CondNode.js';\nimport MathNode from './math/MathNode.js';\nimport ArrayElementNode from './utils/ArrayElementNode.js';\nimport ConvertNode from './utils/ConvertNode.js';\nimport JoinNode from './utils/JoinNode.js';\nimport SplitNode from './utils/SplitNode.js';\nimport { getValueFromType } from './core/NodeUtils.js';\n\n// core nodes\nconst NodeHandler = {\n  construct(NodeClosure, params) {\n    const inputs = params.shift();\n    return NodeClosure(new ShaderNodeObjects(inputs), ...params);\n  },\n  get: function (node, prop) {\n    if (typeof prop === 'string' && node[prop] === undefined) {\n      if (/^[xyzwrgbastpq]{1,4}$/.test(prop) === true) {\n        // accessing properties ( swizzle )\n        prop = prop.replace(/r|s/g, 'x').replace(/g|t/g, 'y').replace(/b|p/g, 'z').replace(/a|q/g, 'w');\n        return new ShaderNodeObject(new SplitNode(node, prop));\n      } else if (/^\\d+$/.test(prop) === true) {\n        // accessing array\n        return new ShaderNodeObject(new ArrayElementNode(node, uint(Number(prop))));\n      }\n    }\n    return node[prop];\n  }\n};\nconst nodeObjects = new WeakMap();\nconst ShaderNodeObject = function (obj) {\n  const type = typeof obj;\n  if (type === 'number' || type === 'boolean') {\n    return new ShaderNodeObject(getAutoTypedConstNode(obj));\n  } else if (type === 'object') {\n    if (obj.isNode === true) {\n      let nodeObject = nodeObjects.get(obj);\n      if (nodeObject === undefined) {\n        nodeObject = new Proxy(obj, NodeHandler);\n        nodeObjects.set(obj, nodeObject);\n        nodeObjects.set(nodeObject, nodeObject);\n      }\n      return nodeObject;\n    }\n  }\n  return obj;\n};\nconst ShaderNodeObjects = function (objects) {\n  for (const name in objects) {\n    objects[name] = new ShaderNodeObject(objects[name]);\n  }\n  return objects;\n};\nconst getShaderNodeArray = array => {\n  const len = array.length;\n  for (let i = 0; i < len; i++) {\n    array[i] = new ShaderNodeObject(array[i]);\n  }\n  return array;\n};\nconst ShaderNodeProxy = function (NodeClass) {\n  let scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let factor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  if (scope === null) {\n    return function () {\n      for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {\n        params[_key] = arguments[_key];\n      }\n      return new ShaderNodeObject(new NodeClass(...getShaderNodeArray(params)));\n    };\n  } else if (factor === null) {\n    return function () {\n      for (var _len2 = arguments.length, params = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        params[_key2] = arguments[_key2];\n      }\n      return new ShaderNodeObject(new NodeClass(scope, ...getShaderNodeArray(params)));\n    };\n  } else {\n    factor = new ShaderNodeObject(factor);\n    return function () {\n      for (var _len3 = arguments.length, params = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        params[_key3] = arguments[_key3];\n      }\n      return new ShaderNodeObject(new NodeClass(scope, ...getShaderNodeArray(params), factor));\n    };\n  }\n};\nconst ShaderNodeScript = function (jsFunc) {\n  return (inputs, builder) => {\n    new ShaderNodeObjects(inputs);\n    return new ShaderNodeObject(jsFunc(inputs, builder));\n  };\n};\nconst bools = [false, true];\nconst uints = [0, 1, 2, 3];\nconst ints = [-1, -2];\nconst floats = [0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / (Math.PI * 2), Math.PI / 2];\nconst boolsCacheMap = new Map();\nfor (let bool of bools) boolsCacheMap.set(bool, new ConstNode(bool));\nconst uintsCacheMap = new Map();\nfor (let uint of uints) uintsCacheMap.set(uint, new ConstNode(uint, 'uint'));\nconst intsCacheMap = new Map([...uintsCacheMap].map(el => new ConstNode(el.value, 'int')));\nfor (let int of ints) intsCacheMap.set(int, new ConstNode(int, 'int'));\nconst floatsCacheMap = new Map([...intsCacheMap].map(el => new ConstNode(el.value)));\nfor (let float of floats) floatsCacheMap.set(float, new ConstNode(float));\nfor (let float of floats) floatsCacheMap.set(-float, new ConstNode(-float));\nconst constNodesCacheMap = new Map([...boolsCacheMap, ...floatsCacheMap]);\nconst getAutoTypedConstNode = value => {\n  if (constNodesCacheMap.has(value)) {\n    return constNodesCacheMap.get(value);\n  } else if (value.isNode === true) {\n    return value;\n  } else {\n    return new ConstNode(value);\n  }\n};\nconst ConvertType = function (type) {\n  let cacheMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return function () {\n    for (var _len4 = arguments.length, params = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      params[_key4] = arguments[_key4];\n    }\n    if (params.length === 0) {\n      return nodeObject(new ConstNode(getValueFromType(type), type));\n    } else {\n      if (type === 'color' && params[0].isNode !== true) {\n        params = [getValueFromType(type, ...params)];\n      }\n      if (params.length === 1 && cacheMap !== null && cacheMap.has(params[0])) {\n        return cacheMap.get(params[0]);\n      }\n      const nodes = params.map(getAutoTypedConstNode);\n      return nodeObject(new ConvertNode(nodes.length === 1 ? nodes[0] : new JoinNode(nodes), type));\n    }\n  };\n}; //\n// Node Material Shader Syntax\n//\n\nconst ShaderNode = new Proxy(ShaderNodeScript, NodeHandler);\nconst nodeObject = val => {\n  return new ShaderNodeObject(val);\n};\nconst uniform = value => {\n  var _value$node;\n\n  // TODO: get ConstNode from .traverse() in the future\n  value = value.isNode === true ? ((_value$node = value.node) === null || _value$node === void 0 ? void 0 : _value$node.value) || value.value : value;\n  return nodeObject(new UniformNode(value, value.nodeType));\n};\nconst label = (node, name) => {\n  node = nodeObject(node);\n  if (node.isVarNode === true) {\n    node.name = name;\n    return node;\n  }\n  return nodeObject(new VarNode(node, name));\n};\nconst temp = node => nodeObject(new VarNode(nodeObject(node)));\nconst color = new ConvertType('color');\nconst float = new ConvertType('float', floatsCacheMap);\nconst int = new ConvertType('int', intsCacheMap);\nconst uint = new ConvertType('uint', uintsCacheMap);\nconst bool = new ConvertType('bool', boolsCacheMap);\nconst vec2 = new ConvertType('vec2');\nconst ivec2 = new ConvertType('ivec2');\nconst uvec2 = new ConvertType('uvec2');\nconst bvec2 = new ConvertType('bvec2');\nconst vec3 = new ConvertType('vec3');\nconst ivec3 = new ConvertType('ivec3');\nconst uvec3 = new ConvertType('uvec3');\nconst bvec3 = new ConvertType('bvec3');\nconst vec4 = new ConvertType('vec4');\nconst ivec4 = new ConvertType('ivec4');\nconst uvec4 = new ConvertType('uvec4');\nconst bvec4 = new ConvertType('bvec4');\nconst mat3 = new ConvertType('mat3');\nconst imat3 = new ConvertType('imat3');\nconst umat3 = new ConvertType('umat3');\nconst bmat3 = new ConvertType('bmat3');\nconst mat4 = new ConvertType('mat4');\nconst imat4 = new ConvertType('imat4');\nconst umat4 = new ConvertType('umat4');\nconst bmat4 = new ConvertType('bmat4');\nconst join = function () {\n  for (var _len5 = arguments.length, params = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n    params[_key5] = arguments[_key5];\n  }\n  return nodeObject(new JoinNode(getShaderNodeArray(params)));\n};\nconst uv = function () {\n  for (var _len6 = arguments.length, params = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n    params[_key6] = arguments[_key6];\n  }\n  return nodeObject(new UVNode(...params));\n};\nconst attribute = function () {\n  for (var _len7 = arguments.length, params = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n    params[_key7] = arguments[_key7];\n  }\n  return nodeObject(new AttributeNode(...params));\n};\nconst buffer = function () {\n  for (var _len8 = arguments.length, params = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n    params[_key8] = arguments[_key8];\n  }\n  return nodeObject(new BufferNode(...params));\n};\nconst texture = function () {\n  for (var _len9 = arguments.length, params = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n    params[_key9] = arguments[_key9];\n  }\n  return nodeObject(new TextureNode(...params));\n};\nconst sampler = texture => nodeObject(new ConvertNode(texture.isNode === true ? texture : new TextureNode(texture), 'sampler'));\nconst cond = function () {\n  for (var _len10 = arguments.length, params = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n    params[_key10] = arguments[_key10];\n  }\n  return nodeObject(new CondNode(...getShaderNodeArray(params)));\n};\nconst addTo = function (varNode) {\n  for (var _len11 = arguments.length, params = new Array(_len11 > 1 ? _len11 - 1 : 0), _key11 = 1; _key11 < _len11; _key11++) {\n    params[_key11 - 1] = arguments[_key11];\n  }\n  varNode.node = add(varNode.node, ...getShaderNodeArray(params));\n  return nodeObject(varNode);\n};\nconst add = new ShaderNodeProxy(OperatorNode, '+');\nconst sub = new ShaderNodeProxy(OperatorNode, '-');\nconst mul = new ShaderNodeProxy(OperatorNode, '*');\nconst div = new ShaderNodeProxy(OperatorNode, '/');\nconst remainder = new ShaderNodeProxy(OperatorNode, '%');\nconst equal = new ShaderNodeProxy(OperatorNode, '==');\nconst assign = new ShaderNodeProxy(OperatorNode, '=');\nconst lessThan = new ShaderNodeProxy(OperatorNode, '<');\nconst greaterThan = new ShaderNodeProxy(OperatorNode, '>');\nconst lessThanEqual = new ShaderNodeProxy(OperatorNode, '<=');\nconst greaterThanEqual = new ShaderNodeProxy(OperatorNode, '>=');\nconst and = new ShaderNodeProxy(OperatorNode, '&&');\nconst or = new ShaderNodeProxy(OperatorNode, '||');\nconst xor = new ShaderNodeProxy(OperatorNode, '^^');\nconst bitAnd = new ShaderNodeProxy(OperatorNode, '&');\nconst bitOr = new ShaderNodeProxy(OperatorNode, '|');\nconst bitXor = new ShaderNodeProxy(OperatorNode, '^');\nconst shiftLeft = new ShaderNodeProxy(OperatorNode, '<<');\nconst shiftRight = new ShaderNodeProxy(OperatorNode, '>>');\nconst element = new ShaderNodeProxy(ArrayElementNode);\nconst normalGeometry = new ShaderNodeObject(new NormalNode(NormalNode.GEOMETRY));\nconst normalLocal = new ShaderNodeObject(new NormalNode(NormalNode.LOCAL));\nconst normalWorld = new ShaderNodeObject(new NormalNode(NormalNode.WORLD));\nconst normalView = new ShaderNodeObject(new NormalNode(NormalNode.VIEW));\nconst transformedNormalView = new ShaderNodeObject(new VarNode(new NormalNode(NormalNode.VIEW), 'TransformedNormalView', 'vec3'));\nconst positionLocal = new ShaderNodeObject(new PositionNode(PositionNode.LOCAL));\nconst positionWorld = new ShaderNodeObject(new PositionNode(PositionNode.WORLD));\nconst positionView = new ShaderNodeObject(new PositionNode(PositionNode.VIEW));\nconst positionViewDirection = new ShaderNodeObject(new PositionNode(PositionNode.VIEW_DIRECTION));\nconst viewMatrix = new ShaderNodeObject(new ModelNode(ModelNode.VIEW_MATRIX));\nconst cameraPosition = new ShaderNodeObject(new CameraNode(CameraNode.POSITION));\nconst diffuseColor = new ShaderNodeObject(new PropertyNode('DiffuseColor', 'vec4'));\nconst roughness = new ShaderNodeObject(new PropertyNode('Roughness', 'float'));\nconst metalness = new ShaderNodeObject(new PropertyNode('Metalness', 'float'));\nconst alphaTest = new ShaderNodeObject(new PropertyNode('AlphaTest', 'float'));\nconst specularColor = new ShaderNodeObject(new PropertyNode('SpecularColor', 'color'));\nconst abs = new ShaderNodeProxy(MathNode, 'abs');\nconst acos = new ShaderNodeProxy(MathNode, 'acos');\nconst asin = new ShaderNodeProxy(MathNode, 'asin');\nconst atan = new ShaderNodeProxy(MathNode, 'atan');\nconst ceil = new ShaderNodeProxy(MathNode, 'ceil');\nconst clamp = new ShaderNodeProxy(MathNode, 'clamp');\nconst cos = new ShaderNodeProxy(MathNode, 'cos');\nconst cross = new ShaderNodeProxy(MathNode, 'cross');\nconst degrees = new ShaderNodeProxy(MathNode, 'degrees');\nconst dFdx = new ShaderNodeProxy(MathNode, 'dFdx');\nconst dFdy = new ShaderNodeProxy(MathNode, 'dFdy');\nconst distance = new ShaderNodeProxy(MathNode, 'distance');\nconst dot = new ShaderNodeProxy(MathNode, 'dot');\nconst exp = new ShaderNodeProxy(MathNode, 'exp');\nconst exp2 = new ShaderNodeProxy(MathNode, 'exp2');\nconst faceforward = new ShaderNodeProxy(MathNode, 'faceforward');\nconst floor = new ShaderNodeProxy(MathNode, 'floor');\nconst fract = new ShaderNodeProxy(MathNode, 'fract');\nconst invert = new ShaderNodeProxy(MathNode, 'invert');\nconst inversesqrt = new ShaderNodeProxy(MathNode, 'inversesqrt');\nconst length = new ShaderNodeProxy(MathNode, 'length');\nconst log = new ShaderNodeProxy(MathNode, 'log');\nconst log2 = new ShaderNodeProxy(MathNode, 'log2');\nconst max = new ShaderNodeProxy(MathNode, 'max');\nconst min = new ShaderNodeProxy(MathNode, 'min');\nconst mix = new ShaderNodeProxy(MathNode, 'mix');\nconst mod = new ShaderNodeProxy(MathNode, 'mod');\nconst negate = new ShaderNodeProxy(MathNode, 'negate');\nconst normalize = new ShaderNodeProxy(MathNode, 'normalize');\nconst pow = new ShaderNodeProxy(MathNode, 'pow');\nconst pow2 = new ShaderNodeProxy(MathNode, 'pow', 2);\nconst pow3 = new ShaderNodeProxy(MathNode, 'pow', 3);\nconst pow4 = new ShaderNodeProxy(MathNode, 'pow', 4);\nconst radians = new ShaderNodeProxy(MathNode, 'radians');\nconst reflect = new ShaderNodeProxy(MathNode, 'reflect');\nconst refract = new ShaderNodeProxy(MathNode, 'refract');\nconst round = new ShaderNodeProxy(MathNode, 'round');\nconst saturate = new ShaderNodeProxy(MathNode, 'saturate');\nconst sign = new ShaderNodeProxy(MathNode, 'sign');\nconst sin = new ShaderNodeProxy(MathNode, 'sin');\nconst smoothstep = new ShaderNodeProxy(MathNode, 'smoothstep');\nconst sqrt = new ShaderNodeProxy(MathNode, 'sqrt');\nconst step = new ShaderNodeProxy(MathNode, 'step');\nconst tan = new ShaderNodeProxy(MathNode, 'tan');\nconst transformDirection = new ShaderNodeProxy(MathNode, 'transformDirection');\nconst EPSILON = float(1e-6);\nconst INFINITY = float(1e6);\nexport { EPSILON, INFINITY, ShaderNode, abs, acos, add, addTo, alphaTest, and, asin, assign, atan, attribute, bitAnd, bitOr, bitXor, bmat3, bmat4, bool, buffer, bvec2, bvec3, bvec4, cameraPosition, ceil, clamp, color, cond, cos, cross, dFdx, dFdy, degrees, diffuseColor, distance, div, dot, element, equal, exp, exp2, faceforward, float, floor, fract, greaterThan, greaterThanEqual, imat3, imat4, int, inversesqrt, invert, ivec2, ivec3, ivec4, join, label, length, lessThan, lessThanEqual, log, log2, mat3, mat4, max, metalness, min, mix, mod, mul, negate, nodeObject, normalGeometry, normalLocal, normalView, normalWorld, normalize, or, positionLocal, positionView, positionViewDirection, positionWorld, pow, pow2, pow3, pow4, radians, reflect, refract, remainder, roughness, round, sampler, saturate, shiftLeft, shiftRight, sign, sin, smoothstep, specularColor, sqrt, step, sub, tan, temp, texture, transformDirection, transformedNormalView, uint, umat3, umat4, uniform, uv, uvec2, uvec3, uvec4, vec2, vec3, vec4, viewMatrix, xor };","map":{"version":3,"names":["PropertyNode","VarNode","AttributeNode","ConstNode","UniformNode","BufferNode","PositionNode","NormalNode","CameraNode","ModelNode","TextureNode","UVNode","OperatorNode","CondNode","MathNode","ArrayElementNode","ConvertNode","JoinNode","SplitNode","getValueFromType","NodeHandler","construct","NodeClosure","params","inputs","shift","ShaderNodeObjects","get","node","prop","undefined","test","replace","ShaderNodeObject","uint","Number","nodeObjects","WeakMap","obj","type","getAutoTypedConstNode","isNode","nodeObject","Proxy","set","objects","name","getShaderNodeArray","array","len","length","i","ShaderNodeProxy","NodeClass","scope","arguments","factor","_len","Array","_key","_len2","_key2","_len3","_key3","ShaderNodeScript","jsFunc","builder","bools","uints","ints","floats","Math","PI","boolsCacheMap","Map","bool","uintsCacheMap","intsCacheMap","map","el","value","int","floatsCacheMap","float","constNodesCacheMap","has","ConvertType","cacheMap","_len4","_key4","nodes","ShaderNode","val","uniform","_value$node","nodeType","label","isVarNode","temp","color","vec2","ivec2","uvec2","bvec2","vec3","ivec3","uvec3","bvec3","vec4","ivec4","uvec4","bvec4","mat3","imat3","umat3","bmat3","mat4","imat4","umat4","bmat4","join","_len5","_key5","uv","_len6","_key6","attribute","_len7","_key7","buffer","_len8","_key8","texture","_len9","_key9","sampler","cond","_len10","_key10","addTo","varNode","_len11","_key11","add","sub","mul","div","remainder","equal","assign","lessThan","greaterThan","lessThanEqual","greaterThanEqual","and","or","xor","bitAnd","bitOr","bitXor","shiftLeft","shiftRight","element","normalGeometry","GEOMETRY","normalLocal","LOCAL","normalWorld","WORLD","normalView","VIEW","transformedNormalView","positionLocal","positionWorld","positionView","positionViewDirection","VIEW_DIRECTION","viewMatrix","VIEW_MATRIX","cameraPosition","POSITION","diffuseColor","roughness","metalness","alphaTest","specularColor","abs","acos","asin","atan","ceil","clamp","cos","cross","degrees","dFdx","dFdy","distance","dot","exp","exp2","faceforward","floor","fract","invert","inversesqrt","log","log2","max","min","mix","mod","negate","normalize","pow","pow2","pow3","pow4","radians","reflect","refract","round","saturate","sign","sin","smoothstep","sqrt","step","tan","transformDirection","EPSILON","INFINITY"],"sources":["/Users/rociopichardo/Desktop/PFhenryFront/node_modules/three-stdlib/nodes/ShaderNode.js"],"sourcesContent":["import PropertyNode from './core/PropertyNode.js';\nimport VarNode from './core/VarNode.js';\nimport AttributeNode from './core/AttributeNode.js';\nimport ConstNode from './core/ConstNode.js';\nimport UniformNode from './core/UniformNode.js';\nimport BufferNode from './accessors/BufferNode.js';\nimport PositionNode from './accessors/PositionNode.js';\nimport NormalNode from './accessors/NormalNode.js';\nimport CameraNode from './accessors/CameraNode.js';\nimport ModelNode from './accessors/ModelNode.js';\nimport TextureNode from './accessors/TextureNode.js';\nimport UVNode from './accessors/UVNode.js';\nimport OperatorNode from './math/OperatorNode.js';\nimport CondNode from './math/CondNode.js';\nimport MathNode from './math/MathNode.js';\nimport ArrayElementNode from './utils/ArrayElementNode.js';\nimport ConvertNode from './utils/ConvertNode.js';\nimport JoinNode from './utils/JoinNode.js';\nimport SplitNode from './utils/SplitNode.js';\nimport { getValueFromType } from './core/NodeUtils.js';\n\n// core nodes\nconst NodeHandler = {\n  construct(NodeClosure, params) {\n    const inputs = params.shift();\n    return NodeClosure(new ShaderNodeObjects(inputs), ...params);\n  },\n\n  get: function (node, prop) {\n    if (typeof prop === 'string' && node[prop] === undefined) {\n      if (/^[xyzwrgbastpq]{1,4}$/.test(prop) === true) {\n        // accessing properties ( swizzle )\n        prop = prop.replace(/r|s/g, 'x').replace(/g|t/g, 'y').replace(/b|p/g, 'z').replace(/a|q/g, 'w');\n        return new ShaderNodeObject(new SplitNode(node, prop));\n      } else if (/^\\d+$/.test(prop) === true) {\n        // accessing array\n        return new ShaderNodeObject(new ArrayElementNode(node, uint(Number(prop))));\n      }\n    }\n\n    return node[prop];\n  }\n};\nconst nodeObjects = new WeakMap();\n\nconst ShaderNodeObject = function (obj) {\n  const type = typeof obj;\n\n  if (type === 'number' || type === 'boolean') {\n    return new ShaderNodeObject(getAutoTypedConstNode(obj));\n  } else if (type === 'object') {\n    if (obj.isNode === true) {\n      let nodeObject = nodeObjects.get(obj);\n\n      if (nodeObject === undefined) {\n        nodeObject = new Proxy(obj, NodeHandler);\n        nodeObjects.set(obj, nodeObject);\n        nodeObjects.set(nodeObject, nodeObject);\n      }\n\n      return nodeObject;\n    }\n  }\n\n  return obj;\n};\n\nconst ShaderNodeObjects = function (objects) {\n  for (const name in objects) {\n    objects[name] = new ShaderNodeObject(objects[name]);\n  }\n\n  return objects;\n};\n\nconst getShaderNodeArray = array => {\n  const len = array.length;\n\n  for (let i = 0; i < len; i++) {\n    array[i] = new ShaderNodeObject(array[i]);\n  }\n\n  return array;\n};\n\nconst ShaderNodeProxy = function (NodeClass, scope = null, factor = null) {\n  if (scope === null) {\n    return (...params) => {\n      return new ShaderNodeObject(new NodeClass(...getShaderNodeArray(params)));\n    };\n  } else if (factor === null) {\n    return (...params) => {\n      return new ShaderNodeObject(new NodeClass(scope, ...getShaderNodeArray(params)));\n    };\n  } else {\n    factor = new ShaderNodeObject(factor);\n    return (...params) => {\n      return new ShaderNodeObject(new NodeClass(scope, ...getShaderNodeArray(params), factor));\n    };\n  }\n};\n\nconst ShaderNodeScript = function (jsFunc) {\n  return (inputs, builder) => {\n    new ShaderNodeObjects(inputs);\n    return new ShaderNodeObject(jsFunc(inputs, builder));\n  };\n};\n\nconst bools = [false, true];\nconst uints = [0, 1, 2, 3];\nconst ints = [-1, -2];\nconst floats = [0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / (Math.PI * 2), Math.PI / 2];\nconst boolsCacheMap = new Map();\n\nfor (let bool of bools) boolsCacheMap.set(bool, new ConstNode(bool));\n\nconst uintsCacheMap = new Map();\n\nfor (let uint of uints) uintsCacheMap.set(uint, new ConstNode(uint, 'uint'));\n\nconst intsCacheMap = new Map([...uintsCacheMap].map(el => new ConstNode(el.value, 'int')));\n\nfor (let int of ints) intsCacheMap.set(int, new ConstNode(int, 'int'));\n\nconst floatsCacheMap = new Map([...intsCacheMap].map(el => new ConstNode(el.value)));\n\nfor (let float of floats) floatsCacheMap.set(float, new ConstNode(float));\n\nfor (let float of floats) floatsCacheMap.set(-float, new ConstNode(-float));\n\nconst constNodesCacheMap = new Map([...boolsCacheMap, ...floatsCacheMap]);\n\nconst getAutoTypedConstNode = value => {\n  if (constNodesCacheMap.has(value)) {\n    return constNodesCacheMap.get(value);\n  } else if (value.isNode === true) {\n    return value;\n  } else {\n    return new ConstNode(value);\n  }\n};\n\nconst ConvertType = function (type, cacheMap = null) {\n  return (...params) => {\n    if (params.length === 0) {\n      return nodeObject(new ConstNode(getValueFromType(type), type));\n    } else {\n      if (type === 'color' && params[0].isNode !== true) {\n        params = [getValueFromType(type, ...params)];\n      }\n\n      if (params.length === 1 && cacheMap !== null && cacheMap.has(params[0])) {\n        return cacheMap.get(params[0]);\n      }\n\n      const nodes = params.map(getAutoTypedConstNode);\n      return nodeObject(new ConvertNode(nodes.length === 1 ? nodes[0] : new JoinNode(nodes), type));\n    }\n  };\n}; //\n// Node Material Shader Syntax\n//\n\n\nconst ShaderNode = new Proxy(ShaderNodeScript, NodeHandler);\nconst nodeObject = val => {\n  return new ShaderNodeObject(val);\n};\nconst uniform = value => {\n  var _value$node;\n\n  // TODO: get ConstNode from .traverse() in the future\n  value = value.isNode === true ? ((_value$node = value.node) === null || _value$node === void 0 ? void 0 : _value$node.value) || value.value : value;\n  return nodeObject(new UniformNode(value, value.nodeType));\n};\nconst label = (node, name) => {\n  node = nodeObject(node);\n\n  if (node.isVarNode === true) {\n    node.name = name;\n    return node;\n  }\n\n  return nodeObject(new VarNode(node, name));\n};\nconst temp = node => nodeObject(new VarNode(nodeObject(node)));\nconst color = new ConvertType('color');\nconst float = new ConvertType('float', floatsCacheMap);\nconst int = new ConvertType('int', intsCacheMap);\nconst uint = new ConvertType('uint', uintsCacheMap);\nconst bool = new ConvertType('bool', boolsCacheMap);\nconst vec2 = new ConvertType('vec2');\nconst ivec2 = new ConvertType('ivec2');\nconst uvec2 = new ConvertType('uvec2');\nconst bvec2 = new ConvertType('bvec2');\nconst vec3 = new ConvertType('vec3');\nconst ivec3 = new ConvertType('ivec3');\nconst uvec3 = new ConvertType('uvec3');\nconst bvec3 = new ConvertType('bvec3');\nconst vec4 = new ConvertType('vec4');\nconst ivec4 = new ConvertType('ivec4');\nconst uvec4 = new ConvertType('uvec4');\nconst bvec4 = new ConvertType('bvec4');\nconst mat3 = new ConvertType('mat3');\nconst imat3 = new ConvertType('imat3');\nconst umat3 = new ConvertType('umat3');\nconst bmat3 = new ConvertType('bmat3');\nconst mat4 = new ConvertType('mat4');\nconst imat4 = new ConvertType('imat4');\nconst umat4 = new ConvertType('umat4');\nconst bmat4 = new ConvertType('bmat4');\nconst join = (...params) => nodeObject(new JoinNode(getShaderNodeArray(params)));\nconst uv = (...params) => nodeObject(new UVNode(...params));\nconst attribute = (...params) => nodeObject(new AttributeNode(...params));\nconst buffer = (...params) => nodeObject(new BufferNode(...params));\nconst texture = (...params) => nodeObject(new TextureNode(...params));\nconst sampler = texture => nodeObject(new ConvertNode(texture.isNode === true ? texture : new TextureNode(texture), 'sampler'));\nconst cond = (...params) => nodeObject(new CondNode(...getShaderNodeArray(params)));\nconst addTo = (varNode, ...params) => {\n  varNode.node = add(varNode.node, ...getShaderNodeArray(params));\n  return nodeObject(varNode);\n};\nconst add = new ShaderNodeProxy(OperatorNode, '+');\nconst sub = new ShaderNodeProxy(OperatorNode, '-');\nconst mul = new ShaderNodeProxy(OperatorNode, '*');\nconst div = new ShaderNodeProxy(OperatorNode, '/');\nconst remainder = new ShaderNodeProxy(OperatorNode, '%');\nconst equal = new ShaderNodeProxy(OperatorNode, '==');\nconst assign = new ShaderNodeProxy(OperatorNode, '=');\nconst lessThan = new ShaderNodeProxy(OperatorNode, '<');\nconst greaterThan = new ShaderNodeProxy(OperatorNode, '>');\nconst lessThanEqual = new ShaderNodeProxy(OperatorNode, '<=');\nconst greaterThanEqual = new ShaderNodeProxy(OperatorNode, '>=');\nconst and = new ShaderNodeProxy(OperatorNode, '&&');\nconst or = new ShaderNodeProxy(OperatorNode, '||');\nconst xor = new ShaderNodeProxy(OperatorNode, '^^');\nconst bitAnd = new ShaderNodeProxy(OperatorNode, '&');\nconst bitOr = new ShaderNodeProxy(OperatorNode, '|');\nconst bitXor = new ShaderNodeProxy(OperatorNode, '^');\nconst shiftLeft = new ShaderNodeProxy(OperatorNode, '<<');\nconst shiftRight = new ShaderNodeProxy(OperatorNode, '>>');\nconst element = new ShaderNodeProxy(ArrayElementNode);\nconst normalGeometry = new ShaderNodeObject(new NormalNode(NormalNode.GEOMETRY));\nconst normalLocal = new ShaderNodeObject(new NormalNode(NormalNode.LOCAL));\nconst normalWorld = new ShaderNodeObject(new NormalNode(NormalNode.WORLD));\nconst normalView = new ShaderNodeObject(new NormalNode(NormalNode.VIEW));\nconst transformedNormalView = new ShaderNodeObject(new VarNode(new NormalNode(NormalNode.VIEW), 'TransformedNormalView', 'vec3'));\nconst positionLocal = new ShaderNodeObject(new PositionNode(PositionNode.LOCAL));\nconst positionWorld = new ShaderNodeObject(new PositionNode(PositionNode.WORLD));\nconst positionView = new ShaderNodeObject(new PositionNode(PositionNode.VIEW));\nconst positionViewDirection = new ShaderNodeObject(new PositionNode(PositionNode.VIEW_DIRECTION));\nconst viewMatrix = new ShaderNodeObject(new ModelNode(ModelNode.VIEW_MATRIX));\nconst cameraPosition = new ShaderNodeObject(new CameraNode(CameraNode.POSITION));\nconst diffuseColor = new ShaderNodeObject(new PropertyNode('DiffuseColor', 'vec4'));\nconst roughness = new ShaderNodeObject(new PropertyNode('Roughness', 'float'));\nconst metalness = new ShaderNodeObject(new PropertyNode('Metalness', 'float'));\nconst alphaTest = new ShaderNodeObject(new PropertyNode('AlphaTest', 'float'));\nconst specularColor = new ShaderNodeObject(new PropertyNode('SpecularColor', 'color'));\nconst abs = new ShaderNodeProxy(MathNode, 'abs');\nconst acos = new ShaderNodeProxy(MathNode, 'acos');\nconst asin = new ShaderNodeProxy(MathNode, 'asin');\nconst atan = new ShaderNodeProxy(MathNode, 'atan');\nconst ceil = new ShaderNodeProxy(MathNode, 'ceil');\nconst clamp = new ShaderNodeProxy(MathNode, 'clamp');\nconst cos = new ShaderNodeProxy(MathNode, 'cos');\nconst cross = new ShaderNodeProxy(MathNode, 'cross');\nconst degrees = new ShaderNodeProxy(MathNode, 'degrees');\nconst dFdx = new ShaderNodeProxy(MathNode, 'dFdx');\nconst dFdy = new ShaderNodeProxy(MathNode, 'dFdy');\nconst distance = new ShaderNodeProxy(MathNode, 'distance');\nconst dot = new ShaderNodeProxy(MathNode, 'dot');\nconst exp = new ShaderNodeProxy(MathNode, 'exp');\nconst exp2 = new ShaderNodeProxy(MathNode, 'exp2');\nconst faceforward = new ShaderNodeProxy(MathNode, 'faceforward');\nconst floor = new ShaderNodeProxy(MathNode, 'floor');\nconst fract = new ShaderNodeProxy(MathNode, 'fract');\nconst invert = new ShaderNodeProxy(MathNode, 'invert');\nconst inversesqrt = new ShaderNodeProxy(MathNode, 'inversesqrt');\nconst length = new ShaderNodeProxy(MathNode, 'length');\nconst log = new ShaderNodeProxy(MathNode, 'log');\nconst log2 = new ShaderNodeProxy(MathNode, 'log2');\nconst max = new ShaderNodeProxy(MathNode, 'max');\nconst min = new ShaderNodeProxy(MathNode, 'min');\nconst mix = new ShaderNodeProxy(MathNode, 'mix');\nconst mod = new ShaderNodeProxy(MathNode, 'mod');\nconst negate = new ShaderNodeProxy(MathNode, 'negate');\nconst normalize = new ShaderNodeProxy(MathNode, 'normalize');\nconst pow = new ShaderNodeProxy(MathNode, 'pow');\nconst pow2 = new ShaderNodeProxy(MathNode, 'pow', 2);\nconst pow3 = new ShaderNodeProxy(MathNode, 'pow', 3);\nconst pow4 = new ShaderNodeProxy(MathNode, 'pow', 4);\nconst radians = new ShaderNodeProxy(MathNode, 'radians');\nconst reflect = new ShaderNodeProxy(MathNode, 'reflect');\nconst refract = new ShaderNodeProxy(MathNode, 'refract');\nconst round = new ShaderNodeProxy(MathNode, 'round');\nconst saturate = new ShaderNodeProxy(MathNode, 'saturate');\nconst sign = new ShaderNodeProxy(MathNode, 'sign');\nconst sin = new ShaderNodeProxy(MathNode, 'sin');\nconst smoothstep = new ShaderNodeProxy(MathNode, 'smoothstep');\nconst sqrt = new ShaderNodeProxy(MathNode, 'sqrt');\nconst step = new ShaderNodeProxy(MathNode, 'step');\nconst tan = new ShaderNodeProxy(MathNode, 'tan');\nconst transformDirection = new ShaderNodeProxy(MathNode, 'transformDirection');\nconst EPSILON = float(1e-6);\nconst INFINITY = float(1e6);\n\nexport { EPSILON, INFINITY, ShaderNode, abs, acos, add, addTo, alphaTest, and, asin, assign, atan, attribute, bitAnd, bitOr, bitXor, bmat3, bmat4, bool, buffer, bvec2, bvec3, bvec4, cameraPosition, ceil, clamp, color, cond, cos, cross, dFdx, dFdy, degrees, diffuseColor, distance, div, dot, element, equal, exp, exp2, faceforward, float, floor, fract, greaterThan, greaterThanEqual, imat3, imat4, int, inversesqrt, invert, ivec2, ivec3, ivec4, join, label, length, lessThan, lessThanEqual, log, log2, mat3, mat4, max, metalness, min, mix, mod, mul, negate, nodeObject, normalGeometry, normalLocal, normalView, normalWorld, normalize, or, positionLocal, positionView, positionViewDirection, positionWorld, pow, pow2, pow3, pow4, radians, reflect, refract, remainder, roughness, round, sampler, saturate, shiftLeft, shiftRight, sign, sin, smoothstep, specularColor, sqrt, step, sub, tan, temp, texture, transformDirection, transformedNormalView, uint, umat3, umat4, uniform, uv, uvec2, uvec3, uvec4, vec2, vec3, vec4, viewMatrix, xor };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}