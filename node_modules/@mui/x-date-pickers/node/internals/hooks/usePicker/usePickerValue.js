"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.usePickerValue = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var React = _interopRequireWildcard(require("react"));
var _utils = require("@mui/utils");
var _useEventCallback = _interopRequireDefault(require("@mui/utils/useEventCallback"));
var _useOpenState = require("../useOpenState");
var _useUtils = require("../useUtils");
var _useValidation = require("../validation/useValidation");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * Manage the value lifecycle of all the pickers.
 */
const usePickerValue = ({
  props,
  valueManager,
  wrapperVariant,
  validator
}) => {
  const {
    onAccept: onAcceptProp,
    onChange,
    value: inValue,
    defaultValue,
    closeOnSelect = wrapperVariant === 'desktop',
    selectedSections: selectedSectionsProp,
    onSelectedSectionsChange
  } = props;
  const utils = (0, _useUtils.useUtils)();
  const adapter = (0, _useUtils.useLocalizationContext)();
  const [value, setValue] = (0, _utils.unstable_useControlled)({
    controlled: inValue,
    default: defaultValue ?? valueManager.emptyValue,
    name: 'usePickerValue',
    state: 'value'
  });
  const [selectedSections, setSelectedSections] = (0, _utils.unstable_useControlled)({
    controlled: selectedSectionsProp,
    default: null,
    name: 'usePickerValue',
    state: 'selectedSections'
  });
  const {
    isOpen,
    setIsOpen
  } = (0, _useOpenState.useOpenState)(props);
  const [dateState, setDateState] = React.useState(() => ({
    committed: value,
    draft: value,
    resetFallback: value
  }));
  (0, _useValidation.useValidation)((0, _extends2.default)({}, props, {
    value
  }), validator, valueManager.isSameError, valueManager.defaultErrorState);
  const setDate = (0, _useEventCallback.default)(params => {
    setDateState(prev => {
      switch (params.action) {
        case 'setAll':
        case 'acceptAndClose':
          {
            return {
              draft: params.value,
              committed: params.value,
              resetFallback: params.value
            };
          }
        case 'setCommitted':
          {
            return (0, _extends2.default)({}, prev, {
              draft: params.value,
              committed: params.value
            });
          }
        case 'setDraft':
          {
            return (0, _extends2.default)({}, prev, {
              draft: params.value
            });
          }
        default:
          {
            return prev;
          }
      }
    });
    if (!params.skipOnChangeCall && !valueManager.areValuesEqual(utils, dateState.committed, params.value)) {
      setValue(params.value);
      if (onChange) {
        const context = {
          validationError: params.contextFromField == null ? validator({
            adapter,
            value: params.value,
            props: (0, _extends2.default)({}, props, {
              value: params.value
            })
          }) : params.contextFromField.validationError
        };
        onChange(params.value, context);
      }
    }
    if (params.action === 'acceptAndClose') {
      setIsOpen(false);
      if (onAcceptProp && !valueManager.areValuesEqual(utils, dateState.resetFallback, params.value)) {
        onAcceptProp(params.value);
      }
    }
  });
  React.useEffect(() => {
    if (isOpen) {
      // Update all dates in state to equal the current prop value
      setDate({
        action: 'setAll',
        value,
        skipOnChangeCall: true
      });
    }
  }, [isOpen]); // eslint-disable-line react-hooks/exhaustive-deps

  // Set the draft and committed date to equal the new prop value.
  if (!valueManager.areValuesEqual(utils, dateState.committed, value)) {
    setDate({
      action: 'setCommitted',
      value,
      skipOnChangeCall: true
    });
  }
  const handleClear = (0, _useEventCallback.default)(() => {
    // Reset all date in state to the empty value and close picker.
    setDate({
      value: valueManager.emptyValue,
      action: 'acceptAndClose'
    });
  });
  const handleAccept = (0, _useEventCallback.default)(() => {
    // Set all date in state to equal the current draft value and close picker.
    setDate({
      value: dateState.draft,
      action: 'acceptAndClose'
    });
  });
  const handleDismiss = (0, _useEventCallback.default)(() => {
    // Set all dates in state to equal the last committed date.
    // e.g. Reset the state to the last committed value.
    setDate({
      value: dateState.committed,
      action: 'acceptAndClose'
    });
  });
  const handleCancel = (0, _useEventCallback.default)(() => {
    // Set all dates in state to equal the last accepted date and close picker.
    // e.g. Reset the state to the last accepted value
    setDate({
      value: dateState.resetFallback,
      action: 'acceptAndClose'
    });
  });
  const handleSetToday = (0, _useEventCallback.default)(() => {
    // Set all dates in state to equal today and close picker.
    setDate({
      value: valueManager.getTodayValue(utils),
      action: 'acceptAndClose'
    });
  });
  const handleOpen = (0, _useEventCallback.default)(() => setIsOpen(true));
  const handleClose = (0, _useEventCallback.default)(() => setIsOpen(false));
  const handleChange = (0, _useEventCallback.default)((newDate, selectionState = 'partial') => {
    switch (selectionState) {
      case 'shallow':
        {
          // Update the `draft` state but do not fire `onChange`
          return setDate({
            action: 'setDraft',
            value: newDate,
            skipOnChangeCall: true
          });
        }
      case 'partial':
        {
          // Update the `draft` state and fire `onChange`
          return setDate({
            action: 'setDraft',
            value: newDate
          });
        }
      case 'finish':
        {
          if (closeOnSelect) {
            // Set all dates in state to equal the new date and close picker.
            return setDate({
              value: newDate,
              action: 'acceptAndClose'
            });
          }

          // Updates the `committed` state and fire `onChange`
          return setDate({
            value: newDate,
            action: 'setCommitted'
          });
        }
      default:
        {
          throw new Error('MUI: Invalid selectionState passed to `onDateChange`');
        }
    }
  });
  const handleChangeAndCommit = (0, _useEventCallback.default)((newValue, contextFromField) => setDate({
    action: 'setCommitted',
    value: newValue,
    contextFromField
  }));
  const handleFieldSelectedSectionsChange = (0, _useEventCallback.default)(newSelectedSections => {
    setSelectedSections(newSelectedSections);
    onSelectedSectionsChange?.(newSelectedSections);
  });
  const actions = {
    onClear: handleClear,
    onAccept: handleAccept,
    onDismiss: handleDismiss,
    onCancel: handleCancel,
    onSetToday: handleSetToday,
    onOpen: handleOpen,
    onClose: handleClose
  };
  const fieldResponse = {
    value: dateState.draft,
    onChange: handleChangeAndCommit,
    selectedSections,
    onSelectedSectionsChange: handleFieldSelectedSectionsChange
  };
  const viewValue = React.useMemo(() => valueManager.cleanValue(utils, dateState.draft), [utils, valueManager, dateState.draft]);
  const viewResponse = {
    value: viewValue,
    onChange: handleChange,
    onClose: handleClose,
    open: isOpen,
    onSelectedSectionsChange: handleFieldSelectedSectionsChange
  };
  const isValid = testedValue => {
    const validationResponse = validator({
      adapter,
      value: testedValue,
      props: (0, _extends2.default)({}, props, {
        value: testedValue
      })
    });
    return Array.isArray(testedValue) ? validationResponse.every(v => v === null) : validationResponse === null;
  };
  const layoutResponse = (0, _extends2.default)({}, actions, {
    value: viewValue,
    onChange: handleChangeAndCommit,
    isValid
  });
  return {
    open: isOpen,
    fieldProps: fieldResponse,
    viewProps: viewResponse,
    layoutProps: layoutResponse,
    actions
  };
};
exports.usePickerValue = usePickerValue;