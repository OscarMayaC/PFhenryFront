{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RestWalker = void 0;\nvar drop_1 = __importDefault(require(\"lodash/drop\"));\nvar forEach_1 = __importDefault(require(\"lodash/forEach\"));\nvar gast_1 = require(\"@chevrotain/gast\");\n/**\n *  A Grammar Walker that computes the \"remaining\" grammar \"after\" a productions in the grammar.\n */\nvar RestWalker = /** @class */function () {\n  function RestWalker() {}\n  RestWalker.prototype.walk = function (prod, prevRest) {\n    var _this = this;\n    if (prevRest === void 0) {\n      prevRest = [];\n    }\n    (0, forEach_1.default)(prod.definition, function (subProd, index) {\n      var currRest = (0, drop_1.default)(prod.definition, index + 1);\n      /* istanbul ignore else */\n      if (subProd instanceof gast_1.NonTerminal) {\n        _this.walkProdRef(subProd, currRest, prevRest);\n      } else if (subProd instanceof gast_1.Terminal) {\n        _this.walkTerminal(subProd, currRest, prevRest);\n      } else if (subProd instanceof gast_1.Alternative) {\n        _this.walkFlat(subProd, currRest, prevRest);\n      } else if (subProd instanceof gast_1.Option) {\n        _this.walkOption(subProd, currRest, prevRest);\n      } else if (subProd instanceof gast_1.RepetitionMandatory) {\n        _this.walkAtLeastOne(subProd, currRest, prevRest);\n      } else if (subProd instanceof gast_1.RepetitionMandatoryWithSeparator) {\n        _this.walkAtLeastOneSep(subProd, currRest, prevRest);\n      } else if (subProd instanceof gast_1.RepetitionWithSeparator) {\n        _this.walkManySep(subProd, currRest, prevRest);\n      } else if (subProd instanceof gast_1.Repetition) {\n        _this.walkMany(subProd, currRest, prevRest);\n      } else if (subProd instanceof gast_1.Alternation) {\n        _this.walkOr(subProd, currRest, prevRest);\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    });\n  };\n  RestWalker.prototype.walkTerminal = function (terminal, currRest, prevRest) {};\n  RestWalker.prototype.walkProdRef = function (refProd, currRest, prevRest) {};\n  RestWalker.prototype.walkFlat = function (flatProd, currRest, prevRest) {\n    // ABCDEF => after the D the rest is EF\n    var fullOrRest = currRest.concat(prevRest);\n    this.walk(flatProd, fullOrRest);\n  };\n  RestWalker.prototype.walkOption = function (optionProd, currRest, prevRest) {\n    // ABC(DE)?F => after the (DE)? the rest is F\n    var fullOrRest = currRest.concat(prevRest);\n    this.walk(optionProd, fullOrRest);\n  };\n  RestWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {\n    // ABC(DE)+F => after the (DE)+ the rest is (DE)?F\n    var fullAtLeastOneRest = [new gast_1.Option({\n      definition: atLeastOneProd.definition\n    })].concat(currRest, prevRest);\n    this.walk(atLeastOneProd, fullAtLeastOneRest);\n  };\n  RestWalker.prototype.walkAtLeastOneSep = function (atLeastOneSepProd, currRest, prevRest) {\n    // ABC DE(,DE)* F => after the (,DE)+ the rest is (,DE)?F\n    var fullAtLeastOneSepRest = restForRepetitionWithSeparator(atLeastOneSepProd, currRest, prevRest);\n    this.walk(atLeastOneSepProd, fullAtLeastOneSepRest);\n  };\n  RestWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {\n    // ABC(DE)*F => after the (DE)* the rest is (DE)?F\n    var fullManyRest = [new gast_1.Option({\n      definition: manyProd.definition\n    })].concat(currRest, prevRest);\n    this.walk(manyProd, fullManyRest);\n  };\n  RestWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {\n    // ABC (DE(,DE)*)? F => after the (,DE)* the rest is (,DE)?F\n    var fullManySepRest = restForRepetitionWithSeparator(manySepProd, currRest, prevRest);\n    this.walk(manySepProd, fullManySepRest);\n  };\n  RestWalker.prototype.walkOr = function (orProd, currRest, prevRest) {\n    var _this = this;\n    // ABC(D|E|F)G => when finding the (D|E|F) the rest is G\n    var fullOrRest = currRest.concat(prevRest);\n    // walk all different alternatives\n    (0, forEach_1.default)(orProd.definition, function (alt) {\n      // wrapping each alternative in a single definition wrapper\n      // to avoid errors in computing the rest of that alternative in the invocation to computeInProdFollows\n      // (otherwise for OR([alt1,alt2]) alt2 will be considered in 'rest' of alt1\n      var prodWrapper = new gast_1.Alternative({\n        definition: [alt]\n      });\n      _this.walk(prodWrapper, fullOrRest);\n    });\n  };\n  return RestWalker;\n}();\nexports.RestWalker = RestWalker;\nfunction restForRepetitionWithSeparator(repSepProd, currRest, prevRest) {\n  var repSepRest = [new gast_1.Option({\n    definition: [new gast_1.Terminal({\n      terminalType: repSepProd.separator\n    })].concat(repSepProd.definition)\n  })];\n  var fullRepSepRest = repSepRest.concat(currRest, prevRest);\n  return fullRepSepRest;\n}","map":{"version":3,"names":["drop_1","__importDefault","require","forEach_1","gast_1","RestWalker","prototype","walk","prod","prevRest","_this","default","definition","subProd","index","currRest","NonTerminal","walkProdRef","Terminal","walkTerminal","Alternative","walkFlat","Option","walkOption","RepetitionMandatory","walkAtLeastOne","RepetitionMandatoryWithSeparator","walkAtLeastOneSep","RepetitionWithSeparator","walkManySep","Repetition","walkMany","Alternation","walkOr","Error","terminal","refProd","flatProd","fullOrRest","concat","optionProd","atLeastOneProd","fullAtLeastOneRest","atLeastOneSepProd","fullAtLeastOneSepRest","restForRepetitionWithSeparator","manyProd","fullManyRest","manySepProd","fullManySepRest","orProd","alt","prodWrapper","exports","repSepProd","repSepRest","terminalType","separator","fullRepSepRest"],"sources":["/Users/rociopichardo/Desktop/PFhenryFront/node_modules/chevrotain/src/parse/grammar/rest.ts"],"sourcesContent":["import drop from \"lodash/drop\"\nimport forEach from \"lodash/forEach\"\nimport {\n  Alternation,\n  Alternative,\n  NonTerminal,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Terminal\n} from \"@chevrotain/gast\"\nimport { IProduction } from \"@chevrotain/types\"\n\n/**\n *  A Grammar Walker that computes the \"remaining\" grammar \"after\" a productions in the grammar.\n */\nexport abstract class RestWalker {\n  walk(prod: { definition: IProduction[] }, prevRest: any[] = []): void {\n    forEach(prod.definition, (subProd: IProduction, index) => {\n      const currRest = drop(prod.definition, index + 1)\n      /* istanbul ignore else */\n      if (subProd instanceof NonTerminal) {\n        this.walkProdRef(subProd, currRest, prevRest)\n      } else if (subProd instanceof Terminal) {\n        this.walkTerminal(subProd, currRest, prevRest)\n      } else if (subProd instanceof Alternative) {\n        this.walkFlat(subProd, currRest, prevRest)\n      } else if (subProd instanceof Option) {\n        this.walkOption(subProd, currRest, prevRest)\n      } else if (subProd instanceof RepetitionMandatory) {\n        this.walkAtLeastOne(subProd, currRest, prevRest)\n      } else if (subProd instanceof RepetitionMandatoryWithSeparator) {\n        this.walkAtLeastOneSep(subProd, currRest, prevRest)\n      } else if (subProd instanceof RepetitionWithSeparator) {\n        this.walkManySep(subProd, currRest, prevRest)\n      } else if (subProd instanceof Repetition) {\n        this.walkMany(subProd, currRest, prevRest)\n      } else if (subProd instanceof Alternation) {\n        this.walkOr(subProd, currRest, prevRest)\n      } else {\n        throw Error(\"non exhaustive match\")\n      }\n    })\n  }\n\n  walkTerminal(\n    terminal: Terminal,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {}\n\n  walkProdRef(\n    refProd: NonTerminal,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {}\n\n  walkFlat(\n    flatProd: Alternative,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    // ABCDEF => after the D the rest is EF\n    const fullOrRest = currRest.concat(prevRest)\n    this.walk(flatProd, <any>fullOrRest)\n  }\n\n  walkOption(\n    optionProd: Option,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    // ABC(DE)?F => after the (DE)? the rest is F\n    const fullOrRest = currRest.concat(prevRest)\n    this.walk(optionProd, <any>fullOrRest)\n  }\n\n  walkAtLeastOne(\n    atLeastOneProd: RepetitionMandatory,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    // ABC(DE)+F => after the (DE)+ the rest is (DE)?F\n    const fullAtLeastOneRest: IProduction[] = [\n      new Option({ definition: atLeastOneProd.definition })\n    ].concat(<any>currRest, <any>prevRest)\n    this.walk(atLeastOneProd, fullAtLeastOneRest)\n  }\n\n  walkAtLeastOneSep(\n    atLeastOneSepProd: RepetitionMandatoryWithSeparator,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    // ABC DE(,DE)* F => after the (,DE)+ the rest is (,DE)?F\n    const fullAtLeastOneSepRest = restForRepetitionWithSeparator(\n      atLeastOneSepProd,\n      currRest,\n      prevRest\n    )\n    this.walk(atLeastOneSepProd, fullAtLeastOneSepRest)\n  }\n\n  walkMany(\n    manyProd: Repetition,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    // ABC(DE)*F => after the (DE)* the rest is (DE)?F\n    const fullManyRest: IProduction[] = [\n      new Option({ definition: manyProd.definition })\n    ].concat(<any>currRest, <any>prevRest)\n    this.walk(manyProd, fullManyRest)\n  }\n\n  walkManySep(\n    manySepProd: RepetitionWithSeparator,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    // ABC (DE(,DE)*)? F => after the (,DE)* the rest is (,DE)?F\n    const fullManySepRest = restForRepetitionWithSeparator(\n      manySepProd,\n      currRest,\n      prevRest\n    )\n    this.walk(manySepProd, fullManySepRest)\n  }\n\n  walkOr(\n    orProd: Alternation,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    // ABC(D|E|F)G => when finding the (D|E|F) the rest is G\n    const fullOrRest = currRest.concat(prevRest)\n    // walk all different alternatives\n    forEach(orProd.definition, (alt) => {\n      // wrapping each alternative in a single definition wrapper\n      // to avoid errors in computing the rest of that alternative in the invocation to computeInProdFollows\n      // (otherwise for OR([alt1,alt2]) alt2 will be considered in 'rest' of alt1\n      const prodWrapper = new Alternative({ definition: [alt] })\n      this.walk(prodWrapper, <any>fullOrRest)\n    })\n  }\n}\n\nfunction restForRepetitionWithSeparator(\n  repSepProd: RepetitionWithSeparator,\n  currRest: IProduction[],\n  prevRest: IProduction[]\n) {\n  const repSepRest = [\n    new Option({\n      definition: [\n        new Terminal({ terminalType: repSepProd.separator }) as IProduction\n      ].concat(repSepProd.definition)\n    }) as IProduction\n  ]\n  const fullRepSepRest: IProduction[] = repSepRest.concat(currRest, prevRest)\n  return fullRepSepRest\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}