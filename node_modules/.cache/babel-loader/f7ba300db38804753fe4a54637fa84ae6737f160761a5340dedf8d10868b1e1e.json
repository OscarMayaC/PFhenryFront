{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ErrorHandler = void 0;\nvar exceptions_public_1 = require(\"../../exceptions_public\");\nvar has_1 = __importDefault(require(\"lodash/has\"));\nvar clone_1 = __importDefault(require(\"lodash/clone\"));\nvar lookahead_1 = require(\"../../grammar/lookahead\");\nvar parser_1 = require(\"../parser\");\n/**\n * Trait responsible for runtime parsing errors.\n */\nvar ErrorHandler = /** @class */function () {\n  function ErrorHandler() {}\n  ErrorHandler.prototype.initErrorHandler = function (config) {\n    this._errors = [];\n    this.errorMessageProvider = (0, has_1.default)(config, \"errorMessageProvider\") ? config.errorMessageProvider // assumes end user provides the correct config value/type\n    : parser_1.DEFAULT_PARSER_CONFIG.errorMessageProvider;\n  };\n  ErrorHandler.prototype.SAVE_ERROR = function (error) {\n    if ((0, exceptions_public_1.isRecognitionException)(error)) {\n      error.context = {\n        ruleStack: this.getHumanReadableRuleStack(),\n        ruleOccurrenceStack: (0, clone_1.default)(this.RULE_OCCURRENCE_STACK)\n      };\n      this._errors.push(error);\n      return error;\n    } else {\n      throw Error(\"Trying to save an Error which is not a RecognitionException\");\n    }\n  };\n  Object.defineProperty(ErrorHandler.prototype, \"errors\", {\n    get: function () {\n      return (0, clone_1.default)(this._errors);\n    },\n    set: function (newErrors) {\n      this._errors = newErrors;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  // TODO: consider caching the error message computed information\n  ErrorHandler.prototype.raiseEarlyExitException = function (occurrence, prodType, userDefinedErrMsg) {\n    var ruleName = this.getCurrRuleFullName();\n    var ruleGrammar = this.getGAstProductions()[ruleName];\n    var lookAheadPathsPerAlternative = (0, lookahead_1.getLookaheadPathsForOptionalProd)(occurrence, ruleGrammar, prodType, this.maxLookahead);\n    var insideProdPaths = lookAheadPathsPerAlternative[0];\n    var actualTokens = [];\n    for (var i = 1; i <= this.maxLookahead; i++) {\n      actualTokens.push(this.LA(i));\n    }\n    var msg = this.errorMessageProvider.buildEarlyExitMessage({\n      expectedIterationPaths: insideProdPaths,\n      actual: actualTokens,\n      previous: this.LA(0),\n      customUserDescription: userDefinedErrMsg,\n      ruleName: ruleName\n    });\n    throw this.SAVE_ERROR(new exceptions_public_1.EarlyExitException(msg, this.LA(1), this.LA(0)));\n  };\n  // TODO: consider caching the error message computed information\n  ErrorHandler.prototype.raiseNoAltException = function (occurrence, errMsgTypes) {\n    var ruleName = this.getCurrRuleFullName();\n    var ruleGrammar = this.getGAstProductions()[ruleName];\n    // TODO: getLookaheadPathsForOr can be slow for large enough maxLookahead and certain grammars, consider caching ?\n    var lookAheadPathsPerAlternative = (0, lookahead_1.getLookaheadPathsForOr)(occurrence, ruleGrammar, this.maxLookahead);\n    var actualTokens = [];\n    for (var i = 1; i <= this.maxLookahead; i++) {\n      actualTokens.push(this.LA(i));\n    }\n    var previousToken = this.LA(0);\n    var errMsg = this.errorMessageProvider.buildNoViableAltMessage({\n      expectedPathsPerAlt: lookAheadPathsPerAlternative,\n      actual: actualTokens,\n      previous: previousToken,\n      customUserDescription: errMsgTypes,\n      ruleName: this.getCurrRuleFullName()\n    });\n    throw this.SAVE_ERROR(new exceptions_public_1.NoViableAltException(errMsg, this.LA(1), previousToken));\n  };\n  return ErrorHandler;\n}();\nexports.ErrorHandler = ErrorHandler;","map":{"version":3,"names":["exceptions_public_1","require","has_1","__importDefault","clone_1","lookahead_1","parser_1","ErrorHandler","prototype","initErrorHandler","config","_errors","errorMessageProvider","default","DEFAULT_PARSER_CONFIG","SAVE_ERROR","error","isRecognitionException","context","ruleStack","getHumanReadableRuleStack","ruleOccurrenceStack","RULE_OCCURRENCE_STACK","push","Error","Object","defineProperty","get","set","newErrors","raiseEarlyExitException","occurrence","prodType","userDefinedErrMsg","ruleName","getCurrRuleFullName","ruleGrammar","getGAstProductions","lookAheadPathsPerAlternative","getLookaheadPathsForOptionalProd","maxLookahead","insideProdPaths","actualTokens","i","LA","msg","buildEarlyExitMessage","expectedIterationPaths","actual","previous","customUserDescription","EarlyExitException","raiseNoAltException","errMsgTypes","getLookaheadPathsForOr","previousToken","errMsg","buildNoViableAltMessage","expectedPathsPerAlt","NoViableAltException","exports"],"sources":["/Users/rociopichardo/Desktop/PFhenryFront/restaurante-pf-front/node_modules/chevrotain/src/parse/parser/traits/error_handler.ts"],"sourcesContent":["import {\n  IParserConfig,\n  IParserErrorMessageProvider,\n  IRecognitionException\n} from \"@chevrotain/types\"\nimport {\n  EarlyExitException,\n  isRecognitionException,\n  NoViableAltException\n} from \"../../exceptions_public\"\nimport has from \"lodash/has\"\nimport clone from \"lodash/clone\"\nimport {\n  getLookaheadPathsForOptionalProd,\n  getLookaheadPathsForOr,\n  PROD_TYPE\n} from \"../../grammar/lookahead\"\nimport { MixedInParser } from \"./parser_traits\"\nimport { DEFAULT_PARSER_CONFIG } from \"../parser\"\n\n/**\n * Trait responsible for runtime parsing errors.\n */\nexport class ErrorHandler {\n  _errors: IRecognitionException[]\n  errorMessageProvider: IParserErrorMessageProvider\n\n  initErrorHandler(config: IParserConfig) {\n    this._errors = []\n    this.errorMessageProvider = has(config, \"errorMessageProvider\")\n      ? (config.errorMessageProvider as IParserErrorMessageProvider) // assumes end user provides the correct config value/type\n      : DEFAULT_PARSER_CONFIG.errorMessageProvider\n  }\n\n  SAVE_ERROR(\n    this: MixedInParser,\n    error: IRecognitionException\n  ): IRecognitionException {\n    if (isRecognitionException(error)) {\n      error.context = {\n        ruleStack: this.getHumanReadableRuleStack(),\n        ruleOccurrenceStack: clone(this.RULE_OCCURRENCE_STACK)\n      }\n      this._errors.push(error)\n      return error\n    } else {\n      throw Error(\"Trying to save an Error which is not a RecognitionException\")\n    }\n  }\n\n  get errors(): IRecognitionException[] {\n    return clone(this._errors)\n  }\n\n  set errors(newErrors: IRecognitionException[]) {\n    this._errors = newErrors\n  }\n\n  // TODO: consider caching the error message computed information\n  raiseEarlyExitException(\n    this: MixedInParser,\n    occurrence: number,\n    prodType: PROD_TYPE,\n    userDefinedErrMsg: string | undefined\n  ): never {\n    const ruleName = this.getCurrRuleFullName()\n    const ruleGrammar = this.getGAstProductions()[ruleName]\n    const lookAheadPathsPerAlternative = getLookaheadPathsForOptionalProd(\n      occurrence,\n      ruleGrammar,\n      prodType,\n      this.maxLookahead\n    )\n    const insideProdPaths = lookAheadPathsPerAlternative[0]\n    const actualTokens = []\n    for (let i = 1; i <= this.maxLookahead; i++) {\n      actualTokens.push(this.LA(i))\n    }\n    const msg = this.errorMessageProvider.buildEarlyExitMessage({\n      expectedIterationPaths: insideProdPaths,\n      actual: actualTokens,\n      previous: this.LA(0),\n      customUserDescription: userDefinedErrMsg,\n      ruleName: ruleName\n    })\n\n    throw this.SAVE_ERROR(new EarlyExitException(msg, this.LA(1), this.LA(0)))\n  }\n\n  // TODO: consider caching the error message computed information\n  raiseNoAltException(\n    this: MixedInParser,\n    occurrence: number,\n    errMsgTypes: string | undefined\n  ): never {\n    const ruleName = this.getCurrRuleFullName()\n    const ruleGrammar = this.getGAstProductions()[ruleName]\n    // TODO: getLookaheadPathsForOr can be slow for large enough maxLookahead and certain grammars, consider caching ?\n    const lookAheadPathsPerAlternative = getLookaheadPathsForOr(\n      occurrence,\n      ruleGrammar,\n      this.maxLookahead\n    )\n\n    const actualTokens = []\n    for (let i = 1; i <= this.maxLookahead; i++) {\n      actualTokens.push(this.LA(i))\n    }\n    const previousToken = this.LA(0)\n\n    const errMsg = this.errorMessageProvider.buildNoViableAltMessage({\n      expectedPathsPerAlt: lookAheadPathsPerAlternative,\n      actual: actualTokens,\n      previous: previousToken,\n      customUserDescription: errMsgTypes,\n      ruleName: this.getCurrRuleFullName()\n    })\n\n    throw this.SAVE_ERROR(\n      new NoViableAltException(errMsg, this.LA(1), previousToken)\n    )\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}