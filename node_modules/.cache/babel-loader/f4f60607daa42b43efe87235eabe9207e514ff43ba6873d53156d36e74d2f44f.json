{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LexerAdapter = void 0;\nvar parser_1 = require(\"../parser\");\n/**\n * Trait responsible abstracting over the interaction with Lexer output (Token vector).\n *\n * This could be generalized to support other kinds of lexers, e.g.\n * - Just in Time Lexing / Lexer-Less parsing.\n * - Streaming Lexer.\n */\nvar LexerAdapter = /** @class */function () {\n  function LexerAdapter() {}\n  LexerAdapter.prototype.initLexerAdapter = function () {\n    this.tokVector = [];\n    this.tokVectorLength = 0;\n    this.currIdx = -1;\n  };\n  Object.defineProperty(LexerAdapter.prototype, \"input\", {\n    get: function () {\n      return this.tokVector;\n    },\n    set: function (newInput) {\n      // @ts-ignore - `this parameter` not supported in setters/getters\n      //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters\n      if (this.selfAnalysisDone !== true) {\n        throw Error(\"Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.\");\n      }\n      // @ts-ignore - `this parameter` not supported in setters/getters\n      //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters\n      this.reset();\n      this.tokVector = newInput;\n      this.tokVectorLength = newInput.length;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  // skips a token and returns the next token\n  LexerAdapter.prototype.SKIP_TOKEN = function () {\n    if (this.currIdx <= this.tokVector.length - 2) {\n      this.consumeToken();\n      return this.LA(1);\n    } else {\n      return parser_1.END_OF_FILE;\n    }\n  };\n  // Lexer (accessing Token vector) related methods which can be overridden to implement lazy lexers\n  // or lexers dependent on parser context.\n  LexerAdapter.prototype.LA = function (howMuch) {\n    var soughtIdx = this.currIdx + howMuch;\n    if (soughtIdx < 0 || this.tokVectorLength <= soughtIdx) {\n      return parser_1.END_OF_FILE;\n    } else {\n      return this.tokVector[soughtIdx];\n    }\n  };\n  LexerAdapter.prototype.consumeToken = function () {\n    this.currIdx++;\n  };\n  LexerAdapter.prototype.exportLexerState = function () {\n    return this.currIdx;\n  };\n  LexerAdapter.prototype.importLexerState = function (newState) {\n    this.currIdx = newState;\n  };\n  LexerAdapter.prototype.resetLexerState = function () {\n    this.currIdx = -1;\n  };\n  LexerAdapter.prototype.moveToTerminatedState = function () {\n    this.currIdx = this.tokVector.length - 1;\n  };\n  LexerAdapter.prototype.getLexerPosition = function () {\n    return this.exportLexerState();\n  };\n  return LexerAdapter;\n}();\nexports.LexerAdapter = LexerAdapter;","map":{"version":3,"names":["parser_1","require","LexerAdapter","prototype","initLexerAdapter","tokVector","tokVectorLength","currIdx","Object","defineProperty","get","set","newInput","selfAnalysisDone","Error","reset","length","SKIP_TOKEN","consumeToken","LA","END_OF_FILE","howMuch","soughtIdx","exportLexerState","importLexerState","newState","resetLexerState","moveToTerminatedState","getLexerPosition","exports"],"sources":["/Users/rociopichardo/Desktop/PFhenryFront/node_modules/chevrotain/src/parse/parser/traits/lexer_adapter.ts"],"sourcesContent":["import { END_OF_FILE } from \"../parser\"\nimport { IToken } from \"@chevrotain/types\"\nimport { MixedInParser } from \"./parser_traits\"\n\n/**\n * Trait responsible abstracting over the interaction with Lexer output (Token vector).\n *\n * This could be generalized to support other kinds of lexers, e.g.\n * - Just in Time Lexing / Lexer-Less parsing.\n * - Streaming Lexer.\n */\nexport class LexerAdapter {\n  tokVector: IToken[]\n  tokVectorLength: number\n  currIdx: number\n\n  initLexerAdapter() {\n    this.tokVector = []\n    this.tokVectorLength = 0\n    this.currIdx = -1\n  }\n\n  set input(newInput: IToken[]) {\n    // @ts-ignore - `this parameter` not supported in setters/getters\n    //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters\n    if (this.selfAnalysisDone !== true) {\n      throw Error(\n        `Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.`\n      )\n    }\n    // @ts-ignore - `this parameter` not supported in setters/getters\n    //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters\n    this.reset()\n    this.tokVector = newInput\n    this.tokVectorLength = newInput.length\n  }\n\n  get input(): IToken[] {\n    return this.tokVector\n  }\n\n  // skips a token and returns the next token\n  SKIP_TOKEN(this: MixedInParser): IToken {\n    if (this.currIdx <= this.tokVector.length - 2) {\n      this.consumeToken()\n      return this.LA(1)\n    } else {\n      return END_OF_FILE\n    }\n  }\n\n  // Lexer (accessing Token vector) related methods which can be overridden to implement lazy lexers\n  // or lexers dependent on parser context.\n  LA(this: MixedInParser, howMuch: number): IToken {\n    const soughtIdx = this.currIdx + howMuch\n    if (soughtIdx < 0 || this.tokVectorLength <= soughtIdx) {\n      return END_OF_FILE\n    } else {\n      return this.tokVector[soughtIdx]\n    }\n  }\n\n  consumeToken(this: MixedInParser) {\n    this.currIdx++\n  }\n\n  exportLexerState(this: MixedInParser): number {\n    return this.currIdx\n  }\n\n  importLexerState(this: MixedInParser, newState: number) {\n    this.currIdx = newState\n  }\n\n  resetLexerState(this: MixedInParser): void {\n    this.currIdx = -1\n  }\n\n  moveToTerminatedState(this: MixedInParser): void {\n    this.currIdx = this.tokVector.length - 1\n  }\n\n  getLexerPosition(this: MixedInParser): number {\n    return this.exportLexerState()\n  }\n}\n"],"mappings":";;;;;;AAAA,IAAAA,QAAA,GAAAC,OAAA;AAIA;;;;;;;AAOA,IAAAC,YAAA;EAAA,SAAAA,aAAA,GA0EA;EArEEA,YAAA,CAAAC,SAAA,CAAAC,gBAAgB,GAAhB;IACE,IAAI,CAACC,SAAS,GAAG,EAAE;IACnB,IAAI,CAACC,eAAe,GAAG,CAAC;IACxB,IAAI,CAACC,OAAO,GAAG,CAAC,CAAC;EACnB,CAAC;EAEDC,MAAA,CAAAC,cAAA,CAAIP,YAAA,CAAAC,SAAA,SAAK;SAeT,SAAAO,CAAA;MACE,OAAO,IAAI,CAACL,SAAS;IACvB,CAAC;SAjBD,SAAAM,CAAUC,QAAkB;MAC1B;MACA;MACA,IAAI,IAAI,CAACC,gBAAgB,KAAK,IAAI,EAAE;QAClC,MAAMC,KAAK,CACT,kFAAkF,CACnF;;MAEH;MACA;MACA,IAAI,CAACC,KAAK,EAAE;MACZ,IAAI,CAACV,SAAS,GAAGO,QAAQ;MACzB,IAAI,CAACN,eAAe,GAAGM,QAAQ,CAACI,MAAM;IACxC,CAAC;;;;EAMD;EACAd,YAAA,CAAAC,SAAA,CAAAc,UAAU,GAAV;IACE,IAAI,IAAI,CAACV,OAAO,IAAI,IAAI,CAACF,SAAS,CAACW,MAAM,GAAG,CAAC,EAAE;MAC7C,IAAI,CAACE,YAAY,EAAE;MACnB,OAAO,IAAI,CAACC,EAAE,CAAC,CAAC,CAAC;KAClB,MAAM;MACL,OAAOnB,QAAA,CAAAoB,WAAW;;EAEtB,CAAC;EAED;EACA;EACAlB,YAAA,CAAAC,SAAA,CAAAgB,EAAE,GAAF,UAAwBE,OAAe;IACrC,IAAMC,SAAS,GAAG,IAAI,CAACf,OAAO,GAAGc,OAAO;IACxC,IAAIC,SAAS,GAAG,CAAC,IAAI,IAAI,CAAChB,eAAe,IAAIgB,SAAS,EAAE;MACtD,OAAOtB,QAAA,CAAAoB,WAAW;KACnB,MAAM;MACL,OAAO,IAAI,CAACf,SAAS,CAACiB,SAAS,CAAC;;EAEpC,CAAC;EAEDpB,YAAA,CAAAC,SAAA,CAAAe,YAAY,GAAZ;IACE,IAAI,CAACX,OAAO,EAAE;EAChB,CAAC;EAEDL,YAAA,CAAAC,SAAA,CAAAoB,gBAAgB,GAAhB;IACE,OAAO,IAAI,CAAChB,OAAO;EACrB,CAAC;EAEDL,YAAA,CAAAC,SAAA,CAAAqB,gBAAgB,GAAhB,UAAsCC,QAAgB;IACpD,IAAI,CAAClB,OAAO,GAAGkB,QAAQ;EACzB,CAAC;EAEDvB,YAAA,CAAAC,SAAA,CAAAuB,eAAe,GAAf;IACE,IAAI,CAACnB,OAAO,GAAG,CAAC,CAAC;EACnB,CAAC;EAEDL,YAAA,CAAAC,SAAA,CAAAwB,qBAAqB,GAArB;IACE,IAAI,CAACpB,OAAO,GAAG,IAAI,CAACF,SAAS,CAACW,MAAM,GAAG,CAAC;EAC1C,CAAC;EAEDd,YAAA,CAAAC,SAAA,CAAAyB,gBAAgB,GAAhB;IACE,OAAO,IAAI,CAACL,gBAAgB,EAAE;EAChC,CAAC;EACH,OAAArB,YAAC;AAAD,CAAC,EA1ED;AAAa2B,OAAA,CAAA3B,YAAA,GAAAA,YAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}