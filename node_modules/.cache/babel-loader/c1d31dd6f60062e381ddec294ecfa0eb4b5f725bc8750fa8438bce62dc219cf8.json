{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildModel = void 0;\nvar gast_1 = require(\"@chevrotain/gast\");\nvar map_1 = __importDefault(require(\"lodash/map\"));\nvar flatten_1 = __importDefault(require(\"lodash/flatten\"));\nvar values_1 = __importDefault(require(\"lodash/values\"));\nvar some_1 = __importDefault(require(\"lodash/some\"));\nvar groupBy_1 = __importDefault(require(\"lodash/groupBy\"));\nvar assign_1 = __importDefault(require(\"lodash/assign\"));\nfunction buildModel(productions) {\n  var generator = new CstNodeDefinitionGenerator();\n  var allRules = (0, values_1.default)(productions);\n  return (0, map_1.default)(allRules, function (rule) {\n    return generator.visitRule(rule);\n  });\n}\nexports.buildModel = buildModel;\nvar CstNodeDefinitionGenerator = /** @class */function (_super) {\n  __extends(CstNodeDefinitionGenerator, _super);\n  function CstNodeDefinitionGenerator() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  CstNodeDefinitionGenerator.prototype.visitRule = function (node) {\n    var rawElements = this.visitEach(node.definition);\n    var grouped = (0, groupBy_1.default)(rawElements, function (el) {\n      return el.propertyName;\n    });\n    var properties = (0, map_1.default)(grouped, function (group, propertyName) {\n      var allNullable = !(0, some_1.default)(group, function (el) {\n        return !el.canBeNull;\n      });\n      // In an alternation with a label a property name can have\n      // multiple types.\n      var propertyType = group[0].type;\n      if (group.length > 1) {\n        propertyType = (0, map_1.default)(group, function (g) {\n          return g.type;\n        });\n      }\n      return {\n        name: propertyName,\n        type: propertyType,\n        optional: allNullable\n      };\n    });\n    return {\n      name: node.name,\n      properties: properties\n    };\n  };\n  CstNodeDefinitionGenerator.prototype.visitAlternative = function (node) {\n    return this.visitEachAndOverrideWith(node.definition, {\n      canBeNull: true\n    });\n  };\n  CstNodeDefinitionGenerator.prototype.visitOption = function (node) {\n    return this.visitEachAndOverrideWith(node.definition, {\n      canBeNull: true\n    });\n  };\n  CstNodeDefinitionGenerator.prototype.visitRepetition = function (node) {\n    return this.visitEachAndOverrideWith(node.definition, {\n      canBeNull: true\n    });\n  };\n  CstNodeDefinitionGenerator.prototype.visitRepetitionMandatory = function (node) {\n    return this.visitEach(node.definition);\n  };\n  CstNodeDefinitionGenerator.prototype.visitRepetitionMandatoryWithSeparator = function (node) {\n    return this.visitEach(node.definition).concat({\n      propertyName: node.separator.name,\n      canBeNull: true,\n      type: getType(node.separator)\n    });\n  };\n  CstNodeDefinitionGenerator.prototype.visitRepetitionWithSeparator = function (node) {\n    return this.visitEachAndOverrideWith(node.definition, {\n      canBeNull: true\n    }).concat({\n      propertyName: node.separator.name,\n      canBeNull: true,\n      type: getType(node.separator)\n    });\n  };\n  CstNodeDefinitionGenerator.prototype.visitAlternation = function (node) {\n    return this.visitEachAndOverrideWith(node.definition, {\n      canBeNull: true\n    });\n  };\n  CstNodeDefinitionGenerator.prototype.visitTerminal = function (node) {\n    return [{\n      propertyName: node.label || node.terminalType.name,\n      canBeNull: false,\n      type: getType(node)\n    }];\n  };\n  CstNodeDefinitionGenerator.prototype.visitNonTerminal = function (node) {\n    return [{\n      propertyName: node.label || node.nonTerminalName,\n      canBeNull: false,\n      type: getType(node)\n    }];\n  };\n  CstNodeDefinitionGenerator.prototype.visitEachAndOverrideWith = function (definition, override) {\n    return (0, map_1.default)(this.visitEach(definition), function (definition) {\n      return (0, assign_1.default)({}, definition, override);\n    });\n  };\n  CstNodeDefinitionGenerator.prototype.visitEach = function (definition) {\n    var _this = this;\n    return (0, flatten_1.default)((0, map_1.default)(definition, function (definition) {\n      return _this.visit(definition);\n    }));\n  };\n  return CstNodeDefinitionGenerator;\n}(gast_1.GAstVisitor);\nfunction getType(production) {\n  if (production instanceof gast_1.NonTerminal) {\n    return {\n      kind: \"rule\",\n      name: production.referencedRule.name\n    };\n  }\n  return {\n    kind: \"token\"\n  };\n}","map":{"version":3,"names":["gast_1","require","map_1","__importDefault","flatten_1","values_1","some_1","groupBy_1","assign_1","buildModel","productions","generator","CstNodeDefinitionGenerator","allRules","default","rule","visitRule","exports","_super","__extends","prototype","node","rawElements","visitEach","definition","grouped","el","propertyName","properties","group","allNullable","canBeNull","propertyType","type","length","g","name","optional","visitAlternative","visitEachAndOverrideWith","visitOption","visitRepetition","visitRepetitionMandatory","visitRepetitionMandatoryWithSeparator","concat","separator","getType","visitRepetitionWithSeparator","visitAlternation","visitTerminal","label","terminalType","visitNonTerminal","nonTerminalName","override","_this","visit","GAstVisitor","production","NonTerminal","kind","referencedRule"],"sources":["/Users/rociopichardo/Desktop/PFhenryFront/node_modules/@chevrotain/cst-dts-gen/src/model.ts"],"sourcesContent":["import type {\n  Alternation,\n  Alternative,\n  IProduction,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Rule,\n  Terminal,\n  TokenType\n} from \"@chevrotain/types\"\nimport { NonTerminal, GAstVisitor } from \"@chevrotain/gast\"\nimport map from \"lodash/map\"\nimport flatten from \"lodash/flatten\"\nimport values from \"lodash/values\"\nimport some from \"lodash/some\"\nimport groupBy from \"lodash/groupBy\"\nimport assign from \"lodash/assign\"\n\nexport function buildModel(\n  productions: Record<string, Rule>\n): CstNodeTypeDefinition[] {\n  const generator = new CstNodeDefinitionGenerator()\n  const allRules = values(productions)\n  return map(allRules, (rule) => generator.visitRule(rule))\n}\n\nexport type CstNodeTypeDefinition = {\n  name: string\n  properties: PropertyTypeDefinition[]\n}\n\nexport type PropertyTypeDefinition = {\n  name: string\n  type: PropertyArrayType\n  optional: boolean\n}\n\nexport type PropertyArrayType =\n  | TokenArrayType\n  | RuleArrayType\n  | (TokenArrayType | RuleArrayType)[]\n\nexport type TokenArrayType = { kind: \"token\" }\nexport type RuleArrayType = {\n  kind: \"rule\"\n  name: string\n}\n\nclass CstNodeDefinitionGenerator extends GAstVisitor {\n  visitRule(node: Rule): CstNodeTypeDefinition {\n    const rawElements = this.visitEach(node.definition)\n\n    const grouped = groupBy(rawElements, (el) => el.propertyName)\n    const properties = map(grouped, (group, propertyName) => {\n      const allNullable = !some(group, (el) => !el.canBeNull)\n\n      // In an alternation with a label a property name can have\n      // multiple types.\n      let propertyType: PropertyArrayType = group[0].type\n      if (group.length > 1) {\n        propertyType = map(group, (g) => g.type)\n      }\n\n      return {\n        name: propertyName,\n        type: propertyType,\n        optional: allNullable\n      } as PropertyTypeDefinition\n    })\n\n    return {\n      name: node.name,\n      properties: properties\n    }\n  }\n\n  visitAlternative(node: Alternative) {\n    return this.visitEachAndOverrideWith(node.definition, { canBeNull: true })\n  }\n\n  visitOption(node: Option) {\n    return this.visitEachAndOverrideWith(node.definition, { canBeNull: true })\n  }\n\n  visitRepetition(node: Repetition) {\n    return this.visitEachAndOverrideWith(node.definition, { canBeNull: true })\n  }\n\n  visitRepetitionMandatory(node: RepetitionMandatory) {\n    return this.visitEach(node.definition)\n  }\n\n  visitRepetitionMandatoryWithSeparator(\n    node: RepetitionMandatoryWithSeparator\n  ) {\n    return this.visitEach(node.definition).concat({\n      propertyName: node.separator.name,\n      canBeNull: true,\n      type: getType(node.separator)\n    })\n  }\n\n  visitRepetitionWithSeparator(node: RepetitionWithSeparator) {\n    return this.visitEachAndOverrideWith(node.definition, {\n      canBeNull: true\n    }).concat({\n      propertyName: node.separator.name,\n      canBeNull: true,\n      type: getType(node.separator)\n    })\n  }\n\n  visitAlternation(node: Alternation) {\n    return this.visitEachAndOverrideWith(node.definition, { canBeNull: true })\n  }\n\n  visitTerminal(node: Terminal): PropertyTupleElement[] {\n    return [\n      {\n        propertyName: node.label || node.terminalType.name,\n        canBeNull: false,\n        type: getType(node)\n      }\n    ]\n  }\n\n  visitNonTerminal(node: NonTerminal): PropertyTupleElement[] {\n    return [\n      {\n        propertyName: node.label || node.nonTerminalName,\n        canBeNull: false,\n        type: getType(node)\n      }\n    ]\n  }\n\n  private visitEachAndOverrideWith(\n    definition: IProduction[],\n    override: Partial<PropertyTupleElement>\n  ) {\n    return map(\n      this.visitEach(definition),\n      (definition) => assign({}, definition, override) as PropertyTupleElement\n    )\n  }\n\n  private visitEach(definition: IProduction[]) {\n    return flatten<PropertyTupleElement>(\n      map(\n        definition,\n        (definition) => this.visit(definition) as PropertyTupleElement[]\n      )\n    )\n  }\n}\n\ntype PropertyTupleElement = {\n  propertyName: string\n  canBeNull: boolean\n  type: TokenArrayType | RuleArrayType\n}\n\nfunction getType(\n  production: Terminal | NonTerminal | TokenType\n): TokenArrayType | RuleArrayType {\n  if (production instanceof NonTerminal) {\n    return {\n      kind: \"rule\",\n      name: production.referencedRule.name\n    }\n  }\n\n  return { kind: \"token\" }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}