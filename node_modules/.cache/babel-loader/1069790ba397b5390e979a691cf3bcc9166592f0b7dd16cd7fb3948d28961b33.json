{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.charCodeToOptimizedIndex = exports.minOptimizationVal = exports.buildLineBreakIssueMessage = exports.LineTerminatorOptimizedTester = exports.isShortPattern = exports.isCustomPattern = exports.cloneEmptyGroups = exports.performWarningRuntimeChecks = exports.performRuntimeChecks = exports.addStickyFlag = exports.addStartOfInput = exports.findUnreachablePatterns = exports.findModesThatDoNotExist = exports.findInvalidGroupType = exports.findDuplicatePatterns = exports.findUnsupportedFlags = exports.findStartOfInputAnchor = exports.findEmptyMatchRegExps = exports.findEndOfInputAnchor = exports.findInvalidPatterns = exports.findMissingPatterns = exports.validatePatterns = exports.analyzeTokenTypes = exports.enableSticky = exports.disableSticky = exports.SUPPORT_STICKY = exports.MODES = exports.DEFAULT_MODE = void 0;\nvar regexp_to_ast_1 = require(\"regexp-to-ast\");\nvar lexer_public_1 = require(\"./lexer_public\");\nvar first_1 = __importDefault(require(\"lodash/first\"));\nvar isEmpty_1 = __importDefault(require(\"lodash/isEmpty\"));\nvar compact_1 = __importDefault(require(\"lodash/compact\"));\nvar isArray_1 = __importDefault(require(\"lodash/isArray\"));\nvar values_1 = __importDefault(require(\"lodash/values\"));\nvar flatten_1 = __importDefault(require(\"lodash/flatten\"));\nvar reject_1 = __importDefault(require(\"lodash/reject\"));\nvar difference_1 = __importDefault(require(\"lodash/difference\"));\nvar indexOf_1 = __importDefault(require(\"lodash/indexOf\"));\nvar map_1 = __importDefault(require(\"lodash/map\"));\nvar forEach_1 = __importDefault(require(\"lodash/forEach\"));\nvar isString_1 = __importDefault(require(\"lodash/isString\"));\nvar isFunction_1 = __importDefault(require(\"lodash/isFunction\"));\nvar isUndefined_1 = __importDefault(require(\"lodash/isUndefined\"));\nvar find_1 = __importDefault(require(\"lodash/find\"));\nvar has_1 = __importDefault(require(\"lodash/has\"));\nvar keys_1 = __importDefault(require(\"lodash/keys\"));\nvar isRegExp_1 = __importDefault(require(\"lodash/isRegExp\"));\nvar filter_1 = __importDefault(require(\"lodash/filter\"));\nvar defaults_1 = __importDefault(require(\"lodash/defaults\"));\nvar reduce_1 = __importDefault(require(\"lodash/reduce\"));\nvar includes_1 = __importDefault(require(\"lodash/includes\"));\nvar utils_1 = require(\"@chevrotain/utils\");\nvar reg_exp_1 = require(\"./reg_exp\");\nvar reg_exp_parser_1 = require(\"./reg_exp_parser\");\nvar PATTERN = \"PATTERN\";\nexports.DEFAULT_MODE = \"defaultMode\";\nexports.MODES = \"modes\";\nexports.SUPPORT_STICKY = typeof new RegExp(\"(?:)\").sticky === \"boolean\";\nfunction disableSticky() {\n  exports.SUPPORT_STICKY = false;\n}\nexports.disableSticky = disableSticky;\nfunction enableSticky() {\n  exports.SUPPORT_STICKY = true;\n}\nexports.enableSticky = enableSticky;\nfunction analyzeTokenTypes(tokenTypes, options) {\n  options = (0, defaults_1.default)(options, {\n    useSticky: exports.SUPPORT_STICKY,\n    debug: false,\n    safeMode: false,\n    positionTracking: \"full\",\n    lineTerminatorCharacters: [\"\\r\", \"\\n\"],\n    tracer: function (msg, action) {\n      return action();\n    }\n  });\n  var tracer = options.tracer;\n  tracer(\"initCharCodeToOptimizedIndexMap\", function () {\n    initCharCodeToOptimizedIndexMap();\n  });\n  var onlyRelevantTypes;\n  tracer(\"Reject Lexer.NA\", function () {\n    onlyRelevantTypes = (0, reject_1.default)(tokenTypes, function (currType) {\n      return currType[PATTERN] === lexer_public_1.Lexer.NA;\n    });\n  });\n  var hasCustom = false;\n  var allTransformedPatterns;\n  tracer(\"Transform Patterns\", function () {\n    hasCustom = false;\n    allTransformedPatterns = (0, map_1.default)(onlyRelevantTypes, function (currType) {\n      var currPattern = currType[PATTERN];\n      /* istanbul ignore else */\n      if ((0, isRegExp_1.default)(currPattern)) {\n        var regExpSource = currPattern.source;\n        if (regExpSource.length === 1 &&\n        // only these regExp meta characters which can appear in a length one regExp\n        regExpSource !== \"^\" && regExpSource !== \"$\" && regExpSource !== \".\" && !currPattern.ignoreCase) {\n          return regExpSource;\n        } else if (regExpSource.length === 2 && regExpSource[0] === \"\\\\\" &&\n        // not a meta character\n        !(0, includes_1.default)([\"d\", \"D\", \"s\", \"S\", \"t\", \"r\", \"n\", \"t\", \"0\", \"c\", \"b\", \"B\", \"f\", \"v\", \"w\", \"W\"], regExpSource[1])) {\n          // escaped meta Characters: /\\+/ /\\[/\n          // or redundant escaping: /\\a/\n          // without the escaping \"\\\"\n          return regExpSource[1];\n        } else {\n          return options.useSticky ? addStickyFlag(currPattern) : addStartOfInput(currPattern);\n        }\n      } else if ((0, isFunction_1.default)(currPattern)) {\n        hasCustom = true;\n        // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object\n        return {\n          exec: currPattern\n        };\n      } else if (typeof currPattern === \"object\") {\n        hasCustom = true;\n        // ICustomPattern\n        return currPattern;\n      } else if (typeof currPattern === \"string\") {\n        if (currPattern.length === 1) {\n          return currPattern;\n        } else {\n          var escapedRegExpString = currPattern.replace(/[\\\\^$.*+?()[\\]{}|]/g, \"\\\\$&\");\n          var wrappedRegExp = new RegExp(escapedRegExpString);\n          return options.useSticky ? addStickyFlag(wrappedRegExp) : addStartOfInput(wrappedRegExp);\n        }\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    });\n  });\n  var patternIdxToType;\n  var patternIdxToGroup;\n  var patternIdxToLongerAltIdxArr;\n  var patternIdxToPushMode;\n  var patternIdxToPopMode;\n  tracer(\"misc mapping\", function () {\n    patternIdxToType = (0, map_1.default)(onlyRelevantTypes, function (currType) {\n      return currType.tokenTypeIdx;\n    });\n    patternIdxToGroup = (0, map_1.default)(onlyRelevantTypes, function (clazz) {\n      var groupName = clazz.GROUP;\n      /* istanbul ignore next */\n      if (groupName === lexer_public_1.Lexer.SKIPPED) {\n        return undefined;\n      } else if ((0, isString_1.default)(groupName)) {\n        return groupName;\n      } else if ((0, isUndefined_1.default)(groupName)) {\n        return false;\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    });\n    patternIdxToLongerAltIdxArr = (0, map_1.default)(onlyRelevantTypes, function (clazz) {\n      var longerAltType = clazz.LONGER_ALT;\n      if (longerAltType) {\n        var longerAltIdxArr = (0, isArray_1.default)(longerAltType) ? (0, map_1.default)(longerAltType, function (type) {\n          return (0, indexOf_1.default)(onlyRelevantTypes, type);\n        }) : [(0, indexOf_1.default)(onlyRelevantTypes, longerAltType)];\n        return longerAltIdxArr;\n      }\n    });\n    patternIdxToPushMode = (0, map_1.default)(onlyRelevantTypes, function (clazz) {\n      return clazz.PUSH_MODE;\n    });\n    patternIdxToPopMode = (0, map_1.default)(onlyRelevantTypes, function (clazz) {\n      return (0, has_1.default)(clazz, \"POP_MODE\");\n    });\n  });\n  var patternIdxToCanLineTerminator;\n  tracer(\"Line Terminator Handling\", function () {\n    var lineTerminatorCharCodes = getCharCodes(options.lineTerminatorCharacters);\n    patternIdxToCanLineTerminator = (0, map_1.default)(onlyRelevantTypes, function (tokType) {\n      return false;\n    });\n    if (options.positionTracking !== \"onlyOffset\") {\n      patternIdxToCanLineTerminator = (0, map_1.default)(onlyRelevantTypes, function (tokType) {\n        if ((0, has_1.default)(tokType, \"LINE_BREAKS\")) {\n          return !!tokType.LINE_BREAKS;\n        } else {\n          return checkLineBreaksIssues(tokType, lineTerminatorCharCodes) === false && (0, reg_exp_1.canMatchCharCode)(lineTerminatorCharCodes, tokType.PATTERN);\n        }\n      });\n    }\n  });\n  var patternIdxToIsCustom;\n  var patternIdxToShort;\n  var emptyGroups;\n  var patternIdxToConfig;\n  tracer(\"Misc Mapping #2\", function () {\n    patternIdxToIsCustom = (0, map_1.default)(onlyRelevantTypes, isCustomPattern);\n    patternIdxToShort = (0, map_1.default)(allTransformedPatterns, isShortPattern);\n    emptyGroups = (0, reduce_1.default)(onlyRelevantTypes, function (acc, clazz) {\n      var groupName = clazz.GROUP;\n      if ((0, isString_1.default)(groupName) && !(groupName === lexer_public_1.Lexer.SKIPPED)) {\n        acc[groupName] = [];\n      }\n      return acc;\n    }, {});\n    patternIdxToConfig = (0, map_1.default)(allTransformedPatterns, function (x, idx) {\n      return {\n        pattern: allTransformedPatterns[idx],\n        longerAlt: patternIdxToLongerAltIdxArr[idx],\n        canLineTerminator: patternIdxToCanLineTerminator[idx],\n        isCustom: patternIdxToIsCustom[idx],\n        short: patternIdxToShort[idx],\n        group: patternIdxToGroup[idx],\n        push: patternIdxToPushMode[idx],\n        pop: patternIdxToPopMode[idx],\n        tokenTypeIdx: patternIdxToType[idx],\n        tokenType: onlyRelevantTypes[idx]\n      };\n    });\n  });\n  var canBeOptimized = true;\n  var charCodeToPatternIdxToConfig = [];\n  if (!options.safeMode) {\n    tracer(\"First Char Optimization\", function () {\n      charCodeToPatternIdxToConfig = (0, reduce_1.default)(onlyRelevantTypes, function (result, currTokType, idx) {\n        if (typeof currTokType.PATTERN === \"string\") {\n          var charCode = currTokType.PATTERN.charCodeAt(0);\n          var optimizedIdx = charCodeToOptimizedIndex(charCode);\n          addToMapOfArrays(result, optimizedIdx, patternIdxToConfig[idx]);\n        } else if ((0, isArray_1.default)(currTokType.START_CHARS_HINT)) {\n          var lastOptimizedIdx_1;\n          (0, forEach_1.default)(currTokType.START_CHARS_HINT, function (charOrInt) {\n            var charCode = typeof charOrInt === \"string\" ? charOrInt.charCodeAt(0) : charOrInt;\n            var currOptimizedIdx = charCodeToOptimizedIndex(charCode);\n            // Avoid adding the config multiple times\n            /* istanbul ignore else */\n            // - Difficult to check this scenario effects as it is only a performance\n            //   optimization that does not change correctness\n            if (lastOptimizedIdx_1 !== currOptimizedIdx) {\n              lastOptimizedIdx_1 = currOptimizedIdx;\n              addToMapOfArrays(result, currOptimizedIdx, patternIdxToConfig[idx]);\n            }\n          });\n        } else if ((0, isRegExp_1.default)(currTokType.PATTERN)) {\n          if (currTokType.PATTERN.unicode) {\n            canBeOptimized = false;\n            if (options.ensureOptimizations) {\n              (0, utils_1.PRINT_ERROR)(\"\".concat(reg_exp_1.failedOptimizationPrefixMsg) + \"\\tUnable to analyze < \".concat(currTokType.PATTERN.toString(), \" > pattern.\\n\") + \"\\tThe regexp unicode flag is not currently supported by the regexp-to-ast library.\\n\" + \"\\tThis will disable the lexer's first char optimizations.\\n\" + \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE\");\n            }\n          } else {\n            var optimizedCodes = (0, reg_exp_1.getOptimizedStartCodesIndices)(currTokType.PATTERN, options.ensureOptimizations);\n            /* istanbul ignore if */\n            // start code will only be empty given an empty regExp or failure of regexp-to-ast library\n            // the first should be a different validation and the second cannot be tested.\n            if ((0, isEmpty_1.default)(optimizedCodes)) {\n              // we cannot understand what codes may start possible matches\n              // The optimization correctness requires knowing start codes for ALL patterns.\n              // Not actually sure this is an error, no debug message\n              canBeOptimized = false;\n            }\n            (0, forEach_1.default)(optimizedCodes, function (code) {\n              addToMapOfArrays(result, code, patternIdxToConfig[idx]);\n            });\n          }\n        } else {\n          if (options.ensureOptimizations) {\n            (0, utils_1.PRINT_ERROR)(\"\".concat(reg_exp_1.failedOptimizationPrefixMsg) + \"\\tTokenType: <\".concat(currTokType.name, \"> is using a custom token pattern without providing <start_chars_hint> parameter.\\n\") + \"\\tThis will disable the lexer's first char optimizations.\\n\" + \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE\");\n          }\n          canBeOptimized = false;\n        }\n        return result;\n      }, []);\n    });\n  }\n  return {\n    emptyGroups: emptyGroups,\n    patternIdxToConfig: patternIdxToConfig,\n    charCodeToPatternIdxToConfig: charCodeToPatternIdxToConfig,\n    hasCustom: hasCustom,\n    canBeOptimized: canBeOptimized\n  };\n}\nexports.analyzeTokenTypes = analyzeTokenTypes;\nfunction validatePatterns(tokenTypes, validModesNames) {\n  var errors = [];\n  var missingResult = findMissingPatterns(tokenTypes);\n  errors = errors.concat(missingResult.errors);\n  var invalidResult = findInvalidPatterns(missingResult.valid);\n  var validTokenTypes = invalidResult.valid;\n  errors = errors.concat(invalidResult.errors);\n  errors = errors.concat(validateRegExpPattern(validTokenTypes));\n  errors = errors.concat(findInvalidGroupType(validTokenTypes));\n  errors = errors.concat(findModesThatDoNotExist(validTokenTypes, validModesNames));\n  errors = errors.concat(findUnreachablePatterns(validTokenTypes));\n  return errors;\n}\nexports.validatePatterns = validatePatterns;\nfunction validateRegExpPattern(tokenTypes) {\n  var errors = [];\n  var withRegExpPatterns = (0, filter_1.default)(tokenTypes, function (currTokType) {\n    return (0, isRegExp_1.default)(currTokType[PATTERN]);\n  });\n  errors = errors.concat(findEndOfInputAnchor(withRegExpPatterns));\n  errors = errors.concat(findStartOfInputAnchor(withRegExpPatterns));\n  errors = errors.concat(findUnsupportedFlags(withRegExpPatterns));\n  errors = errors.concat(findDuplicatePatterns(withRegExpPatterns));\n  errors = errors.concat(findEmptyMatchRegExps(withRegExpPatterns));\n  return errors;\n}\nfunction findMissingPatterns(tokenTypes) {\n  var tokenTypesWithMissingPattern = (0, filter_1.default)(tokenTypes, function (currType) {\n    return !(0, has_1.default)(currType, PATTERN);\n  });\n  var errors = (0, map_1.default)(tokenTypesWithMissingPattern, function (currType) {\n    return {\n      message: \"Token Type: ->\" + currType.name + \"<- missing static 'PATTERN' property\",\n      type: lexer_public_1.LexerDefinitionErrorType.MISSING_PATTERN,\n      tokenTypes: [currType]\n    };\n  });\n  var valid = (0, difference_1.default)(tokenTypes, tokenTypesWithMissingPattern);\n  return {\n    errors: errors,\n    valid: valid\n  };\n}\nexports.findMissingPatterns = findMissingPatterns;\nfunction findInvalidPatterns(tokenTypes) {\n  var tokenTypesWithInvalidPattern = (0, filter_1.default)(tokenTypes, function (currType) {\n    var pattern = currType[PATTERN];\n    return !(0, isRegExp_1.default)(pattern) && !(0, isFunction_1.default)(pattern) && !(0, has_1.default)(pattern, \"exec\") && !(0, isString_1.default)(pattern);\n  });\n  var errors = (0, map_1.default)(tokenTypesWithInvalidPattern, function (currType) {\n    return {\n      message: \"Token Type: ->\" + currType.name + \"<- static 'PATTERN' can only be a RegExp, a\" + \" Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.\",\n      type: lexer_public_1.LexerDefinitionErrorType.INVALID_PATTERN,\n      tokenTypes: [currType]\n    };\n  });\n  var valid = (0, difference_1.default)(tokenTypes, tokenTypesWithInvalidPattern);\n  return {\n    errors: errors,\n    valid: valid\n  };\n}\nexports.findInvalidPatterns = findInvalidPatterns;\nvar end_of_input = /[^\\\\][$]/;\nfunction findEndOfInputAnchor(tokenTypes) {\n  var EndAnchorFinder = /** @class */function (_super) {\n    __extends(EndAnchorFinder, _super);\n    function EndAnchorFinder() {\n      var _this = _super !== null && _super.apply(this, arguments) || this;\n      _this.found = false;\n      return _this;\n    }\n    EndAnchorFinder.prototype.visitEndAnchor = function (node) {\n      this.found = true;\n    };\n    return EndAnchorFinder;\n  }(regexp_to_ast_1.BaseRegExpVisitor);\n  var invalidRegex = (0, filter_1.default)(tokenTypes, function (currType) {\n    var pattern = currType.PATTERN;\n    try {\n      var regexpAst = (0, reg_exp_parser_1.getRegExpAst)(pattern);\n      var endAnchorVisitor = new EndAnchorFinder();\n      endAnchorVisitor.visit(regexpAst);\n      return endAnchorVisitor.found;\n    } catch (e) {\n      // old behavior in case of runtime exceptions with regexp-to-ast.\n      /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/\n      return end_of_input.test(pattern.source);\n    }\n  });\n  var errors = (0, map_1.default)(invalidRegex, function (currType) {\n    return {\n      message: \"Unexpected RegExp Anchor Error:\\n\" + \"\\tToken Type: ->\" + currType.name + \"<- static 'PATTERN' cannot contain end of input anchor '$'\\n\" + \"\\tSee chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS\" + \"\\tfor details.\",\n      type: lexer_public_1.LexerDefinitionErrorType.EOI_ANCHOR_FOUND,\n      tokenTypes: [currType]\n    };\n  });\n  return errors;\n}\nexports.findEndOfInputAnchor = findEndOfInputAnchor;\nfunction findEmptyMatchRegExps(tokenTypes) {\n  var matchesEmptyString = (0, filter_1.default)(tokenTypes, function (currType) {\n    var pattern = currType.PATTERN;\n    return pattern.test(\"\");\n  });\n  var errors = (0, map_1.default)(matchesEmptyString, function (currType) {\n    return {\n      message: \"Token Type: ->\" + currType.name + \"<- static 'PATTERN' must not match an empty string\",\n      type: lexer_public_1.LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,\n      tokenTypes: [currType]\n    };\n  });\n  return errors;\n}\nexports.findEmptyMatchRegExps = findEmptyMatchRegExps;\nvar start_of_input = /[^\\\\[][\\^]|^\\^/;\nfunction findStartOfInputAnchor(tokenTypes) {\n  var StartAnchorFinder = /** @class */function (_super) {\n    __extends(StartAnchorFinder, _super);\n    function StartAnchorFinder() {\n      var _this = _super !== null && _super.apply(this, arguments) || this;\n      _this.found = false;\n      return _this;\n    }\n    StartAnchorFinder.prototype.visitStartAnchor = function (node) {\n      this.found = true;\n    };\n    return StartAnchorFinder;\n  }(regexp_to_ast_1.BaseRegExpVisitor);\n  var invalidRegex = (0, filter_1.default)(tokenTypes, function (currType) {\n    var pattern = currType.PATTERN;\n    try {\n      var regexpAst = (0, reg_exp_parser_1.getRegExpAst)(pattern);\n      var startAnchorVisitor = new StartAnchorFinder();\n      startAnchorVisitor.visit(regexpAst);\n      return startAnchorVisitor.found;\n    } catch (e) {\n      // old behavior in case of runtime exceptions with regexp-to-ast.\n      /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/\n      return start_of_input.test(pattern.source);\n    }\n  });\n  var errors = (0, map_1.default)(invalidRegex, function (currType) {\n    return {\n      message: \"Unexpected RegExp Anchor Error:\\n\" + \"\\tToken Type: ->\" + currType.name + \"<- static 'PATTERN' cannot contain start of input anchor '^'\\n\" + \"\\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS\" + \"\\tfor details.\",\n      type: lexer_public_1.LexerDefinitionErrorType.SOI_ANCHOR_FOUND,\n      tokenTypes: [currType]\n    };\n  });\n  return errors;\n}\nexports.findStartOfInputAnchor = findStartOfInputAnchor;\nfunction findUnsupportedFlags(tokenTypes) {\n  var invalidFlags = (0, filter_1.default)(tokenTypes, function (currType) {\n    var pattern = currType[PATTERN];\n    return pattern instanceof RegExp && (pattern.multiline || pattern.global);\n  });\n  var errors = (0, map_1.default)(invalidFlags, function (currType) {\n    return {\n      message: \"Token Type: ->\" + currType.name + \"<- static 'PATTERN' may NOT contain global('g') or multiline('m')\",\n      type: lexer_public_1.LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,\n      tokenTypes: [currType]\n    };\n  });\n  return errors;\n}\nexports.findUnsupportedFlags = findUnsupportedFlags;\n// This can only test for identical duplicate RegExps, not semantically equivalent ones.\nfunction findDuplicatePatterns(tokenTypes) {\n  var found = [];\n  var identicalPatterns = (0, map_1.default)(tokenTypes, function (outerType) {\n    return (0, reduce_1.default)(tokenTypes, function (result, innerType) {\n      if (outerType.PATTERN.source === innerType.PATTERN.source && !(0, includes_1.default)(found, innerType) && innerType.PATTERN !== lexer_public_1.Lexer.NA) {\n        // this avoids duplicates in the result, each Token Type may only appear in one \"set\"\n        // in essence we are creating Equivalence classes on equality relation.\n        found.push(innerType);\n        result.push(innerType);\n        return result;\n      }\n      return result;\n    }, []);\n  });\n  identicalPatterns = (0, compact_1.default)(identicalPatterns);\n  var duplicatePatterns = (0, filter_1.default)(identicalPatterns, function (currIdenticalSet) {\n    return currIdenticalSet.length > 1;\n  });\n  var errors = (0, map_1.default)(duplicatePatterns, function (setOfIdentical) {\n    var tokenTypeNames = (0, map_1.default)(setOfIdentical, function (currType) {\n      return currType.name;\n    });\n    var dupPatternSrc = (0, first_1.default)(setOfIdentical).PATTERN;\n    return {\n      message: \"The same RegExp pattern ->\".concat(dupPatternSrc, \"<-\") + \"has been used in all of the following Token Types: \".concat(tokenTypeNames.join(\", \"), \" <-\"),\n      type: lexer_public_1.LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,\n      tokenTypes: setOfIdentical\n    };\n  });\n  return errors;\n}\nexports.findDuplicatePatterns = findDuplicatePatterns;\nfunction findInvalidGroupType(tokenTypes) {\n  var invalidTypes = (0, filter_1.default)(tokenTypes, function (clazz) {\n    if (!(0, has_1.default)(clazz, \"GROUP\")) {\n      return false;\n    }\n    var group = clazz.GROUP;\n    return group !== lexer_public_1.Lexer.SKIPPED && group !== lexer_public_1.Lexer.NA && !(0, isString_1.default)(group);\n  });\n  var errors = (0, map_1.default)(invalidTypes, function (currType) {\n    return {\n      message: \"Token Type: ->\" + currType.name + \"<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String\",\n      type: lexer_public_1.LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,\n      tokenTypes: [currType]\n    };\n  });\n  return errors;\n}\nexports.findInvalidGroupType = findInvalidGroupType;\nfunction findModesThatDoNotExist(tokenTypes, validModes) {\n  var invalidModes = (0, filter_1.default)(tokenTypes, function (clazz) {\n    return clazz.PUSH_MODE !== undefined && !(0, includes_1.default)(validModes, clazz.PUSH_MODE);\n  });\n  var errors = (0, map_1.default)(invalidModes, function (tokType) {\n    var msg = \"Token Type: ->\".concat(tokType.name, \"<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->\").concat(tokType.PUSH_MODE, \"<-\") + \"which does not exist\";\n    return {\n      message: msg,\n      type: lexer_public_1.LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,\n      tokenTypes: [tokType]\n    };\n  });\n  return errors;\n}\nexports.findModesThatDoNotExist = findModesThatDoNotExist;\nfunction findUnreachablePatterns(tokenTypes) {\n  var errors = [];\n  var canBeTested = (0, reduce_1.default)(tokenTypes, function (result, tokType, idx) {\n    var pattern = tokType.PATTERN;\n    if (pattern === lexer_public_1.Lexer.NA) {\n      return result;\n    }\n    // a more comprehensive validation for all forms of regExps would require\n    // deeper regExp analysis capabilities\n    if ((0, isString_1.default)(pattern)) {\n      result.push({\n        str: pattern,\n        idx: idx,\n        tokenType: tokType\n      });\n    } else if ((0, isRegExp_1.default)(pattern) && noMetaChar(pattern)) {\n      result.push({\n        str: pattern.source,\n        idx: idx,\n        tokenType: tokType\n      });\n    }\n    return result;\n  }, []);\n  (0, forEach_1.default)(tokenTypes, function (tokType, testIdx) {\n    (0, forEach_1.default)(canBeTested, function (_a) {\n      var str = _a.str,\n        idx = _a.idx,\n        tokenType = _a.tokenType;\n      if (testIdx < idx && testTokenType(str, tokType.PATTERN)) {\n        var msg = \"Token: ->\".concat(tokenType.name, \"<- can never be matched.\\n\") + \"Because it appears AFTER the Token Type ->\".concat(tokType.name, \"<-\") + \"in the lexer's definition.\\n\" + \"See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE\";\n        errors.push({\n          message: msg,\n          type: lexer_public_1.LexerDefinitionErrorType.UNREACHABLE_PATTERN,\n          tokenTypes: [tokType, tokenType]\n        });\n      }\n    });\n  });\n  return errors;\n}\nexports.findUnreachablePatterns = findUnreachablePatterns;\nfunction testTokenType(str, pattern) {\n  /* istanbul ignore else */\n  if ((0, isRegExp_1.default)(pattern)) {\n    var regExpArray = pattern.exec(str);\n    return regExpArray !== null && regExpArray.index === 0;\n  } else if ((0, isFunction_1.default)(pattern)) {\n    // maintain the API of custom patterns\n    return pattern(str, 0, [], {});\n  } else if ((0, has_1.default)(pattern, \"exec\")) {\n    // maintain the API of custom patterns\n    return pattern.exec(str, 0, [], {});\n  } else if (typeof pattern === \"string\") {\n    return pattern === str;\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\nfunction noMetaChar(regExp) {\n  //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp\n  var metaChars = [\".\", \"\\\\\", \"[\", \"]\", \"|\", \"^\", \"$\", \"(\", \")\", \"?\", \"*\", \"+\", \"{\"];\n  return (0, find_1.default)(metaChars, function (char) {\n    return regExp.source.indexOf(char) !== -1;\n  }) === undefined;\n}\nfunction addStartOfInput(pattern) {\n  var flags = pattern.ignoreCase ? \"i\" : \"\";\n  // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.\n  // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)\n  return new RegExp(\"^(?:\".concat(pattern.source, \")\"), flags);\n}\nexports.addStartOfInput = addStartOfInput;\nfunction addStickyFlag(pattern) {\n  var flags = pattern.ignoreCase ? \"iy\" : \"y\";\n  // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.\n  // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)\n  return new RegExp(\"\".concat(pattern.source), flags);\n}\nexports.addStickyFlag = addStickyFlag;\nfunction performRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {\n  var errors = [];\n  // some run time checks to help the end users.\n  if (!(0, has_1.default)(lexerDefinition, exports.DEFAULT_MODE)) {\n    errors.push({\n      message: \"A MultiMode Lexer cannot be initialized without a <\" + exports.DEFAULT_MODE + \"> property in its definition\\n\",\n      type: lexer_public_1.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\n    });\n  }\n  if (!(0, has_1.default)(lexerDefinition, exports.MODES)) {\n    errors.push({\n      message: \"A MultiMode Lexer cannot be initialized without a <\" + exports.MODES + \"> property in its definition\\n\",\n      type: lexer_public_1.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\n    });\n  }\n  if ((0, has_1.default)(lexerDefinition, exports.MODES) && (0, has_1.default)(lexerDefinition, exports.DEFAULT_MODE) && !(0, has_1.default)(lexerDefinition.modes, lexerDefinition.defaultMode)) {\n    errors.push({\n      message: \"A MultiMode Lexer cannot be initialized with a \".concat(exports.DEFAULT_MODE, \": <\").concat(lexerDefinition.defaultMode, \">\") + \"which does not exist\\n\",\n      type: lexer_public_1.LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\n    });\n  }\n  if ((0, has_1.default)(lexerDefinition, exports.MODES)) {\n    (0, forEach_1.default)(lexerDefinition.modes, function (currModeValue, currModeName) {\n      (0, forEach_1.default)(currModeValue, function (currTokType, currIdx) {\n        if ((0, isUndefined_1.default)(currTokType)) {\n          errors.push({\n            message: \"A Lexer cannot be initialized using an undefined Token Type. Mode:\" + \"<\".concat(currModeName, \"> at index: <\").concat(currIdx, \">\\n\"),\n            type: lexer_public_1.LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\n          });\n        } else if ((0, has_1.default)(currTokType, \"LONGER_ALT\")) {\n          var longerAlt = (0, isArray_1.default)(currTokType.LONGER_ALT) ? currTokType.LONGER_ALT : [currTokType.LONGER_ALT];\n          (0, forEach_1.default)(longerAlt, function (currLongerAlt) {\n            if (!(0, isUndefined_1.default)(currLongerAlt) && !(0, includes_1.default)(currModeValue, currLongerAlt)) {\n              errors.push({\n                message: \"A MultiMode Lexer cannot be initialized with a longer_alt <\".concat(currLongerAlt.name, \"> on token <\").concat(currTokType.name, \"> outside of mode <\").concat(currModeName, \">\\n\"),\n                type: lexer_public_1.LexerDefinitionErrorType.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE\n              });\n            }\n          });\n        }\n      });\n    });\n  }\n  return errors;\n}\nexports.performRuntimeChecks = performRuntimeChecks;\nfunction performWarningRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {\n  var warnings = [];\n  var hasAnyLineBreak = false;\n  var allTokenTypes = (0, compact_1.default)((0, flatten_1.default)((0, values_1.default)(lexerDefinition.modes)));\n  var concreteTokenTypes = (0, reject_1.default)(allTokenTypes, function (currType) {\n    return currType[PATTERN] === lexer_public_1.Lexer.NA;\n  });\n  var terminatorCharCodes = getCharCodes(lineTerminatorCharacters);\n  if (trackLines) {\n    (0, forEach_1.default)(concreteTokenTypes, function (tokType) {\n      var currIssue = checkLineBreaksIssues(tokType, terminatorCharCodes);\n      if (currIssue !== false) {\n        var message = buildLineBreakIssueMessage(tokType, currIssue);\n        var warningDescriptor = {\n          message: message,\n          type: currIssue.issue,\n          tokenType: tokType\n        };\n        warnings.push(warningDescriptor);\n      } else {\n        // we don't want to attempt to scan if the user explicitly specified the line_breaks option.\n        if ((0, has_1.default)(tokType, \"LINE_BREAKS\")) {\n          if (tokType.LINE_BREAKS === true) {\n            hasAnyLineBreak = true;\n          }\n        } else {\n          if ((0, reg_exp_1.canMatchCharCode)(terminatorCharCodes, tokType.PATTERN)) {\n            hasAnyLineBreak = true;\n          }\n        }\n      }\n    });\n  }\n  if (trackLines && !hasAnyLineBreak) {\n    warnings.push({\n      message: \"Warning: No LINE_BREAKS Found.\\n\" + \"\\tThis Lexer has been defined to track line and column information,\\n\" + \"\\tBut none of the Token Types can be identified as matching a line terminator.\\n\" + \"\\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \\n\" + \"\\tfor details.\",\n      type: lexer_public_1.LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS\n    });\n  }\n  return warnings;\n}\nexports.performWarningRuntimeChecks = performWarningRuntimeChecks;\nfunction cloneEmptyGroups(emptyGroups) {\n  var clonedResult = {};\n  var groupKeys = (0, keys_1.default)(emptyGroups);\n  (0, forEach_1.default)(groupKeys, function (currKey) {\n    var currGroupValue = emptyGroups[currKey];\n    /* istanbul ignore else */\n    if ((0, isArray_1.default)(currGroupValue)) {\n      clonedResult[currKey] = [];\n    } else {\n      throw Error(\"non exhaustive match\");\n    }\n  });\n  return clonedResult;\n}\nexports.cloneEmptyGroups = cloneEmptyGroups;\n// TODO: refactor to avoid duplication\nfunction isCustomPattern(tokenType) {\n  var pattern = tokenType.PATTERN;\n  /* istanbul ignore else */\n  if ((0, isRegExp_1.default)(pattern)) {\n    return false;\n  } else if ((0, isFunction_1.default)(pattern)) {\n    // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object\n    return true;\n  } else if ((0, has_1.default)(pattern, \"exec\")) {\n    // ICustomPattern\n    return true;\n  } else if ((0, isString_1.default)(pattern)) {\n    return false;\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\nexports.isCustomPattern = isCustomPattern;\nfunction isShortPattern(pattern) {\n  if ((0, isString_1.default)(pattern) && pattern.length === 1) {\n    return pattern.charCodeAt(0);\n  } else {\n    return false;\n  }\n}\nexports.isShortPattern = isShortPattern;\n/**\n * Faster than using a RegExp for default newline detection during lexing.\n */\nexports.LineTerminatorOptimizedTester = {\n  // implements /\\n|\\r\\n?/g.test\n  test: function (text) {\n    var len = text.length;\n    for (var i = this.lastIndex; i < len; i++) {\n      var c = text.charCodeAt(i);\n      if (c === 10) {\n        this.lastIndex = i + 1;\n        return true;\n      } else if (c === 13) {\n        if (text.charCodeAt(i + 1) === 10) {\n          this.lastIndex = i + 2;\n        } else {\n          this.lastIndex = i + 1;\n        }\n        return true;\n      }\n    }\n    return false;\n  },\n  lastIndex: 0\n};\nfunction checkLineBreaksIssues(tokType, lineTerminatorCharCodes) {\n  if ((0, has_1.default)(tokType, \"LINE_BREAKS\")) {\n    // if the user explicitly declared the line_breaks option we will respect their choice\n    // and assume it is correct.\n    return false;\n  } else {\n    /* istanbul ignore else */\n    if ((0, isRegExp_1.default)(tokType.PATTERN)) {\n      try {\n        // TODO: why is the casting suddenly needed?\n        (0, reg_exp_1.canMatchCharCode)(lineTerminatorCharCodes, tokType.PATTERN);\n      } catch (e) {\n        /* istanbul ignore next - to test this we would have to mock <canMatchCharCode> to throw an error */\n        return {\n          issue: lexer_public_1.LexerDefinitionErrorType.IDENTIFY_TERMINATOR,\n          errMsg: e.message\n        };\n      }\n      return false;\n    } else if ((0, isString_1.default)(tokType.PATTERN)) {\n      // string literal patterns can always be analyzed to detect line terminator usage\n      return false;\n    } else if (isCustomPattern(tokType)) {\n      // custom token types\n      return {\n        issue: lexer_public_1.LexerDefinitionErrorType.CUSTOM_LINE_BREAK\n      };\n    } else {\n      throw Error(\"non exhaustive match\");\n    }\n  }\n}\nfunction buildLineBreakIssueMessage(tokType, details) {\n  /* istanbul ignore else */\n  if (details.issue === lexer_public_1.LexerDefinitionErrorType.IDENTIFY_TERMINATOR) {\n    return \"Warning: unable to identify line terminator usage in pattern.\\n\" + \"\\tThe problem is in the <\".concat(tokType.name, \"> Token Type\\n\") + \"\\t Root cause: \".concat(details.errMsg, \".\\n\") + \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR\";\n  } else if (details.issue === lexer_public_1.LexerDefinitionErrorType.CUSTOM_LINE_BREAK) {\n    return \"Warning: A Custom Token Pattern should specify the <line_breaks> option.\\n\" + \"\\tThe problem is in the <\".concat(tokType.name, \"> Token Type\\n\") + \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK\";\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\nexports.buildLineBreakIssueMessage = buildLineBreakIssueMessage;\nfunction getCharCodes(charsOrCodes) {\n  var charCodes = (0, map_1.default)(charsOrCodes, function (numOrString) {\n    if ((0, isString_1.default)(numOrString)) {\n      return numOrString.charCodeAt(0);\n    } else {\n      return numOrString;\n    }\n  });\n  return charCodes;\n}\nfunction addToMapOfArrays(map, key, value) {\n  if (map[key] === undefined) {\n    map[key] = [value];\n  } else {\n    map[key].push(value);\n  }\n}\nexports.minOptimizationVal = 256;\n/**\n * We are mapping charCode above ASCI (256) into buckets each in the size of 256.\n * This is because ASCI are the most common start chars so each one of those will get its own\n * possible token configs vector.\n *\n * Tokens starting with charCodes \"above\" ASCI are uncommon, so we can \"afford\"\n * to place these into buckets of possible token configs, What we gain from\n * this is avoiding the case of creating an optimization 'charCodeToPatternIdxToConfig'\n * which would contain 10,000+ arrays of small size (e.g unicode Identifiers scenario).\n * Our 'charCodeToPatternIdxToConfig' max size will now be:\n * 256 + (2^16 / 2^8) - 1 === 511\n *\n * note the hack for fast division integer part extraction\n * See: https://stackoverflow.com/a/4228528\n */\nvar charCodeToOptimizedIdxMap = [];\nfunction charCodeToOptimizedIndex(charCode) {\n  return charCode < exports.minOptimizationVal ? charCode : charCodeToOptimizedIdxMap[charCode];\n}\nexports.charCodeToOptimizedIndex = charCodeToOptimizedIndex;\n/**\n * This is a compromise between cold start / hot running performance\n * Creating this array takes ~3ms on a modern machine,\n * But if we perform the computation at runtime as needed the CSS Lexer benchmark\n * performance degrades by ~10%\n *\n * TODO: Perhaps it should be lazy initialized only if a charCode > 255 is used.\n */\nfunction initCharCodeToOptimizedIndexMap() {\n  if ((0, isEmpty_1.default)(charCodeToOptimizedIdxMap)) {\n    charCodeToOptimizedIdxMap = new Array(65536);\n    for (var i = 0; i < 65536; i++) {\n      charCodeToOptimizedIdxMap[i] = i > 255 ? 255 + ~~(i / 255) : i;\n    }\n  }\n}","map":{"version":3,"names":["regexp_to_ast_1","require","lexer_public_1","first_1","__importDefault","isEmpty_1","compact_1","isArray_1","values_1","flatten_1","reject_1","difference_1","indexOf_1","map_1","forEach_1","isString_1","isFunction_1","isUndefined_1","find_1","has_1","keys_1","isRegExp_1","filter_1","defaults_1","reduce_1","includes_1","utils_1","reg_exp_1","reg_exp_parser_1","PATTERN","exports","DEFAULT_MODE","MODES","SUPPORT_STICKY","RegExp","sticky","disableSticky","enableSticky","analyzeTokenTypes","tokenTypes","options","default","useSticky","debug","safeMode","positionTracking","lineTerminatorCharacters","tracer","msg","action","initCharCodeToOptimizedIndexMap","onlyRelevantTypes","currType","Lexer","NA","hasCustom","allTransformedPatterns","currPattern","regExpSource","source","length","ignoreCase","addStickyFlag","addStartOfInput","exec","escapedRegExpString","replace","wrappedRegExp","Error","patternIdxToType","patternIdxToGroup","patternIdxToLongerAltIdxArr","patternIdxToPushMode","patternIdxToPopMode","tokenTypeIdx","clazz","groupName","GROUP","SKIPPED","undefined","longerAltType","LONGER_ALT","longerAltIdxArr","type","PUSH_MODE","patternIdxToCanLineTerminator","lineTerminatorCharCodes","getCharCodes","tokType","LINE_BREAKS","checkLineBreaksIssues","canMatchCharCode","patternIdxToIsCustom","patternIdxToShort","emptyGroups","patternIdxToConfig","isCustomPattern","isShortPattern","acc","x","idx","pattern","longerAlt","canLineTerminator","isCustom","short","group","push","pop","tokenType","canBeOptimized","charCodeToPatternIdxToConfig","result","currTokType","charCode","charCodeAt","optimizedIdx","charCodeToOptimizedIndex","addToMapOfArrays","START_CHARS_HINT","lastOptimizedIdx_1","charOrInt","currOptimizedIdx","unicode","ensureOptimizations","PRINT_ERROR","concat","failedOptimizationPrefixMsg","toString","optimizedCodes","getOptimizedStartCodesIndices","code","name","validatePatterns","validModesNames","errors","missingResult","findMissingPatterns","invalidResult","findInvalidPatterns","valid","validTokenTypes","validateRegExpPattern","findInvalidGroupType","findModesThatDoNotExist","findUnreachablePatterns","withRegExpPatterns","findEndOfInputAnchor","findStartOfInputAnchor","findUnsupportedFlags","findDuplicatePatterns","findEmptyMatchRegExps","tokenTypesWithMissingPattern","message","LexerDefinitionErrorType","MISSING_PATTERN","tokenTypesWithInvalidPattern","INVALID_PATTERN","end_of_input","EndAnchorFinder","_super","__extends","_this","apply","arguments","found","prototype","visitEndAnchor","node","BaseRegExpVisitor","invalidRegex","regexpAst","getRegExpAst","endAnchorVisitor","visit","e","test","EOI_ANCHOR_FOUND","matchesEmptyString","EMPTY_MATCH_PATTERN","start_of_input","StartAnchorFinder","visitStartAnchor","startAnchorVisitor","SOI_ANCHOR_FOUND","invalidFlags","multiline","global","UNSUPPORTED_FLAGS_FOUND","identicalPatterns","outerType","innerType","duplicatePatterns","currIdenticalSet","setOfIdentical","tokenTypeNames","dupPatternSrc","join","DUPLICATE_PATTERNS_FOUND","invalidTypes","INVALID_GROUP_TYPE_FOUND","validModes","invalidModes","PUSH_MODE_DOES_NOT_EXIST","canBeTested","str","noMetaChar","testIdx","_a","testTokenType","UNREACHABLE_PATTERN","regExpArray","index","regExp","metaChars","char","indexOf","flags","performRuntimeChecks","lexerDefinition","trackLines","MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE","MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY","modes","defaultMode","MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST","currModeValue","currModeName","currIdx","LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED","currLongerAlt","MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE","performWarningRuntimeChecks","warnings","hasAnyLineBreak","allTokenTypes","concreteTokenTypes","terminatorCharCodes","currIssue","buildLineBreakIssueMessage","warningDescriptor","issue","NO_LINE_BREAKS_FLAGS","cloneEmptyGroups","clonedResult","groupKeys","currKey","currGroupValue","LineTerminatorOptimizedTester","text","len","i","lastIndex","c","IDENTIFY_TERMINATOR","errMsg","CUSTOM_LINE_BREAK","details","charsOrCodes","charCodes","numOrString","map","key","value","minOptimizationVal","charCodeToOptimizedIdxMap","Array"],"sources":["/Users/rociopichardo/Desktop/PFhenryFront/node_modules/chevrotain/src/scan/lexer.ts"],"sourcesContent":["import { BaseRegExpVisitor } from \"regexp-to-ast\"\nimport { IRegExpExec, Lexer, LexerDefinitionErrorType } from \"./lexer_public\"\nimport first from \"lodash/first\"\nimport isEmpty from \"lodash/isEmpty\"\nimport compact from \"lodash/compact\"\nimport isArray from \"lodash/isArray\"\nimport values from \"lodash/values\"\nimport flatten from \"lodash/flatten\"\nimport reject from \"lodash/reject\"\nimport difference from \"lodash/difference\"\nimport indexOf from \"lodash/indexOf\"\nimport map from \"lodash/map\"\nimport forEach from \"lodash/forEach\"\nimport isString from \"lodash/isString\"\nimport isFunction from \"lodash/isFunction\"\nimport isUndefined from \"lodash/isUndefined\"\nimport find from \"lodash/find\"\nimport has from \"lodash/has\"\nimport keys from \"lodash/keys\"\nimport isRegExp from \"lodash/isRegExp\"\nimport filter from \"lodash/filter\"\nimport defaults from \"lodash/defaults\"\nimport reduce from \"lodash/reduce\"\nimport includes from \"lodash/includes\"\nimport { PRINT_ERROR } from \"@chevrotain/utils\"\nimport {\n  canMatchCharCode,\n  failedOptimizationPrefixMsg,\n  getOptimizedStartCodesIndices\n} from \"./reg_exp\"\nimport {\n  ILexerDefinitionError,\n  ILineTerminatorsTester,\n  IMultiModeLexerDefinition,\n  IToken,\n  TokenType\n} from \"@chevrotain/types\"\nimport { getRegExpAst } from \"./reg_exp_parser\"\n\nconst PATTERN = \"PATTERN\"\nexport const DEFAULT_MODE = \"defaultMode\"\nexport const MODES = \"modes\"\n\nexport interface IPatternConfig {\n  pattern: IRegExpExec | string\n  longerAlt: number[] | undefined\n  canLineTerminator: boolean\n  isCustom: boolean\n  short: number | false\n  group: string | undefined | false\n  push: string | undefined\n  pop: boolean\n  tokenType: TokenType\n  tokenTypeIdx: number\n}\n\nexport interface IAnalyzeResult {\n  patternIdxToConfig: IPatternConfig[]\n  charCodeToPatternIdxToConfig: { [charCode: number]: IPatternConfig[] }\n  emptyGroups: { [groupName: string]: IToken[] }\n  hasCustom: boolean\n  canBeOptimized: boolean\n}\n\nexport let SUPPORT_STICKY =\n  typeof (<any>new RegExp(\"(?:)\")).sticky === \"boolean\"\n\nexport function disableSticky() {\n  SUPPORT_STICKY = false\n}\n\nexport function enableSticky() {\n  SUPPORT_STICKY = true\n}\n\nexport function analyzeTokenTypes(\n  tokenTypes: TokenType[],\n  options: {\n    positionTracking?: \"full\" | \"onlyStart\" | \"onlyOffset\"\n    ensureOptimizations?: boolean\n    lineTerminatorCharacters?: (number | string)[]\n    // TODO: should `useSticky` be an argument here?\n    useSticky?: boolean\n    safeMode?: boolean\n    tracer?: (msg: string, action: () => void) => void\n  }\n): IAnalyzeResult {\n  options = defaults(options, {\n    useSticky: SUPPORT_STICKY,\n    debug: false as boolean,\n    safeMode: false as boolean,\n    positionTracking: \"full\",\n    lineTerminatorCharacters: [\"\\r\", \"\\n\"],\n    tracer: (msg: string, action: Function) => action()\n  })\n\n  const tracer = options.tracer!\n\n  tracer(\"initCharCodeToOptimizedIndexMap\", () => {\n    initCharCodeToOptimizedIndexMap()\n  })\n\n  let onlyRelevantTypes: TokenType[]\n  tracer(\"Reject Lexer.NA\", () => {\n    onlyRelevantTypes = reject(tokenTypes, (currType) => {\n      return currType[PATTERN] === Lexer.NA\n    })\n  })\n\n  let hasCustom = false\n  let allTransformedPatterns: (IRegExpExec | string)[]\n  tracer(\"Transform Patterns\", () => {\n    hasCustom = false\n    allTransformedPatterns = map(\n      onlyRelevantTypes,\n      (currType): IRegExpExec | string => {\n        const currPattern = currType[PATTERN]\n\n        /* istanbul ignore else */\n        if (isRegExp(currPattern)) {\n          const regExpSource = currPattern.source\n          if (\n            regExpSource.length === 1 &&\n            // only these regExp meta characters which can appear in a length one regExp\n            regExpSource !== \"^\" &&\n            regExpSource !== \"$\" &&\n            regExpSource !== \".\" &&\n            !currPattern.ignoreCase\n          ) {\n            return regExpSource\n          } else if (\n            regExpSource.length === 2 &&\n            regExpSource[0] === \"\\\\\" &&\n            // not a meta character\n            !includes(\n              [\n                \"d\",\n                \"D\",\n                \"s\",\n                \"S\",\n                \"t\",\n                \"r\",\n                \"n\",\n                \"t\",\n                \"0\",\n                \"c\",\n                \"b\",\n                \"B\",\n                \"f\",\n                \"v\",\n                \"w\",\n                \"W\"\n              ],\n              regExpSource[1]\n            )\n          ) {\n            // escaped meta Characters: /\\+/ /\\[/\n            // or redundant escaping: /\\a/\n            // without the escaping \"\\\"\n            return regExpSource[1]\n          } else {\n            return options.useSticky\n              ? addStickyFlag(currPattern)\n              : addStartOfInput(currPattern)\n          }\n        } else if (isFunction(currPattern)) {\n          hasCustom = true\n          // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object\n          return { exec: currPattern }\n        } else if (typeof currPattern === \"object\") {\n          hasCustom = true\n          // ICustomPattern\n          return currPattern\n        } else if (typeof currPattern === \"string\") {\n          if (currPattern.length === 1) {\n            return currPattern\n          } else {\n            const escapedRegExpString = currPattern.replace(\n              /[\\\\^$.*+?()[\\]{}|]/g,\n              \"\\\\$&\"\n            )\n            const wrappedRegExp = new RegExp(escapedRegExpString)\n            return options.useSticky\n              ? addStickyFlag(wrappedRegExp)\n              : addStartOfInput(wrappedRegExp)\n          }\n        } else {\n          throw Error(\"non exhaustive match\")\n        }\n      }\n    )\n  })\n\n  let patternIdxToType: number[]\n  let patternIdxToGroup: (string | undefined | false)[]\n  let patternIdxToLongerAltIdxArr: (number[] | undefined)[]\n  let patternIdxToPushMode: (string | undefined)[]\n  let patternIdxToPopMode: boolean[]\n  tracer(\"misc mapping\", () => {\n    patternIdxToType = map(\n      onlyRelevantTypes,\n      (currType) => currType.tokenTypeIdx!\n    )\n\n    patternIdxToGroup = map(onlyRelevantTypes, (clazz: any) => {\n      const groupName = clazz.GROUP\n      /* istanbul ignore next */\n      if (groupName === Lexer.SKIPPED) {\n        return undefined\n      } else if (isString(groupName)) {\n        return groupName\n      } else if (isUndefined(groupName)) {\n        return false\n      } else {\n        throw Error(\"non exhaustive match\")\n      }\n    })\n\n    patternIdxToLongerAltIdxArr = map(onlyRelevantTypes, (clazz: any) => {\n      const longerAltType = clazz.LONGER_ALT\n\n      if (longerAltType) {\n        const longerAltIdxArr = isArray(longerAltType)\n          ? map(longerAltType, (type: any) => indexOf(onlyRelevantTypes, type))\n          : [indexOf(onlyRelevantTypes, longerAltType)]\n        return longerAltIdxArr\n      }\n    })\n\n    patternIdxToPushMode = map(\n      onlyRelevantTypes,\n      (clazz: any) => clazz.PUSH_MODE\n    )\n\n    patternIdxToPopMode = map(onlyRelevantTypes, (clazz: any) =>\n      has(clazz, \"POP_MODE\")\n    )\n  })\n\n  let patternIdxToCanLineTerminator: boolean[]\n  tracer(\"Line Terminator Handling\", () => {\n    const lineTerminatorCharCodes = getCharCodes(\n      options.lineTerminatorCharacters!\n    )\n    patternIdxToCanLineTerminator = map(onlyRelevantTypes, (tokType) => false)\n    if (options.positionTracking !== \"onlyOffset\") {\n      patternIdxToCanLineTerminator = map(onlyRelevantTypes, (tokType) => {\n        if (has(tokType, \"LINE_BREAKS\")) {\n          return !!tokType.LINE_BREAKS\n        } else {\n          return (\n            checkLineBreaksIssues(tokType, lineTerminatorCharCodes) === false &&\n            canMatchCharCode(\n              lineTerminatorCharCodes,\n              tokType.PATTERN as RegExp | string\n            )\n          )\n        }\n      })\n    }\n  })\n\n  let patternIdxToIsCustom: boolean[]\n  let patternIdxToShort: (number | false)[]\n  let emptyGroups!: { [groupName: string]: IToken[] }\n  let patternIdxToConfig!: IPatternConfig[]\n  tracer(\"Misc Mapping #2\", () => {\n    patternIdxToIsCustom = map(onlyRelevantTypes, isCustomPattern)\n    patternIdxToShort = map(allTransformedPatterns, isShortPattern)\n\n    emptyGroups = reduce(\n      onlyRelevantTypes,\n      (acc, clazz: any) => {\n        const groupName = clazz.GROUP\n        if (isString(groupName) && !(groupName === Lexer.SKIPPED)) {\n          acc[groupName] = []\n        }\n        return acc\n      },\n      {} as { [groupName: string]: IToken[] }\n    )\n\n    patternIdxToConfig = map(\n      allTransformedPatterns,\n      (x, idx): IPatternConfig => {\n        return {\n          pattern: allTransformedPatterns[idx],\n          longerAlt: patternIdxToLongerAltIdxArr[idx],\n          canLineTerminator: patternIdxToCanLineTerminator[idx],\n          isCustom: patternIdxToIsCustom[idx],\n          short: patternIdxToShort[idx],\n          group: patternIdxToGroup[idx],\n          push: patternIdxToPushMode[idx],\n          pop: patternIdxToPopMode[idx],\n          tokenTypeIdx: patternIdxToType[idx],\n          tokenType: onlyRelevantTypes[idx]\n        }\n      }\n    )\n  })\n\n  let canBeOptimized = true\n  let charCodeToPatternIdxToConfig: { [charCode: number]: IPatternConfig[] } =\n    []\n\n  if (!options.safeMode) {\n    tracer(\"First Char Optimization\", () => {\n      charCodeToPatternIdxToConfig = reduce(\n        onlyRelevantTypes,\n        (result, currTokType, idx) => {\n          if (typeof currTokType.PATTERN === \"string\") {\n            const charCode = currTokType.PATTERN.charCodeAt(0)\n            const optimizedIdx = charCodeToOptimizedIndex(charCode)\n            addToMapOfArrays(result, optimizedIdx, patternIdxToConfig[idx])\n          } else if (isArray(currTokType.START_CHARS_HINT)) {\n            let lastOptimizedIdx: number\n            forEach(currTokType.START_CHARS_HINT, (charOrInt) => {\n              const charCode =\n                typeof charOrInt === \"string\"\n                  ? charOrInt.charCodeAt(0)\n                  : charOrInt\n              const currOptimizedIdx = charCodeToOptimizedIndex(charCode)\n              // Avoid adding the config multiple times\n              /* istanbul ignore else */\n              // - Difficult to check this scenario effects as it is only a performance\n              //   optimization that does not change correctness\n              if (lastOptimizedIdx !== currOptimizedIdx) {\n                lastOptimizedIdx = currOptimizedIdx\n                addToMapOfArrays(\n                  result,\n                  currOptimizedIdx,\n                  patternIdxToConfig[idx]\n                )\n              }\n            })\n          } else if (isRegExp(currTokType.PATTERN)) {\n            if (currTokType.PATTERN.unicode) {\n              canBeOptimized = false\n              if (options.ensureOptimizations) {\n                PRINT_ERROR(\n                  `${failedOptimizationPrefixMsg}` +\n                    `\\tUnable to analyze < ${currTokType.PATTERN.toString()} > pattern.\\n` +\n                    \"\\tThe regexp unicode flag is not currently supported by the regexp-to-ast library.\\n\" +\n                    \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n                    \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE\"\n                )\n              }\n            } else {\n              const optimizedCodes = getOptimizedStartCodesIndices(\n                currTokType.PATTERN,\n                options.ensureOptimizations\n              )\n              /* istanbul ignore if */\n              // start code will only be empty given an empty regExp or failure of regexp-to-ast library\n              // the first should be a different validation and the second cannot be tested.\n              if (isEmpty(optimizedCodes)) {\n                // we cannot understand what codes may start possible matches\n                // The optimization correctness requires knowing start codes for ALL patterns.\n                // Not actually sure this is an error, no debug message\n                canBeOptimized = false\n              }\n              forEach(optimizedCodes, (code) => {\n                addToMapOfArrays(result, code, patternIdxToConfig[idx])\n              })\n            }\n          } else {\n            if (options.ensureOptimizations) {\n              PRINT_ERROR(\n                `${failedOptimizationPrefixMsg}` +\n                  `\\tTokenType: <${currTokType.name}> is using a custom token pattern without providing <start_chars_hint> parameter.\\n` +\n                  \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n                  \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE\"\n              )\n            }\n            canBeOptimized = false\n          }\n\n          return result\n        },\n        [] as { [charCode: number]: IPatternConfig[] }\n      )\n    })\n  }\n\n  return {\n    emptyGroups: emptyGroups,\n    patternIdxToConfig: patternIdxToConfig,\n    charCodeToPatternIdxToConfig: charCodeToPatternIdxToConfig,\n    hasCustom: hasCustom,\n    canBeOptimized: canBeOptimized\n  }\n}\n\nexport function validatePatterns(\n  tokenTypes: TokenType[],\n  validModesNames: string[]\n): ILexerDefinitionError[] {\n  let errors: ILexerDefinitionError[] = []\n\n  const missingResult = findMissingPatterns(tokenTypes)\n  errors = errors.concat(missingResult.errors)\n\n  const invalidResult = findInvalidPatterns(missingResult.valid)\n  const validTokenTypes = invalidResult.valid\n  errors = errors.concat(invalidResult.errors)\n\n  errors = errors.concat(validateRegExpPattern(validTokenTypes))\n\n  errors = errors.concat(findInvalidGroupType(validTokenTypes))\n\n  errors = errors.concat(\n    findModesThatDoNotExist(validTokenTypes, validModesNames)\n  )\n\n  errors = errors.concat(findUnreachablePatterns(validTokenTypes))\n\n  return errors\n}\n\nfunction validateRegExpPattern(\n  tokenTypes: TokenType[]\n): ILexerDefinitionError[] {\n  let errors: ILexerDefinitionError[] = []\n  const withRegExpPatterns = filter(tokenTypes, (currTokType) =>\n    isRegExp(currTokType[PATTERN])\n  )\n\n  errors = errors.concat(findEndOfInputAnchor(withRegExpPatterns))\n\n  errors = errors.concat(findStartOfInputAnchor(withRegExpPatterns))\n\n  errors = errors.concat(findUnsupportedFlags(withRegExpPatterns))\n\n  errors = errors.concat(findDuplicatePatterns(withRegExpPatterns))\n\n  errors = errors.concat(findEmptyMatchRegExps(withRegExpPatterns))\n\n  return errors\n}\n\nexport interface ILexerFilterResult {\n  errors: ILexerDefinitionError[]\n  valid: TokenType[]\n}\n\nexport function findMissingPatterns(\n  tokenTypes: TokenType[]\n): ILexerFilterResult {\n  const tokenTypesWithMissingPattern = filter(tokenTypes, (currType) => {\n    return !has(currType, PATTERN)\n  })\n\n  const errors = map(tokenTypesWithMissingPattern, (currType) => {\n    return {\n      message:\n        \"Token Type: ->\" +\n        currType.name +\n        \"<- missing static 'PATTERN' property\",\n      type: LexerDefinitionErrorType.MISSING_PATTERN,\n      tokenTypes: [currType]\n    }\n  })\n\n  const valid = difference(tokenTypes, tokenTypesWithMissingPattern)\n  return { errors, valid }\n}\n\nexport function findInvalidPatterns(\n  tokenTypes: TokenType[]\n): ILexerFilterResult {\n  const tokenTypesWithInvalidPattern = filter(tokenTypes, (currType) => {\n    const pattern = currType[PATTERN]\n    return (\n      !isRegExp(pattern) &&\n      !isFunction(pattern) &&\n      !has(pattern, \"exec\") &&\n      !isString(pattern)\n    )\n  })\n\n  const errors = map(tokenTypesWithInvalidPattern, (currType) => {\n    return {\n      message:\n        \"Token Type: ->\" +\n        currType.name +\n        \"<- static 'PATTERN' can only be a RegExp, a\" +\n        \" Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.\",\n      type: LexerDefinitionErrorType.INVALID_PATTERN,\n      tokenTypes: [currType]\n    }\n  })\n\n  const valid = difference(tokenTypes, tokenTypesWithInvalidPattern)\n  return { errors, valid }\n}\n\nconst end_of_input = /[^\\\\][$]/\n\nexport function findEndOfInputAnchor(\n  tokenTypes: TokenType[]\n): ILexerDefinitionError[] {\n  class EndAnchorFinder extends BaseRegExpVisitor {\n    found = false\n\n    visitEndAnchor(node: unknown) {\n      this.found = true\n    }\n  }\n\n  const invalidRegex = filter(tokenTypes, (currType) => {\n    const pattern = currType.PATTERN\n\n    try {\n      const regexpAst = getRegExpAst(pattern as RegExp)\n      const endAnchorVisitor = new EndAnchorFinder()\n      endAnchorVisitor.visit(regexpAst)\n\n      return endAnchorVisitor.found\n    } catch (e) {\n      // old behavior in case of runtime exceptions with regexp-to-ast.\n      /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/\n      return end_of_input.test((pattern as RegExp).source)\n    }\n  })\n\n  const errors = map(invalidRegex, (currType) => {\n    return {\n      message:\n        \"Unexpected RegExp Anchor Error:\\n\" +\n        \"\\tToken Type: ->\" +\n        currType.name +\n        \"<- static 'PATTERN' cannot contain end of input anchor '$'\\n\" +\n        \"\\tSee chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS\" +\n        \"\\tfor details.\",\n      type: LexerDefinitionErrorType.EOI_ANCHOR_FOUND,\n      tokenTypes: [currType]\n    }\n  })\n\n  return errors\n}\n\nexport function findEmptyMatchRegExps(\n  tokenTypes: TokenType[]\n): ILexerDefinitionError[] {\n  const matchesEmptyString = filter(tokenTypes, (currType) => {\n    const pattern = currType.PATTERN as RegExp\n    return pattern.test(\"\")\n  })\n\n  const errors = map(matchesEmptyString, (currType) => {\n    return {\n      message:\n        \"Token Type: ->\" +\n        currType.name +\n        \"<- static 'PATTERN' must not match an empty string\",\n      type: LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,\n      tokenTypes: [currType]\n    }\n  })\n\n  return errors\n}\n\nconst start_of_input = /[^\\\\[][\\^]|^\\^/\n\nexport function findStartOfInputAnchor(\n  tokenTypes: TokenType[]\n): ILexerDefinitionError[] {\n  class StartAnchorFinder extends BaseRegExpVisitor {\n    found = false\n\n    visitStartAnchor(node: unknown) {\n      this.found = true\n    }\n  }\n\n  const invalidRegex = filter(tokenTypes, (currType) => {\n    const pattern = currType.PATTERN as RegExp\n    try {\n      const regexpAst = getRegExpAst(pattern)\n      const startAnchorVisitor = new StartAnchorFinder()\n      startAnchorVisitor.visit(regexpAst)\n\n      return startAnchorVisitor.found\n    } catch (e) {\n      // old behavior in case of runtime exceptions with regexp-to-ast.\n      /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/\n      return start_of_input.test(pattern.source)\n    }\n  })\n\n  const errors = map(invalidRegex, (currType) => {\n    return {\n      message:\n        \"Unexpected RegExp Anchor Error:\\n\" +\n        \"\\tToken Type: ->\" +\n        currType.name +\n        \"<- static 'PATTERN' cannot contain start of input anchor '^'\\n\" +\n        \"\\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS\" +\n        \"\\tfor details.\",\n      type: LexerDefinitionErrorType.SOI_ANCHOR_FOUND,\n      tokenTypes: [currType]\n    }\n  })\n\n  return errors\n}\n\nexport function findUnsupportedFlags(\n  tokenTypes: TokenType[]\n): ILexerDefinitionError[] {\n  const invalidFlags = filter(tokenTypes, (currType) => {\n    const pattern = currType[PATTERN]\n    return pattern instanceof RegExp && (pattern.multiline || pattern.global)\n  })\n\n  const errors = map(invalidFlags, (currType) => {\n    return {\n      message:\n        \"Token Type: ->\" +\n        currType.name +\n        \"<- static 'PATTERN' may NOT contain global('g') or multiline('m')\",\n      type: LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,\n      tokenTypes: [currType]\n    }\n  })\n\n  return errors\n}\n\n// This can only test for identical duplicate RegExps, not semantically equivalent ones.\nexport function findDuplicatePatterns(\n  tokenTypes: TokenType[]\n): ILexerDefinitionError[] {\n  const found: TokenType[] = []\n  let identicalPatterns = map(tokenTypes, (outerType: any) => {\n    return reduce(\n      tokenTypes,\n      (result, innerType) => {\n        if (\n          outerType.PATTERN.source === (innerType.PATTERN as RegExp).source &&\n          !includes(found, innerType) &&\n          innerType.PATTERN !== Lexer.NA\n        ) {\n          // this avoids duplicates in the result, each Token Type may only appear in one \"set\"\n          // in essence we are creating Equivalence classes on equality relation.\n          found.push(innerType)\n          result.push(innerType)\n          return result\n        }\n        return result\n      },\n      [] as TokenType[]\n    )\n  })\n\n  identicalPatterns = compact(identicalPatterns)\n\n  const duplicatePatterns = filter(identicalPatterns, (currIdenticalSet) => {\n    return currIdenticalSet.length > 1\n  })\n\n  const errors = map(duplicatePatterns, (setOfIdentical: any) => {\n    const tokenTypeNames = map(setOfIdentical, (currType: any) => {\n      return currType.name\n    })\n\n    const dupPatternSrc = (<any>first(setOfIdentical)).PATTERN\n    return {\n      message:\n        `The same RegExp pattern ->${dupPatternSrc}<-` +\n        `has been used in all of the following Token Types: ${tokenTypeNames.join(\n          \", \"\n        )} <-`,\n      type: LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,\n      tokenTypes: setOfIdentical\n    }\n  })\n\n  return errors\n}\n\nexport function findInvalidGroupType(\n  tokenTypes: TokenType[]\n): ILexerDefinitionError[] {\n  const invalidTypes = filter(tokenTypes, (clazz: any) => {\n    if (!has(clazz, \"GROUP\")) {\n      return false\n    }\n    const group = clazz.GROUP\n\n    return group !== Lexer.SKIPPED && group !== Lexer.NA && !isString(group)\n  })\n\n  const errors = map(invalidTypes, (currType) => {\n    return {\n      message:\n        \"Token Type: ->\" +\n        currType.name +\n        \"<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String\",\n      type: LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,\n      tokenTypes: [currType]\n    }\n  })\n\n  return errors\n}\n\nexport function findModesThatDoNotExist(\n  tokenTypes: TokenType[],\n  validModes: string[]\n): ILexerDefinitionError[] {\n  const invalidModes = filter(tokenTypes, (clazz: any) => {\n    return (\n      clazz.PUSH_MODE !== undefined && !includes(validModes, clazz.PUSH_MODE)\n    )\n  })\n\n  const errors = map(invalidModes, (tokType) => {\n    const msg =\n      `Token Type: ->${tokType.name}<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->${tokType.PUSH_MODE}<-` +\n      `which does not exist`\n    return {\n      message: msg,\n      type: LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,\n      tokenTypes: [tokType]\n    }\n  })\n\n  return errors\n}\n\nexport function findUnreachablePatterns(\n  tokenTypes: TokenType[]\n): ILexerDefinitionError[] {\n  const errors: ILexerDefinitionError[] = []\n\n  const canBeTested = reduce(\n    tokenTypes,\n    (result, tokType, idx) => {\n      const pattern = tokType.PATTERN\n\n      if (pattern === Lexer.NA) {\n        return result\n      }\n\n      // a more comprehensive validation for all forms of regExps would require\n      // deeper regExp analysis capabilities\n      if (isString(pattern)) {\n        result.push({ str: pattern, idx, tokenType: tokType })\n      } else if (isRegExp(pattern) && noMetaChar(pattern)) {\n        result.push({ str: pattern.source, idx, tokenType: tokType })\n      }\n      return result\n    },\n    [] as { str: string; idx: number; tokenType: TokenType }[]\n  )\n\n  forEach(tokenTypes, (tokType, testIdx) => {\n    forEach(canBeTested, ({ str, idx, tokenType }) => {\n      if (testIdx < idx && testTokenType(str, tokType.PATTERN)) {\n        const msg =\n          `Token: ->${tokenType.name}<- can never be matched.\\n` +\n          `Because it appears AFTER the Token Type ->${tokType.name}<-` +\n          `in the lexer's definition.\\n` +\n          `See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE`\n        errors.push({\n          message: msg,\n          type: LexerDefinitionErrorType.UNREACHABLE_PATTERN,\n          tokenTypes: [tokType, tokenType]\n        })\n      }\n    })\n  })\n\n  return errors\n}\n\nfunction testTokenType(str: string, pattern: any): boolean {\n  /* istanbul ignore else */\n  if (isRegExp(pattern)) {\n    const regExpArray = pattern.exec(str)\n    return regExpArray !== null && regExpArray.index === 0\n  } else if (isFunction(pattern)) {\n    // maintain the API of custom patterns\n    return pattern(str, 0, [], {})\n  } else if (has(pattern, \"exec\")) {\n    // maintain the API of custom patterns\n    return pattern.exec(str, 0, [], {})\n  } else if (typeof pattern === \"string\") {\n    return pattern === str\n  } else {\n    throw Error(\"non exhaustive match\")\n  }\n}\n\nfunction noMetaChar(regExp: RegExp): boolean {\n  //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp\n  const metaChars = [\n    \".\",\n    \"\\\\\",\n    \"[\",\n    \"]\",\n    \"|\",\n    \"^\",\n    \"$\",\n    \"(\",\n    \")\",\n    \"?\",\n    \"*\",\n    \"+\",\n    \"{\"\n  ]\n  return (\n    find(metaChars, (char) => regExp.source.indexOf(char) !== -1) === undefined\n  )\n}\n\nexport function addStartOfInput(pattern: RegExp): RegExp {\n  const flags = pattern.ignoreCase ? \"i\" : \"\"\n  // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.\n  // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)\n  return new RegExp(`^(?:${pattern.source})`, flags)\n}\n\nexport function addStickyFlag(pattern: RegExp): RegExp {\n  const flags = pattern.ignoreCase ? \"iy\" : \"y\"\n  // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.\n  // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)\n  return new RegExp(`${pattern.source}`, flags)\n}\n\nexport function performRuntimeChecks(\n  lexerDefinition: IMultiModeLexerDefinition,\n  trackLines: boolean,\n  lineTerminatorCharacters: (number | string)[]\n): ILexerDefinitionError[] {\n  const errors: ILexerDefinitionError[] = []\n\n  // some run time checks to help the end users.\n  if (!has(lexerDefinition, DEFAULT_MODE)) {\n    errors.push({\n      message:\n        \"A MultiMode Lexer cannot be initialized without a <\" +\n        DEFAULT_MODE +\n        \"> property in its definition\\n\",\n      type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\n    })\n  }\n  if (!has(lexerDefinition, MODES)) {\n    errors.push({\n      message:\n        \"A MultiMode Lexer cannot be initialized without a <\" +\n        MODES +\n        \"> property in its definition\\n\",\n      type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\n    })\n  }\n\n  if (\n    has(lexerDefinition, MODES) &&\n    has(lexerDefinition, DEFAULT_MODE) &&\n    !has(lexerDefinition.modes, lexerDefinition.defaultMode)\n  ) {\n    errors.push({\n      message:\n        `A MultiMode Lexer cannot be initialized with a ${DEFAULT_MODE}: <${lexerDefinition.defaultMode}>` +\n        `which does not exist\\n`,\n      type: LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\n    })\n  }\n\n  if (has(lexerDefinition, MODES)) {\n    forEach(lexerDefinition.modes, (currModeValue, currModeName) => {\n      forEach(currModeValue, (currTokType, currIdx) => {\n        if (isUndefined(currTokType)) {\n          errors.push({\n            message:\n              `A Lexer cannot be initialized using an undefined Token Type. Mode:` +\n              `<${currModeName}> at index: <${currIdx}>\\n`,\n            type: LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\n          })\n        } else if (has(currTokType, \"LONGER_ALT\")) {\n          const longerAlt = isArray(currTokType.LONGER_ALT)\n            ? currTokType.LONGER_ALT\n            : [currTokType.LONGER_ALT]\n          forEach(longerAlt, (currLongerAlt) => {\n            if (\n              !isUndefined(currLongerAlt) &&\n              !includes(currModeValue, currLongerAlt)\n            ) {\n              errors.push({\n                message: `A MultiMode Lexer cannot be initialized with a longer_alt <${currLongerAlt.name}> on token <${currTokType.name}> outside of mode <${currModeName}>\\n`,\n                type: LexerDefinitionErrorType.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE\n              })\n            }\n          })\n        }\n      })\n    })\n  }\n\n  return errors\n}\n\nexport function performWarningRuntimeChecks(\n  lexerDefinition: IMultiModeLexerDefinition,\n  trackLines: boolean,\n  lineTerminatorCharacters: (number | string)[]\n): ILexerDefinitionError[] {\n  const warnings = []\n  let hasAnyLineBreak = false\n  const allTokenTypes = compact(flatten(values(lexerDefinition.modes)))\n\n  const concreteTokenTypes = reject(\n    allTokenTypes,\n    (currType) => currType[PATTERN] === Lexer.NA\n  )\n  const terminatorCharCodes = getCharCodes(lineTerminatorCharacters)\n  if (trackLines) {\n    forEach(concreteTokenTypes, (tokType) => {\n      const currIssue = checkLineBreaksIssues(tokType, terminatorCharCodes)\n      if (currIssue !== false) {\n        const message = buildLineBreakIssueMessage(tokType, currIssue)\n        const warningDescriptor = {\n          message,\n          type: currIssue.issue,\n          tokenType: tokType\n        }\n        warnings.push(warningDescriptor)\n      } else {\n        // we don't want to attempt to scan if the user explicitly specified the line_breaks option.\n        if (has(tokType, \"LINE_BREAKS\")) {\n          if (tokType.LINE_BREAKS === true) {\n            hasAnyLineBreak = true\n          }\n        } else {\n          if (\n            canMatchCharCode(terminatorCharCodes, tokType.PATTERN as RegExp)\n          ) {\n            hasAnyLineBreak = true\n          }\n        }\n      }\n    })\n  }\n\n  if (trackLines && !hasAnyLineBreak) {\n    warnings.push({\n      message:\n        \"Warning: No LINE_BREAKS Found.\\n\" +\n        \"\\tThis Lexer has been defined to track line and column information,\\n\" +\n        \"\\tBut none of the Token Types can be identified as matching a line terminator.\\n\" +\n        \"\\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \\n\" +\n        \"\\tfor details.\",\n      type: LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS\n    })\n  }\n  return warnings\n}\n\nexport function cloneEmptyGroups(emptyGroups: {\n  [groupName: string]: IToken\n}): { [groupName: string]: IToken } {\n  const clonedResult: any = {}\n  const groupKeys = keys(emptyGroups)\n\n  forEach(groupKeys, (currKey) => {\n    const currGroupValue = emptyGroups[currKey]\n\n    /* istanbul ignore else */\n    if (isArray(currGroupValue)) {\n      clonedResult[currKey] = []\n    } else {\n      throw Error(\"non exhaustive match\")\n    }\n  })\n\n  return clonedResult\n}\n\n// TODO: refactor to avoid duplication\nexport function isCustomPattern(tokenType: TokenType): boolean {\n  const pattern = tokenType.PATTERN\n  /* istanbul ignore else */\n  if (isRegExp(pattern)) {\n    return false\n  } else if (isFunction(pattern)) {\n    // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object\n    return true\n  } else if (has(pattern, \"exec\")) {\n    // ICustomPattern\n    return true\n  } else if (isString(pattern)) {\n    return false\n  } else {\n    throw Error(\"non exhaustive match\")\n  }\n}\n\nexport function isShortPattern(pattern: any): number | false {\n  if (isString(pattern) && pattern.length === 1) {\n    return pattern.charCodeAt(0)\n  } else {\n    return false\n  }\n}\n\n/**\n * Faster than using a RegExp for default newline detection during lexing.\n */\nexport const LineTerminatorOptimizedTester: ILineTerminatorsTester = {\n  // implements /\\n|\\r\\n?/g.test\n  test: function (text) {\n    const len = text.length\n    for (let i = this.lastIndex; i < len; i++) {\n      const c = text.charCodeAt(i)\n      if (c === 10) {\n        this.lastIndex = i + 1\n        return true\n      } else if (c === 13) {\n        if (text.charCodeAt(i + 1) === 10) {\n          this.lastIndex = i + 2\n        } else {\n          this.lastIndex = i + 1\n        }\n        return true\n      }\n    }\n    return false\n  },\n\n  lastIndex: 0\n}\n\nfunction checkLineBreaksIssues(\n  tokType: TokenType,\n  lineTerminatorCharCodes: number[]\n):\n  | {\n      issue:\n        | LexerDefinitionErrorType.IDENTIFY_TERMINATOR\n        | LexerDefinitionErrorType.CUSTOM_LINE_BREAK\n      errMsg?: string\n    }\n  | false {\n  if (has(tokType, \"LINE_BREAKS\")) {\n    // if the user explicitly declared the line_breaks option we will respect their choice\n    // and assume it is correct.\n    return false\n  } else {\n    /* istanbul ignore else */\n    if (isRegExp(tokType.PATTERN)) {\n      try {\n        // TODO: why is the casting suddenly needed?\n        canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN as RegExp)\n      } catch (e) {\n        /* istanbul ignore next - to test this we would have to mock <canMatchCharCode> to throw an error */\n        return {\n          issue: LexerDefinitionErrorType.IDENTIFY_TERMINATOR,\n          errMsg: (e as Error).message\n        }\n      }\n      return false\n    } else if (isString(tokType.PATTERN)) {\n      // string literal patterns can always be analyzed to detect line terminator usage\n      return false\n    } else if (isCustomPattern(tokType)) {\n      // custom token types\n      return { issue: LexerDefinitionErrorType.CUSTOM_LINE_BREAK }\n    } else {\n      throw Error(\"non exhaustive match\")\n    }\n  }\n}\n\nexport function buildLineBreakIssueMessage(\n  tokType: TokenType,\n  details: {\n    issue:\n      | LexerDefinitionErrorType.IDENTIFY_TERMINATOR\n      | LexerDefinitionErrorType.CUSTOM_LINE_BREAK\n    errMsg?: string\n  }\n): string {\n  /* istanbul ignore else */\n  if (details.issue === LexerDefinitionErrorType.IDENTIFY_TERMINATOR) {\n    return (\n      \"Warning: unable to identify line terminator usage in pattern.\\n\" +\n      `\\tThe problem is in the <${tokType.name}> Token Type\\n` +\n      `\\t Root cause: ${details.errMsg}.\\n` +\n      \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR\"\n    )\n  } else if (details.issue === LexerDefinitionErrorType.CUSTOM_LINE_BREAK) {\n    return (\n      \"Warning: A Custom Token Pattern should specify the <line_breaks> option.\\n\" +\n      `\\tThe problem is in the <${tokType.name}> Token Type\\n` +\n      \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK\"\n    )\n  } else {\n    throw Error(\"non exhaustive match\")\n  }\n}\n\nfunction getCharCodes(charsOrCodes: (number | string)[]): number[] {\n  const charCodes = map(charsOrCodes, (numOrString) => {\n    if (isString(numOrString)) {\n      return numOrString.charCodeAt(0)\n    } else {\n      return numOrString\n    }\n  })\n\n  return charCodes\n}\n\nfunction addToMapOfArrays<T>(\n  map: Record<number, T[]>,\n  key: number,\n  value: T\n): void {\n  if (map[key] === undefined) {\n    map[key] = [value]\n  } else {\n    map[key].push(value)\n  }\n}\n\nexport const minOptimizationVal = 256\n\n/**\n * We are mapping charCode above ASCI (256) into buckets each in the size of 256.\n * This is because ASCI are the most common start chars so each one of those will get its own\n * possible token configs vector.\n *\n * Tokens starting with charCodes \"above\" ASCI are uncommon, so we can \"afford\"\n * to place these into buckets of possible token configs, What we gain from\n * this is avoiding the case of creating an optimization 'charCodeToPatternIdxToConfig'\n * which would contain 10,000+ arrays of small size (e.g unicode Identifiers scenario).\n * Our 'charCodeToPatternIdxToConfig' max size will now be:\n * 256 + (2^16 / 2^8) - 1 === 511\n *\n * note the hack for fast division integer part extraction\n * See: https://stackoverflow.com/a/4228528\n */\nlet charCodeToOptimizedIdxMap: number[] = []\nexport function charCodeToOptimizedIndex(charCode: number): number {\n  return charCode < minOptimizationVal\n    ? charCode\n    : charCodeToOptimizedIdxMap[charCode]\n}\n\n/**\n * This is a compromise between cold start / hot running performance\n * Creating this array takes ~3ms on a modern machine,\n * But if we perform the computation at runtime as needed the CSS Lexer benchmark\n * performance degrades by ~10%\n *\n * TODO: Perhaps it should be lazy initialized only if a charCode > 255 is used.\n */\nfunction initCharCodeToOptimizedIndexMap() {\n  if (isEmpty(charCodeToOptimizedIdxMap)) {\n    charCodeToOptimizedIdxMap = new Array(65536)\n    for (let i = 0; i < 65536; i++) {\n      charCodeToOptimizedIdxMap[i] = i > 255 ? 255 + ~~(i / 255) : i\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}