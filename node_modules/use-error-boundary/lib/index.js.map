{"version":3,"file":"index.js","sources":["../src/ErrorBoundary.ts","../src/use-error-boundary.ts","../src/create-error-boundary.ts","../src/index.cjs.ts"],"sourcesContent":["import { PureComponent } from \"react\"\n\nexport type ErrorObject = {\n  error: any\n}\n\n/**\n * Internal callback, used to link the hook state to the boundary state.\n */\nexport type OnDidCatchCallback = (error: any, errorInfo: any) => void\n\n/**\n * Props of the internal ErrorBoundary component.\n *\n * onDidCatch is used internally.\n * children, render and renderError are public facing and get utilized by the UseErrorBoundaryWrapper.\n */\nexport interface ErrorBoundaryProps {\n  onDidCatch: OnDidCatchCallback\n  children?: React.ReactNode | JSX.Element\n  render?: () => React.ReactNode | JSX.Element\n  renderError?: (error: ErrorObject) => React.ReactNode | JSX.Element\n}\n\n/**\n * Internal ErrorBoundary state.\n */\nexport interface ErrorBoundaryState {\n  hasError: boolean\n  error: any\n}\n\n/**\n * ErrorBoundary class\n *\n * Catches errors using lifecycle methods and renders fallback ui using children or render props.\n */\nexport class ErrorBoundary extends PureComponent<\n  ErrorBoundaryProps,\n  ErrorBoundaryState\n> {\n  /**\n   * Initialize component state.\n   */\n  constructor(props: ErrorBoundaryProps) {\n    super(props)\n\n    this.state = {\n      hasError: false,\n      error: null,\n    }\n  }\n\n  /**\n   * Set error state when the boundary catches.\n   */\n  static getDerivedStateFromError(error: any) {\n    return { hasError: true, error }\n  }\n\n  /**\n   * Use componentDidCatch lifecycle method to report the error using\n   * the onDidCatch prop.\n   */\n  componentDidCatch(error: any, errorInfo: any) {\n    return this.props.onDidCatch(error, errorInfo)\n  }\n\n  /**\n   * Render children or fallback ui depending on the error state.\n   *\n   * Uses render props api if either render or renderError is defined.\n   */\n  render() {\n    const { hasError, error } = this.state\n    const { render, children, renderError } = this.props\n\n    // Prevent rendering of children that caused the error, render fallbacks instead\n    if (hasError) {\n      // Render either components from renderError() or nothing\n      return renderError ? renderError({ error }) : null\n    }\n\n    // Render either components from render() or children or null\n    return render ? render() : children || null\n  }\n}\n","import React, { useRef, useReducer, useCallback } from \"react\"\n\nimport {\n  createErrorBoundary,\n  UseErrorBoundaryWrapper,\n} from \"./create-error-boundary\"\n\nexport interface ErrorState {\n  didCatch: boolean\n  error: any | null\n}\n\nexport interface UseErrorBoundaryState extends ErrorState {\n  ErrorBoundary: UseErrorBoundaryWrapper\n  reset: () => void\n}\n\ninterface StateAction {\n  type: \"catch\" | \"reset\"\n  error?: any | null\n}\n\n/**\n * useErrorBoundary hook options.\n */\nexport interface UseErrorBoundaryOptions {\n  /**\n   * Gets called when the ErrorBoundary catches an error.\n   *\n   * You can use this for logging or reporting errors.\n   */\n  onDidCatch?: (error: any, errorInfo: any) => void\n}\n\n/**\n * useErrorBoundary\n * React hook to use an ErrorBoundary in your component and keep track of the\n * error state of that boundary.\n *\n * Uses a wrapped class component to create the error Boundary, but uses hooks to keep the state\n * in your function component.\n */\n\ntype UseErrorBoundaryReducer = (\n  state: ErrorState,\n  action: StateAction\n) => ErrorState\n\nconst useErrorBoundaryReducer: UseErrorBoundaryReducer = (state, action) => {\n  switch (action.type) {\n    // The component did catch, update state\n    case \"catch\":\n      return {\n        didCatch: true,\n        // Pass the values from action.error\n        error: action.error,\n      }\n    case \"reset\":\n      return {\n        didCatch: false,\n        error: null,\n      }\n    // Unknown action, return state\n    default:\n      return state\n  }\n}\n\nfunction useErrorBoundary(\n  options?: UseErrorBoundaryOptions\n): UseErrorBoundaryState {\n  // Reducer handling the error state\n  const [state, dispatch] = useReducer<UseErrorBoundaryReducer>(\n    useErrorBoundaryReducer,\n    // Default state\n    {\n      didCatch: false,\n      error: null,\n    }\n  )\n  // Create ref for wrapped ErrorBoundary class\n  const errorBoundaryWrapperRef = useRef<UseErrorBoundaryWrapper | null>(null)\n\n  // Create a new wrapped boundary\n  function createWrappedErrorBoundary() {\n    // Create new wrapped ErrorBoundary class with onDidCatch callback\n    return createErrorBoundary((err, errorInfo) => {\n      // Dispatch action in case of an error\n      dispatch({\n        type: \"catch\",\n        error: err,\n      })\n\n      // call onDidCatch if provided by user\n      if (options && options.onDidCatch) options.onDidCatch(err, errorInfo)\n    })\n  }\n\n  // Get the current ref value or initialize it with a new wrapped ErrorBoundary\n  function getWrappedErrorBoundary() {\n    // Get current ref value\n    let errorBoundaryWrapper = errorBoundaryWrapperRef.current\n\n    // Return the component when already initialized\n    if (errorBoundaryWrapper !== null) {\n      return errorBoundaryWrapper\n    }\n\n    // Update the ref with new boundary\n    errorBoundaryWrapperRef.current = createWrappedErrorBoundary()\n\n    // Return the newly created component\n    return errorBoundaryWrapperRef.current\n  }\n\n  const reset = useCallback(() => {\n    // create a new wrapped boundary to force a rerender\n    errorBoundaryWrapperRef.current = createWrappedErrorBoundary()\n    // Reset the hooks error state\n    dispatch({ type: \"reset\" })\n  }, [])\n\n  // Return the wrapped ErrorBoundary class to wrap your components in plus the error state\n  return {\n    ErrorBoundary: getWrappedErrorBoundary(),\n    didCatch: state.didCatch,\n    error: state.error,\n    reset,\n  }\n}\n\nexport default useErrorBoundary\n","import React from \"react\"\n\nimport {\n  ErrorBoundary,\n  ErrorBoundaryProps,\n  OnDidCatchCallback,\n} from \"./ErrorBoundary\"\n\n/**\n * createErrorBoundary\n * Accepts a onDidCatch callback.\n * Creates a UseErrorBoundaryWrapper HOC, to keep the onDidCatch callback while\n * still providing the ability to pass props to the ErrorBoundary\n */\n\nexport type UseErrorBoundaryWrapper = (\n  props: Omit<ErrorBoundaryProps, \"onDidCatch\">\n) => React.ReactElement\n\nexport function createErrorBoundary(\n  onDidCatch: OnDidCatchCallback\n): UseErrorBoundaryWrapper {\n  // Return function component that wraps ErrorBoundary and passes props to it\n  return function UseErrorBoundaryWrapper(props) {\n    // Return ErrorBoundary with original onDidCatch and the current props\n    return React.createElement<ErrorBoundaryProps>(ErrorBoundary, {\n      onDidCatch,\n      children: props.children,\n      render: props.render,\n      renderError: props.renderError,\n    })\n  }\n}\n","// Workaround for mixing named and default exports, see https://github.com/developit/microbundle/issues/712\nimport useErrorBoundary from \"./use-error-boundary\"\nObject.assign(useErrorBoundary, { useErrorBoundary })\nexport default useErrorBoundary\n"],"names":["ErrorBoundary","props","_this","state","hasError","error","getDerivedStateFromError","componentDidCatch","errorInfo","onDidCatch","render","this","children","renderError","PureComponent","useErrorBoundaryReducer","action","type","didCatch","useErrorBoundary","options","useReducer","dispatch","errorBoundaryWrapperRef","useRef","createWrappedErrorBoundary","err","React","createElement","errorBoundaryWrapper","reset","useCallback","current","Object","assign"],"mappings":"0GAqCaA,sBAOX,WAAYC,gBACVC,cAAMD,UAEDE,MAAQ,CACXC,UAAU,EACVC,MAAO,+FAZbL,EAmBSM,yBAAP,SAAgCD,GAC9B,MAAO,CAAED,UAAU,EAAMC,MAAAA,+BAO3BE,kBAAA,SAAkBF,EAAYG,GAC5B,YAAYP,MAAMQ,WAAWJ,EAAOG,MAQtCE,OAAA,WACE,MAA4BC,KAAKR,QACSQ,KAAKV,MAAvCS,IAAAA,OAAQE,IAAAA,SAAUC,IAAAA,YAG1B,SAJQT,SAMCS,EAAcA,EAAY,CAAER,QANnBA,QAM8B,KAIzCK,EAASA,IAAWE,GAAY,SA/CRE,iBCW7BC,EAAmD,SAACZ,EAAOa,GAC/D,OAAQA,EAAOC,MAEb,IAAK,QACH,MAAO,CACLC,UAAU,EAEVb,MAAOW,EAAOX,OAElB,IAAK,QACH,MAAO,CACLa,UAAU,EACVb,MAAO,MAGX,QACE,OAAOF,IAIb,SAASgB,EACPC,GAGA,MAA0BC,aACxBN,EAEA,CACEG,UAAU,EACVb,MAAO,OALJF,OAAOmB,OASRC,EAA0BC,SAAuC,MAGvE,SAASC,IAEP,OClEFhB,EDkE6B,SAACiB,EAAKlB,GAE/Bc,EAAS,CACPL,KAAM,QACNZ,MAAOqB,IAILN,GAAWA,EAAQX,YAAYW,EAAQX,WAAWiB,EAAKlB,aCvEvBP,GAEtC,OAAO0B,UAAMC,cAAkC5B,EAAe,CAC5DS,WAAAA,EACAG,SAAUX,EAAMW,SAChBF,OAAQT,EAAMS,OACdG,YAAaZ,EAAMY,mBATvBJ,ED+FA,IAdMoB,EAcAC,EAAQC,cAAY,WAExBR,EAAwBS,QAAUP,IAElCH,EAAS,CAAEL,KAAM,WAChB,IAGH,MAAO,CACLjB,eAvBI6B,EAAuBN,EAAwBS,QAGtB,OAAzBH,EACKA,GAITN,EAAwBS,QAAUP,IAG3BF,EAAwBS,UAa/Bd,SAAUf,EAAMe,SAChBb,MAAOF,EAAME,MACbyB,MAAAA,GE7HJG,OAAOC,OAAOf,EAAkB,CAAEA,iBAAAA"}