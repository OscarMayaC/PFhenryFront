{"version":3,"file":"index.modern.js","sources":["../src/ErrorBoundary.ts","../src/use-error-boundary.ts","../src/create-error-boundary.ts"],"sourcesContent":["import { PureComponent } from \"react\"\n\nexport type ErrorObject = {\n  error: any\n}\n\n/**\n * Internal callback, used to link the hook state to the boundary state.\n */\nexport type OnDidCatchCallback = (error: any, errorInfo: any) => void\n\n/**\n * Props of the internal ErrorBoundary component.\n *\n * onDidCatch is used internally.\n * children, render and renderError are public facing and get utilized by the UseErrorBoundaryWrapper.\n */\nexport interface ErrorBoundaryProps {\n  onDidCatch: OnDidCatchCallback\n  children?: React.ReactNode | JSX.Element\n  render?: () => React.ReactNode | JSX.Element\n  renderError?: (error: ErrorObject) => React.ReactNode | JSX.Element\n}\n\n/**\n * Internal ErrorBoundary state.\n */\nexport interface ErrorBoundaryState {\n  hasError: boolean\n  error: any\n}\n\n/**\n * ErrorBoundary class\n *\n * Catches errors using lifecycle methods and renders fallback ui using children or render props.\n */\nexport class ErrorBoundary extends PureComponent<\n  ErrorBoundaryProps,\n  ErrorBoundaryState\n> {\n  /**\n   * Initialize component state.\n   */\n  constructor(props: ErrorBoundaryProps) {\n    super(props)\n\n    this.state = {\n      hasError: false,\n      error: null,\n    }\n  }\n\n  /**\n   * Set error state when the boundary catches.\n   */\n  static getDerivedStateFromError(error: any) {\n    return { hasError: true, error }\n  }\n\n  /**\n   * Use componentDidCatch lifecycle method to report the error using\n   * the onDidCatch prop.\n   */\n  componentDidCatch(error: any, errorInfo: any) {\n    return this.props.onDidCatch(error, errorInfo)\n  }\n\n  /**\n   * Render children or fallback ui depending on the error state.\n   *\n   * Uses render props api if either render or renderError is defined.\n   */\n  render() {\n    const { hasError, error } = this.state\n    const { render, children, renderError } = this.props\n\n    // Prevent rendering of children that caused the error, render fallbacks instead\n    if (hasError) {\n      // Render either components from renderError() or nothing\n      return renderError ? renderError({ error }) : null\n    }\n\n    // Render either components from render() or children or null\n    return render ? render() : children || null\n  }\n}\n","import React, { useRef, useReducer, useCallback } from \"react\"\n\nimport {\n  createErrorBoundary,\n  UseErrorBoundaryWrapper,\n} from \"./create-error-boundary\"\n\nexport interface ErrorState {\n  didCatch: boolean\n  error: any | null\n}\n\nexport interface UseErrorBoundaryState extends ErrorState {\n  ErrorBoundary: UseErrorBoundaryWrapper\n  reset: () => void\n}\n\ninterface StateAction {\n  type: \"catch\" | \"reset\"\n  error?: any | null\n}\n\n/**\n * useErrorBoundary hook options.\n */\nexport interface UseErrorBoundaryOptions {\n  /**\n   * Gets called when the ErrorBoundary catches an error.\n   *\n   * You can use this for logging or reporting errors.\n   */\n  onDidCatch?: (error: any, errorInfo: any) => void\n}\n\n/**\n * useErrorBoundary\n * React hook to use an ErrorBoundary in your component and keep track of the\n * error state of that boundary.\n *\n * Uses a wrapped class component to create the error Boundary, but uses hooks to keep the state\n * in your function component.\n */\n\ntype UseErrorBoundaryReducer = (\n  state: ErrorState,\n  action: StateAction\n) => ErrorState\n\nconst useErrorBoundaryReducer: UseErrorBoundaryReducer = (state, action) => {\n  switch (action.type) {\n    // The component did catch, update state\n    case \"catch\":\n      return {\n        didCatch: true,\n        // Pass the values from action.error\n        error: action.error,\n      }\n    case \"reset\":\n      return {\n        didCatch: false,\n        error: null,\n      }\n    // Unknown action, return state\n    default:\n      return state\n  }\n}\n\nfunction useErrorBoundary(\n  options?: UseErrorBoundaryOptions\n): UseErrorBoundaryState {\n  // Reducer handling the error state\n  const [state, dispatch] = useReducer<UseErrorBoundaryReducer>(\n    useErrorBoundaryReducer,\n    // Default state\n    {\n      didCatch: false,\n      error: null,\n    }\n  )\n  // Create ref for wrapped ErrorBoundary class\n  const errorBoundaryWrapperRef = useRef<UseErrorBoundaryWrapper | null>(null)\n\n  // Create a new wrapped boundary\n  function createWrappedErrorBoundary() {\n    // Create new wrapped ErrorBoundary class with onDidCatch callback\n    return createErrorBoundary((err, errorInfo) => {\n      // Dispatch action in case of an error\n      dispatch({\n        type: \"catch\",\n        error: err,\n      })\n\n      // call onDidCatch if provided by user\n      if (options && options.onDidCatch) options.onDidCatch(err, errorInfo)\n    })\n  }\n\n  // Get the current ref value or initialize it with a new wrapped ErrorBoundary\n  function getWrappedErrorBoundary() {\n    // Get current ref value\n    let errorBoundaryWrapper = errorBoundaryWrapperRef.current\n\n    // Return the component when already initialized\n    if (errorBoundaryWrapper !== null) {\n      return errorBoundaryWrapper\n    }\n\n    // Update the ref with new boundary\n    errorBoundaryWrapperRef.current = createWrappedErrorBoundary()\n\n    // Return the newly created component\n    return errorBoundaryWrapperRef.current\n  }\n\n  const reset = useCallback(() => {\n    // create a new wrapped boundary to force a rerender\n    errorBoundaryWrapperRef.current = createWrappedErrorBoundary()\n    // Reset the hooks error state\n    dispatch({ type: \"reset\" })\n  }, [])\n\n  // Return the wrapped ErrorBoundary class to wrap your components in plus the error state\n  return {\n    ErrorBoundary: getWrappedErrorBoundary(),\n    didCatch: state.didCatch,\n    error: state.error,\n    reset,\n  }\n}\n\nexport default useErrorBoundary\n","import React from \"react\"\n\nimport {\n  ErrorBoundary,\n  ErrorBoundaryProps,\n  OnDidCatchCallback,\n} from \"./ErrorBoundary\"\n\n/**\n * createErrorBoundary\n * Accepts a onDidCatch callback.\n * Creates a UseErrorBoundaryWrapper HOC, to keep the onDidCatch callback while\n * still providing the ability to pass props to the ErrorBoundary\n */\n\nexport type UseErrorBoundaryWrapper = (\n  props: Omit<ErrorBoundaryProps, \"onDidCatch\">\n) => React.ReactElement\n\nexport function createErrorBoundary(\n  onDidCatch: OnDidCatchCallback\n): UseErrorBoundaryWrapper {\n  // Return function component that wraps ErrorBoundary and passes props to it\n  return function UseErrorBoundaryWrapper(props) {\n    // Return ErrorBoundary with original onDidCatch and the current props\n    return React.createElement<ErrorBoundaryProps>(ErrorBoundary, {\n      onDidCatch,\n      children: props.children,\n      render: props.render,\n      renderError: props.renderError,\n    })\n  }\n}\n"],"names":["ErrorBoundary","PureComponent","constructor","props","super","this","state","hasError","error","[object Object]","componentDidCatch","errorInfo","onDidCatch","render","children","renderError","useErrorBoundaryReducer","action","type","didCatch","useErrorBoundary","options","dispatch","useReducer","errorBoundaryWrapperRef","useRef","createWrappedErrorBoundary","err","React","createElement","reset","useCallback","current","errorBoundaryWrapper","getWrappedErrorBoundary"],"mappings":"4FAqCaA,UAAsBC,EAOjCC,YAAYC,GACVC,MAAMD,GAENE,KAAKC,MAAQ,CACXC,UAAU,EACVC,MAAO,MAOXC,gCAAgCD,GAC9B,MAAO,CAAED,UAAU,EAAMC,MAAAA,GAO3BE,kBAAkBF,EAAYG,GAC5B,YAAYR,MAAMS,WAAWJ,EAAOG,GAQtCE,SACE,MAAMN,SAAEA,EAAFC,MAAYA,GAAUH,KAAKC,OAC3BO,OAAEA,EAAFC,SAAUA,EAAVC,YAAoBA,GAAgBV,KAAKF,MAG/C,OAAII,EAEKQ,EAAcA,EAAY,CAAEP,MAAAA,IAAW,KAIzCK,EAASA,IAAWC,GAAY,MCpC3C,MAAME,EAAmD,CAACV,EAAOW,KAC/D,OAAQA,EAAOC,MAEb,IAAK,QACH,MAAO,CACLC,UAAU,EAEVX,MAAOS,EAAOT,OAElB,IAAK,QACH,MAAO,CACLW,UAAU,EACVX,MAAO,MAGX,QACE,OAAOF,IAIb,SAASc,EACPC,GAGA,MAAOf,EAAOgB,GAAYC,EACxBP,EAEA,CACEG,UAAU,EACVX,MAAO,OAILgB,EAA0BC,EAAuC,MAGvE,SAASC,IAEP,OClEFd,EDkE6B,CAACe,EAAKhB,KAE/BW,EAAS,CACPJ,KAAM,QACNV,MAAOmB,IAILN,GAAWA,EAAQT,YAAYS,EAAQT,WAAWe,EAAKhB,aCvEvBR,GAEtC,OAAOyB,EAAMC,cAAkC7B,EAAe,CAC5DY,WAAAA,EACAE,SAAUX,EAAMW,SAChBD,OAAQV,EAAMU,OACdE,YAAaZ,EAAMY,mBATvBH,ED+FA,MAAMkB,EAAQC,EAAY,KAExBP,EAAwBQ,QAAUN,IAElCJ,EAAS,CAAEJ,KAAM,WAChB,IAGH,MAAO,CACLlB,cAzBF,WAEE,IAAIiC,EAAuBT,EAAwBQ,QAGnD,OAA6B,OAAzBC,EACKA,GAITT,EAAwBQ,QAAUN,IAG3BF,EAAwBQ,SAYhBE,GACff,SAAUb,EAAMa,SAChBX,MAAOF,EAAME,MACbsB,MAAAA"}