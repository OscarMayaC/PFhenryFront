{"version":3,"file":"functions.js","sources":["../src/center.ts","../src/dedup.ts","../src/utils.ts","../src/inspect.ts","../src/instance.ts","../src/metal-rough.ts","../src/prune.ts","../src/partition.ts","../src/quantize.ts","../src/resample.ts","../src/reorder.ts","../src/sequence.ts","../src/tangents.ts","../src/texture-resize.ts","../src/unweld.ts","../src/weld.ts","../src/colorspace.ts"],"sourcesContent":["import { Document, Transform, vec3 } from '@gltf-transform/core';\nimport { bounds } from '@gltf-transform/core';\n\nconst NAME = 'center';\n\n/** Options for the {@link center} function. */\nexport interface CenterOptions {\n\t/** Location on the model to be considered the pivot, and recentered at the origin. */\n\tpivot?: 'center' | 'above' | 'below' | vec3;\n}\n\nconst CENTER_DEFAULTS: Required<CenterOptions> = {pivot: 'center'};\n\n/**\n * Centers the {@link Scene} at the origin, or above/below it. Transformations from animation,\n * skinning, and morph targets are not taken into account.\n *\n * Example:\n *\n * ```ts\n * await document.transform(center({pivot: 'below'}));\n * ```\n */\nexport function center (_options: CenterOptions = CENTER_DEFAULTS): Transform {\n\tconst options = {...CENTER_DEFAULTS, ..._options} as Required<CenterOptions>;\n\n\treturn (doc: Document): void => {\n\t\tconst logger = doc.getLogger();\n\t\tconst root = doc.getRoot();\n\t\tconst isAnimated = root.listAnimations().length > 0 || root.listSkins().length > 0;\n\n\t\tdoc.getRoot().listScenes().forEach((scene, index) => {\n\t\t\tlogger.debug(`${NAME}: Scene ${index + 1} / ${root.listScenes().length}.`);\n\n\t\t\tlet pivot: vec3;\n\t\t\tif (typeof options.pivot === 'string') {\n\t\t\t\tconst bbox = bounds(scene);\n\t\t\t\tpivot = [\n\t\t\t\t\t(bbox.max[0] - bbox.min[0]) / 2 + bbox.min[0],\n\t\t\t\t\t(bbox.max[1] - bbox.min[1]) / 2 + bbox.min[1],\n\t\t\t\t\t(bbox.max[2] - bbox.min[2]) / 2 + bbox.min[2],\n\t\t\t\t];\n\t\t\t\tif (options.pivot === 'above') pivot[1] = bbox.max[1];\n\t\t\t\tif (options.pivot === 'below') pivot[1] = bbox.min[1];\n\t\t\t} else {\n\t\t\t\tpivot = options.pivot as vec3;\n\t\t\t}\n\n\t\t\tlogger.debug(`${NAME}: Pivot \"${pivot.join(', ')}\".`);\n\n\t\t\tconst offset: vec3 = [-1 * pivot[0], -1 * pivot[1], -1 * pivot[2]];\n\n\t\t\tif (isAnimated) {\n\t\t\t\tlogger.debug(`${NAME}: Model contains animation or skin. Adding a wrapper node.`);\n\t\t\t\tconst offsetNode = doc.createNode('Pivot').setTranslation(offset);\n\t\t\t\tscene.listChildren().forEach((child) => offsetNode.addChild(child));\n\t\t\t\tscene.addChild(offsetNode);\n\t\t\t} else {\n\t\t\t\tlogger.debug(`${NAME}: Skipping wrapper, offsetting all root nodes.`);\n\t\t\t\tscene.listChildren().forEach((child) => {\n\t\t\t\t\tconst t = child.getTranslation();\n\t\t\t\t\tchild.setTranslation([\n\t\t\t\t\t\tt[0] + offset[0],\n\t\t\t\t\t\tt[1] + offset[1],\n\t\t\t\t\t\tt[2] + offset[2],\n\t\t\t\t\t]);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t};\n\n}\n","import { Accessor, BufferUtils, Document, Logger, Mesh, PropertyType, Root, Texture, Transform } from '@gltf-transform/core';\n\nconst NAME = 'dedup';\n\n\n\nexport interface DedupOptions {\n\t/** List of {@link PropertyType} identifiers to be de-duplicated.*/\n\tpropertyTypes: string[];\n}\n\nconst DEDUP_DEFAULTS: Required<DedupOptions> = {\n\tpropertyTypes: [PropertyType.ACCESSOR, PropertyType.MESH, PropertyType.TEXTURE],\n};\n\n/**\n * Removes duplicate {@link Accessor}, {@link Mesh}, and {@link Texture} properties. Based on a\n * [gist by mattdesl](https://gist.github.com/mattdesl/aea40285e2d73916b6b9101b36d84da8).\n *\n * Example:\n *\n * ```ts\n * document.getRoot().listMeshes(); // → [Mesh, Mesh, Mesh]\n *\n * await document.transform(dedup({propertyTypes: [PropertyType.MESH]}));\n *\n * document.getRoot().listMeshes(); // → [Mesh]\n * ```\n */\nexport const dedup = function (_options: DedupOptions = DEDUP_DEFAULTS): Transform {\n\tconst options = {...DEDUP_DEFAULTS, ..._options} as Required<DedupOptions>;\n\n\tconst propertyTypes = new Set(options.propertyTypes);\n\tfor (const propertyType of options.propertyTypes) {\n\t\tif (!DEDUP_DEFAULTS.propertyTypes.includes(propertyType)) {\n\t\t\tthrow new Error(`${NAME}: Unsupported deduplication on type \"${propertyType}\".`);\n\t\t}\n\t}\n\n\treturn (doc: Document): void =>  {\n\t\tconst logger = doc.getLogger();\n\n\t\tif (propertyTypes.has(PropertyType.ACCESSOR)) dedupAccessors(logger, doc);\n\t\tif (propertyTypes.has(PropertyType.MESH)) dedupMeshes(logger, doc);\n\t\tif (propertyTypes.has(PropertyType.TEXTURE)) dedupImages(logger, doc);\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t};\n\n};\n\nfunction dedupAccessors(logger: Logger, doc: Document): void {\n\t// Find all accessors used for mesh data.\n\tconst indicesAccessors: Set<Accessor> = new Set();\n\tconst attributeAccessors: Set<Accessor> = new Set();\n\n\tconst meshes = doc.getRoot().listMeshes();\n\tmeshes.forEach((mesh) => {\n\t\tmesh.listPrimitives().forEach((primitive) => {\n\t\t\tprimitive.listAttributes().forEach((accessor) => (attributeAccessors.add(accessor)));\n\t\t\tconst indices = primitive.getIndices();\n\t\t\tif (indices) indicesAccessors.add(indices);\n\t\t});\n\t});\n\n\t// Find duplicate mesh accessors.\n\tfunction detectDuplicates(accessors: Accessor[]): Map<Accessor, Accessor> {\n\t\tconst duplicateAccessors: Map<Accessor, Accessor> = new Map();\n\n\t\tfor (let i = 0; i < accessors.length; i++) {\n\t\t\tconst a = accessors[i];\n\t\t\tconst aData = a.getArray()!.slice().buffer;\n\n\t\t\tif (duplicateAccessors.has(a)) continue;\n\n\t\t\tfor (let j = 0; j < accessors.length; j++) {\n\t\t\t\tconst b = accessors[j];\n\n\t\t\t\tif (a === b) continue;\n\t\t\t\tif (duplicateAccessors.has(b)) continue;\n\n\t\t\t\tif (a.getType() !== b.getType()) continue;\n\t\t\t\tif (a.getComponentType() !== b.getComponentType()) continue;\n\t\t\t\tif (a.getCount() !== b.getCount()) continue;\n\t\t\t\tif (a.getNormalized() !== b.getNormalized()) continue;\n\t\t\t\tif (BufferUtils.equals(aData, b.getArray()!.slice().buffer)) {\n\t\t\t\t\tduplicateAccessors.set(b, a);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn duplicateAccessors;\n\t}\n\n\tconst duplicateIndices = detectDuplicates(Array.from(indicesAccessors));\n\tlogger.debug(\n\t\t`${NAME}: Found ${duplicateIndices.size} duplicates among ${indicesAccessors.size} indices.`\n\t);\n\n\tconst duplicateAttributes = detectDuplicates(Array.from(attributeAccessors));\n\tlogger.debug(\n\t\t`${NAME}: Found ${duplicateAttributes.size} duplicates among ${attributeAccessors.size}`\n\t\t+ ' attributes.'\n\t);\n\n\t// Dissolve duplicates.\n\tmeshes.forEach((mesh) => {\n\t\tmesh.listPrimitives().forEach((primitive) => {\n\t\t\tprimitive.listAttributes().forEach((accessor) => {\n\t\t\t\tif (duplicateAttributes.has(accessor)) {\n\t\t\t\t\tprimitive.swap(accessor, duplicateAttributes.get(accessor) as Accessor);\n\t\t\t\t}\n\t\t\t});\n\t\t\tconst indices = primitive.getIndices();\n\t\t\tif (indices && duplicateIndices.has(indices)) {\n\t\t\t\tprimitive.swap(indices, duplicateIndices.get(indices) as Accessor);\n\t\t\t}\n\t\t});\n\t});\n\tArray.from(duplicateIndices.keys()).forEach((indices) => indices.dispose());\n\tArray.from(duplicateAttributes.keys()).forEach((attribute) => attribute.dispose());\n}\n\nfunction dedupMeshes(logger: Logger, doc: Document): void {\n\tconst root = doc.getRoot();\n\n\t// Create Accessor -> ID lookup table.\n\tconst accessorIndices = new Map<Accessor, number>();\n\troot.listAccessors().forEach((accessor, index) => {\n\t\taccessorIndices.set(accessor, index);\n\t});\n\n\t// For each mesh, create a hashkey.\n\tconst numMeshes = root.listMeshes().length;\n\tconst uniqueMeshes = new Map<string, Mesh>();\n\tfor (const src of root.listMeshes()) {\n\t\t// For each mesh, create a hashkey.\n\t\tconst srcKeyItems = [];\n\t\tfor (const prim of src.listPrimitives()) {\n\t\t\tconst primKeyItems = [];\n\t\t\tfor (const semantic of prim.listSemantics()) {\n\t\t\t\tconst attribute = prim.getAttribute(semantic)!;\n\t\t\t\tprimKeyItems.push(semantic + ':' + accessorIndices.get(attribute));\n\t\t\t}\n\t\t\tconst indices = prim.getIndices();\n\t\t\tif (indices) {\n\t\t\t\tprimKeyItems.push('indices:' + accessorIndices.get(indices));\n\t\t\t}\n\t\t\tsrcKeyItems.push(primKeyItems.join(','));\n\t\t}\n\n\t\t// If another mesh exists with the same key, replace all instances with that, and dispose\n\t\t// of the duplicate. If not, just cache it.\n\t\tconst meshKey = srcKeyItems.join(';');\n\t\tif (uniqueMeshes.has(meshKey)) {\n\t\t\tconst targetMesh = uniqueMeshes.get(meshKey)!;\n\t\t\tsrc.listParents().forEach((parent) => {\n\t\t\t\tif (parent.propertyType !== PropertyType.ROOT) {\n\t\t\t\t\tparent.swap(src, targetMesh);\n\t\t\t\t}\n\t\t\t});\n\t\t\tsrc.dispose();\n\t\t} else {\n\t\t\tuniqueMeshes.set(meshKey, src);\n\t\t}\n\t}\n\n\tlogger.debug(\n\t\t`${NAME}: Found ${numMeshes - uniqueMeshes.size} duplicates among ${numMeshes} meshes.`\n\t);\n}\n\nfunction dedupImages(logger: Logger, doc: Document): void {\n\tconst root = doc.getRoot();\n\tconst textures = root.listTextures();\n\tconst duplicates: Map<Texture, Texture> = new Map();\n\n\tfor (let i = 0; i < textures.length; i++) {\n\t\tconst a = textures[i];\n\t\tconst aData = a.getImage();\n\n\t\tif (duplicates.has(a)) continue;\n\n\t\tfor (let j = 0; j < textures.length; j++) {\n\t\t\tconst b = textures[j];\n\t\t\tconst bData = b.getImage();\n\n\t\t\tif (a === b) continue;\n\t\t\tif (duplicates.has(b)) continue;\n\n\t\t\t// URIs are intentionally not compared.\n\t\t\tif (a.getMimeType() !== b.getMimeType()) continue;\n\n\t\t\tconst aSize = a.getSize();\n\t\t\tconst bSize = b.getSize();\n\t\t\tif (!aSize || !bSize) continue;\n\t\t\tif (aSize[0] !== bSize[0]) continue;\n\t\t\tif (aSize[1] !== bSize[1]) continue;\n\t\t\tif (!aData || !bData) continue;\n\t\t\tif (BufferUtils.equals(aData, bData)) {\n\t\t\t\tduplicates.set(b, a);\n\t\t\t}\n\t\t}\n\t}\n\n\tlogger.debug(\n\t\t`${NAME}: Found ${duplicates.size} duplicates among ${root.listTextures().length} textures.`\n\t);\n\n\tArray.from(duplicates.entries()).forEach(([src, dst]) => {\n\t\tsrc.listParents().forEach((property) => {\n\t\t\tif (!(property instanceof Root)) property.swap(src, dst);\n\t\t});\n\t\tsrc.dispose();\n\t});\n}\n","import { NdArray } from 'ndarray';\nimport { getPixels, savePixels } from 'ndarray-pixels';\nimport { Primitive, Texture } from '@gltf-transform/core';\n\n/** Maps pixels from source to target textures, with a per-pixel callback. */\nexport async function rewriteTexture(\n\t\tsource: Texture,\n\t\ttarget: Texture,\n\t\tfn: (pixels: NdArray, i: number, j: number) => void): Promise<Texture|null> {\n\n\tif (!source) return null;\n\n\tconst srcImage = source.getImage();\n\tif (!srcImage) return null;\n\n\tconst pixels = await getPixels(new Uint8Array(srcImage), source.getMimeType());\n\n\tfor(let i = 0; i < pixels.shape[0]; ++i) {\n\t\tfor(let j = 0; j < pixels.shape[1]; ++j) {\n\t\t\tfn(pixels, i, j);\n\t\t}\n\t}\n\n\tconst dstImage = (await savePixels(pixels, 'image/png')).buffer;\n\treturn target.setImage(dstImage).setMimeType('image/png');\n}\n\nexport function getGLPrimitiveCount(prim: Primitive): number {\n\tconst indices = prim.getIndices();\n\tconst position = prim.getAttribute('POSITION')!;\n\n\t// Reference: https://www.khronos.org/opengl/wiki/Primitive\n\tswitch (prim.getMode()) {\n\t\tcase Primitive.Mode.POINTS:\n\t\t\treturn position.getCount();\n\t\tcase Primitive.Mode.LINES:\n\t\t\treturn indices\n\t\t\t\t? indices.getCount() / 2\n\t\t\t\t: position.getCount() / 2;\n\t\tcase Primitive.Mode.LINE_LOOP:\n\t\t\treturn position.getCount();\n\t\tcase Primitive.Mode.LINE_STRIP:\n\t\t\treturn position.getCount() - 1;\n\t\tcase Primitive.Mode.TRIANGLES:\n\t\t\treturn indices\n\t\t\t\t? indices.getCount() / 3\n\t\t\t\t: position.getCount() / 3;\n\t\tcase Primitive.Mode.TRIANGLE_STRIP:\n\t\tcase Primitive.Mode.TRIANGLE_FAN:\n\t\t\treturn position.getCount() - 2;\n\t\tdefault:\n\t\t\tthrow new Error('Unexpected mode: ' + prim.getMode());\n\t}\n}\n\nexport class SetMap<K, V> {\n\tprivate _map = new Map<K, Set<V>>();\n\tpublic get size(): number {\n\t\treturn this._map.size;\n\t}\n\tpublic has(k: K): boolean {\n\t\treturn this._map.has(k);\n\t}\n\tpublic add(k: K, v: V): this {\n\t\tlet entry = this._map.get(k);\n\t\tif (!entry) {\n\t\t\tentry = new Set();\n\t\t\tthis._map.set(k, entry);\n\t\t}\n\t\tentry.add(v);\n\t\treturn this;\n\t}\n\tpublic get(k: K): Set<V> {\n\t\treturn this._map.get(k) || new Set();\n\t}\n\tpublic keys(): Iterable<K> {\n\t\treturn this._map.keys();\n\t}\n}\n","import { Accessor, Document, ExtensionProperty, GLTF, ImageUtils, Texture, TypedArray, bounds } from '@gltf-transform/core';\nimport { getGLPrimitiveCount } from './utils';\n\n/** Inspects the contents of a glTF file and returns a JSON report. */\nexport function inspect (doc: Document): InspectReport {\n\treturn {\n\t\tscenes: listScenes(doc),\n\t\tmeshes: listMeshes(doc),\n\t\tmaterials: listMaterials(doc),\n\t\ttextures: listTextures(doc),\n\t\tanimations: listAnimations(doc),\n\t};\n}\n\n/** List scenes. */\nfunction listScenes (doc: Document): InspectPropertyReport<InspectSceneReport> {\n\tconst scenes = doc.getRoot().listScenes().map((scene) => {\n\t\tconst root = scene.listChildren()[0];\n\t\tconst sceneBounds = bounds(scene);\n\t\treturn {\n\t\t\tname: scene.getName(),\n\t\t\trootName: root ? root.getName() : '',\n\t\t\tbboxMin: toPrecision(sceneBounds.min),\n\t\t\tbboxMax: toPrecision(sceneBounds.max),\n\t\t};\n\t});\n\treturn {properties: scenes};\n}\n\n/** List meshes. */\nfunction listMeshes (doc: Document): InspectPropertyReport<InspectMeshReport> {\n\tconst meshes: InspectMeshReport[] = doc.getRoot().listMeshes().map((mesh) => {\n\t\tconst instances = mesh.listParents()\n\t\t\t.filter((parent) => parent.propertyType !== 'Root')\n\t\t\t.length;\n\t\tlet glPrimitives = 0;\n\t\tlet verts = 0;\n\t\tconst semantics = new Set<string>();\n\t\tconst meshIndices = new Set<string>();\n\t\tconst meshAccessors: Set<Accessor> = new Set();\n\n\t\tmesh.listPrimitives().forEach((prim) => {\n\t\t\tfor (const semantic of prim.listSemantics()) {\n\t\t\t\tconst attr = prim.getAttribute(semantic)!;\n\t\t\t\tsemantics.add(semantic + ':' + arrayToType(attr.getArray()!));\n\t\t\t\tmeshAccessors.add(attr);\n\t\t\t}\n\t\t\tfor (const targ of prim.listTargets()) {\n\t\t\t\ttarg.listAttributes().forEach((attr) => meshAccessors.add(attr));\n\t\t\t}\n\t\t\tconst indices = prim.getIndices();\n\t\t\tif (indices) {\n\t\t\t\tmeshIndices.add(arrayToType(indices.getArray()!));\n\t\t\t\tmeshAccessors.add(indices);\n\t\t\t}\n\t\t\tverts += prim.listAttributes()[0].getCount();\n\t\t\tglPrimitives += getGLPrimitiveCount(prim);\n\t\t});\n\n\t\tlet size = 0;\n\t\tArray.from(meshAccessors).forEach((a) => (size += a.getArray()!.byteLength));\n\n\t\tconst modes = mesh.listPrimitives()\n\t\t\t.map((prim) => MeshPrimitiveModeLabels[prim.getMode()]);\n\n\t\treturn {\n\t\t\tname: mesh.getName(),\n\t\t\tmode: Array.from(new Set(modes)),\n\t\t\tprimitives: mesh.listPrimitives().length,\n\t\t\tglPrimitives: glPrimitives,\n\t\t\tvertices: verts,\n\t\t\tindices: Array.from(meshIndices).sort(),\n\t\t\tattributes: Array.from(semantics).sort(),\n\t\t\tinstances: instances,\n\t\t\tsize: size,\n\t\t};\n\t});\n\n\treturn {properties: meshes};\n}\n\n/** List materials. */\nfunction listMaterials (doc: Document): InspectPropertyReport<InspectMaterialReport> {\n\tconst materials: InspectMaterialReport[] = doc.getRoot().listMaterials().map((material) => {\n\t\tconst instances = material.listParents()\n\t\t\t.filter((parent) => parent.propertyType !== 'Root')\n\t\t\t.length;\n\n\t\t// Find all texture slots attached to this material or its extensions.\n\t\tconst extensions = new Set<ExtensionProperty>(material.listExtensions());\n\t\tconst slots = doc.getGraph().getLinks()\n\t\t\t.filter((link) => {\n\t\t\t\tconst child = link.getChild();\n\t\t\t\tconst parent = link.getParent();\n\t\t\t\tif (child instanceof Texture && parent === material) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (child instanceof Texture\n\t\t\t\t\t\t&& parent instanceof ExtensionProperty\n\t\t\t\t\t\t&& extensions.has(parent)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t})\n\t\t\t.map((link) => link.getName());\n\n\t\treturn {\n\t\t\tname: material.getName(),\n\t\t\tinstances,\n\t\t\ttextures: slots,\n\t\t\talphaMode: material.getAlphaMode(),\n\t\t\tdoubleSided: material.getDoubleSided(),\n\t\t};\n\t});\n\n\treturn {properties: materials};\n}\n\n/** List textures. */\nfunction listTextures (doc: Document): InspectPropertyReport<InspectTextureReport> {\n\tconst textures: InspectTextureReport[] = doc.getRoot().listTextures().map((texture) => {\n\t\tconst instances = texture.listParents()\n\t\t\t.filter((parent) => parent.propertyType !== 'Root')\n\t\t\t.length;\n\n\t\tconst slots = doc.getGraph().listParentLinks(texture)\n\t\t\t.map((link) => link.getName())\n\t\t\t.filter((name) => name !== 'texture');\n\n\t\tconst resolution = ImageUtils.getSize(texture.getImage()!, texture.getMimeType());\n\n\t\treturn {\n\t\t\tname: texture.getName(),\n\t\t\turi: texture.getURI(),\n\t\t\tslots: Array.from(new Set(slots)),\n\t\t\tinstances,\n\t\t\tmimeType: texture.getMimeType(),\n\t\t\tresolution: resolution ? resolution.join('x') : '',\n\t\t\tsize: texture.getImage()!.byteLength,\n\t\t\tgpuSize: ImageUtils.getMemSize(texture.getImage()!, texture.getMimeType()),\n\t\t};\n\t});\n\n\treturn {properties: textures};\n}\n\n/** List animations. */\nfunction listAnimations (doc: Document): InspectPropertyReport<InspectAnimationReport> {\n\tconst animations: InspectAnimationReport[] = doc.getRoot().listAnimations().map((anim) => {\n\t\tlet minTime = Infinity;\n\t\tlet maxTime = -Infinity;\n\t\tanim.listSamplers().forEach((sampler) => {\n\t\t\tconst input = sampler.getInput();\n\t\t\tif (!input) return;\n\t\t\tminTime = Math.min(minTime, input.getMin([])[0]);\n\t\t\tmaxTime = Math.max(maxTime, input.getMax([])[0]);\n\t\t});\n\n\t\tlet size = 0;\n\t\tlet keyframes = 0;\n\t\tconst accessors: Set<Accessor> = new Set();\n\t\tanim.listSamplers().forEach((sampler) => {\n\t\t\tconst input = sampler.getInput();\n\t\t\tconst output = sampler.getOutput();\n\t\t\tif (!input) return;\n\t\t\tkeyframes += input.getCount();\n\t\t\taccessors.add(input);\n\t\t\tif (!output) return;\n\t\t\taccessors.add(output);\n\t\t});\n\t\tArray.from(accessors).forEach((accessor) => {\n\t\t\tsize += accessor.getArray()!.byteLength;\n\t\t});\n\n\t\treturn {\n\t\t\tname: anim.getName(),\n\t\t\tchannels: anim.listChannels().length,\n\t\t\tsamplers: anim.listSamplers().length,\n\t\t\tduration: Math.round((maxTime - minTime) * 1000) / 1000,\n\t\t\tkeyframes: keyframes,\n\t\t\tsize: size,\n\t\t};\n\t});\n\n\treturn {properties: animations};\n}\n\nexport interface InspectReport {\n\tscenes: InspectPropertyReport<InspectSceneReport>;\n\tmeshes: InspectPropertyReport<InspectMeshReport>;\n\tmaterials: InspectPropertyReport<InspectMaterialReport>;\n\ttextures: InspectPropertyReport<InspectTextureReport>;\n\tanimations: InspectPropertyReport<InspectAnimationReport>;\n}\n\nexport interface InspectPropertyReport<T> {\n\tproperties: T[];\n\terrors?: string[];\n\twarnings?: string[];\n}\n\nexport interface InspectSceneReport {\n\tname: string;\n\trootName: string;\n\tbboxMin: number[];\n\tbboxMax: number[];\n}\n\nexport interface InspectMeshReport {\n\tname: string;\n\tprimitives: number;\n\tmode: string[];\n\tvertices: number;\n\tglPrimitives: number;\n\tindices: string[];\n\tattributes: string[];\n\tinstances: number;\n\tsize: number;\n}\n\nexport interface InspectMaterialReport {\n\tname: string;\n\tinstances: number;\n\ttextures: string[];\n\talphaMode: GLTF.MaterialAlphaMode;\n\tdoubleSided: boolean;\n}\n\nexport interface InspectTextureReport {\n\tname: string;\n\turi: string;\n\tslots: string[];\n\tinstances: number;\n\tmimeType: string;\n\tresolution: string;\n\tsize: number;\n\tgpuSize: number | null;\n}\n\nexport interface InspectAnimationReport {\n\tname: string;\n\tchannels: number;\n\tsamplers: number;\n\tkeyframes: number;\n\tduration: number;\n\tsize: number;\n}\n\nconst MeshPrimitiveModeLabels = [\n\t'POINTS',\n\t'LINES',\n\t'LINE_LOOP',\n\t'LINE_STRIP',\n\t'TRIANGLES',\n\t'TRIANGLE_STRIP',\n\t'TRIANGLE_FAN',\n];\n\n/** Maps values in a vector to a finite precision. */\nfunction toPrecision(v: number[]): number[] {\n\tfor (let i = 0; i < v.length; i++) {\n\t\tif ((v[i] as number).toFixed) v[i] = Number(v[i].toFixed(5));\n\t}\n\treturn v;\n}\n\nfunction arrayToType(array: TypedArray): string {\n\treturn array.constructor.name.replace('Array', '').toLowerCase();\n}\n","import { Document, Logger, MathUtils, Mesh, Node, Transform, vec3, vec4 } from '@gltf-transform/core';\nimport { InstancedMesh, MeshGPUInstancing } from '@gltf-transform/extensions';\n\nconst NAME = 'instance';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface InstanceOptions {}\n\nconst INSTANCE_DEFAULTS: Required<InstanceOptions> = {};\n\n/**\n * Creates GPU instances (with `EXT_mesh_gpu_instancing`) for shared {@link Mesh} references. No\n * options are currently implemented for this function.\n */\nexport function instance (_options: InstanceOptions = INSTANCE_DEFAULTS): Transform {\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tconst options = {...INSTANCE_DEFAULTS, ..._options} as Required<InstanceOptions>;\n\n\treturn (doc: Document): void => {\n\t\tconst logger = doc.getLogger();\n\t\tconst root = doc.getRoot();\n\t\tconst batchExtension = doc.createExtension(MeshGPUInstancing);\n\n\t\tif (root.listAnimations().length) {\n\t\t\tthrow new Error(`${NAME}: Instancing is not currently supported for animated models.`);\n\t\t}\n\n\t\tlet numBatches = 0;\n\t\tlet numInstances = 0;\n\n\t\tfor (const scene of root.listScenes()) {\n\t\t\t// Gather a one-to-many Mesh/Node mapping, identifying what we can instance.\n\t\t\tconst meshInstances = new Map<Mesh, Set<Node>>();\n\t\t\tscene.traverse((node) => {\n\t\t\t\tconst mesh = node.getMesh();\n\t\t\t\tif (!mesh) return;\n\t\t\t\tmeshInstances.set(mesh, (meshInstances.get(mesh) || new Set<Node>()).add(node));\n\t\t\t});\n\n\t\t\t// For each Mesh, create an InstancedMesh and collect transforms.\n\t\t\tconst modifiedNodes = [];\n\t\t\tfor (const mesh of Array.from(meshInstances.keys())) {\n\t\t\t\tconst nodes = Array.from(meshInstances.get(mesh)!);\n\t\t\t\tif (nodes.length < 2) continue;\n\t\t\t\tif (nodes.some((node) => node.getSkin())) continue;\n\n\t\t\t\tconst batch = createBatch(doc, batchExtension, mesh, nodes.length);\n\t\t\t\tconst batchTranslation = batch.getAttribute('TRANSLATION')!;\n\t\t\t\tconst batchRotation = batch.getAttribute('ROTATION')!;\n\t\t\t\tconst batchScale = batch.getAttribute('SCALE')!;\n\n\t\t\t\tconst batchNode = doc.createNode()\n\t\t\t\t\t.setMesh(mesh)\n\t\t\t\t\t.setExtension('EXT_mesh_gpu_instancing', batch);\n\t\t\t\tscene.addChild(batchNode);\n\n\t\t\t\tlet needsTranslation = false;\n\t\t\t\tlet needsRotation = false;\n\t\t\t\tlet needsScale = false;\n\n\t\t\t\t// For each Node, write TRS properties into instance attributes.\n\t\t\t\tfor (let i = 0; i < nodes.length; i++) {\n\t\t\t\t\tlet t: vec3, r: vec4, s: vec3;\n\t\t\t\t\tconst node = nodes[i];\n\n\t\t\t\t\tbatchTranslation.setElement(i, t = node.getWorldTranslation());\n\t\t\t\t\tbatchRotation.setElement(i, r = node.getWorldRotation());\n\t\t\t\t\tbatchScale.setElement(i, s = node.getWorldScale());\n\n\t\t\t\t\tif (!MathUtils.eq(t, [0, 0, 0])) needsTranslation = true;\n\t\t\t\t\tif (!MathUtils.eq(r, [0, 0, 0, 1])) needsRotation = true;\n\t\t\t\t\tif (!MathUtils.eq(s, [1, 1, 1])) needsScale = true;\n\n\t\t\t\t\t// Mark the node for cleanup.\n\t\t\t\t\tnode.setMesh(null);\n\t\t\t\t\tmodifiedNodes.push(node);\n\t\t\t\t}\n\n\t\t\t\tif (!needsTranslation) batchTranslation.dispose();\n\t\t\t\tif (!needsRotation) batchRotation.dispose();\n\t\t\t\tif (!needsScale) batchScale.dispose();\n\n\t\t\t\tpruneUnusedNodes(modifiedNodes, logger);\n\n\t\t\t\tnumBatches++;\n\t\t\t\tnumInstances += nodes.length;\n\t\t\t}\n\t\t}\n\n\t\tif (numBatches > 0) {\n\t\t\tlogger.info(\n\t\t\t\t`${NAME}: Created ${numBatches} batches, with ${numInstances} total instances.`\n\t\t\t);\n\t\t} else {\n\t\t\tlogger.info(`${NAME}: No meshes with multiple parent nodes were found.`);\n\t\t\tbatchExtension.dispose();\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t};\n\n}\n\nfunction pruneUnusedNodes(nodes: Node[], logger: Logger): void {\n\tlet node: Node | undefined;\n\tlet unusedNodes = 0;\n\twhile ((node = nodes.pop())) {\n\t\tif (node.listChildren().length\n\t\t\t\t|| node.getCamera()\n\t\t\t\t|| node.getMesh()\n\t\t\t\t|| node.getSkin()\n\t\t\t\t|| node.listExtensions().length) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst nodeParent = node.getParent();\n\t\tif (nodeParent instanceof Node) {\n\t\t\tnodes.push(nodeParent);\n\t\t}\n\t\tnode.dispose();\n\t\tunusedNodes++;\n\t}\n\n\tlogger.debug(`${NAME}: Removed ${unusedNodes} unused nodes.`);\n}\n\nfunction createBatch(\n\t\tdoc: Document,\n\t\tbatchExtension: MeshGPUInstancing,\n\t\tmesh: Mesh,\n\t\tcount: number): InstancedMesh {\n\tconst buffer = mesh.listPrimitives()[0].getAttribute('POSITION')!.getBuffer();\n\n\tconst batchTranslation = doc.createAccessor()\n\t\t.setType('VEC3')\n\t\t.setArray(new Float32Array(3 * count))\n\t\t.setBuffer(buffer);\n\tconst batchRotation = doc.createAccessor()\n\t\t.setType('VEC4')\n\t\t.setArray(new Float32Array(4 * count))\n\t\t.setBuffer(buffer);\n\tconst batchScale = doc.createAccessor()\n\t\t.setType('VEC3')\n\t\t.setArray(new Float32Array(3 * count))\n\t\t.setBuffer(buffer);\n\n\treturn batchExtension.createInstancedMesh()\n\t\t.setAttribute('TRANSLATION', batchTranslation)\n\t\t.setAttribute('ROTATION', batchRotation)\n\t\t.setAttribute('SCALE', batchScale);\n}\n","import { Document, Texture, Transform } from '@gltf-transform/core';\nimport { MaterialsIOR, MaterialsPBRSpecularGlossiness, MaterialsSpecular, PBRSpecularGlossiness } from '@gltf-transform/extensions';\nimport { rewriteTexture } from './utils';\n\nconst NAME = 'metalRough';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface MetalRoughOptions {}\n\nconst METALROUGH_DEFAULTS: Required<MetalRoughOptions> = {};\n\n/**\n * Convert {@link Material}s from spec/gloss PBR workflow to metal/rough PBR workflow,\n * removing `KHR_materials_pbrSpecularGlossiness` and adding `KHR_materials_ior` and\n * `KHR_materials_specular`. The metal/rough PBR workflow is preferred for most use cases,\n * and is a prerequisite for other advanced PBR extensions provided by glTF.\n *\n * No options are currently implemented for this function.\n */\nexport function metalRough (_options: MetalRoughOptions = METALROUGH_DEFAULTS): Transform {\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tconst options = {...METALROUGH_DEFAULTS, ..._options} as Required<MetalRoughOptions>;\n\n\treturn async (doc: Document): Promise<void> => {\n\n\t\tconst logger = doc.getLogger();\n\n\t\tconst extensionName = MaterialsPBRSpecularGlossiness.EXTENSION_NAME;\n\t\tconst extensionsUsed = doc.getRoot().listExtensionsUsed().map((ext) => ext.extensionName);\n\t\tif (!extensionsUsed.includes(extensionName)) {\n\t\t\tlogger.warn(`${NAME}: Extension ${extensionName} not found on given document.`);\n\t\t\treturn;\n\t\t}\n\n\t\tconst iorExtension = doc.createExtension(MaterialsIOR) as MaterialsIOR;\n\t\tconst specExtension = doc.createExtension(MaterialsSpecular) as MaterialsSpecular;\n\t\tconst specGlossExtension = doc.createExtension(MaterialsPBRSpecularGlossiness) as\n\t\t\tMaterialsPBRSpecularGlossiness;\n\n\t\tconst inputTextures = new Set<Texture | null>();\n\n\t\tfor (const material of doc.getRoot().listMaterials()) {\n\t\t\tconst specGloss = material.getExtension('KHR_materials_pbrSpecularGlossiness') as\n\t\t\t\tPBRSpecularGlossiness;\n\t\t\tif (!specGloss) continue;\n\n\t\t\t// Create specular extension.\n\t\t\tconst specular = specExtension.createSpecular()\n\t\t\t\t.setSpecularFactor(1.0)\n\t\t\t\t.setSpecularColorFactor(specGloss.getSpecularFactor());\n\n\t\t\t// Stash textures that might become unused, to check and clean up later.\n\t\t\tinputTextures.add(specGloss.getSpecularGlossinessTexture());\n\t\t\tinputTextures.add(material.getBaseColorTexture());\n\t\t\tinputTextures.add(material.getMetallicRoughnessTexture());\n\n\t\t\t// Set up a metal/rough PBR material with IOR=Infinity (or 0), metallic=0. This\n\t\t\t// representation is precise and reliable, but perhaps less convenient for artists\n\t\t\t// than deriving a metalness value. Unfortunately we can't do that without imprecise\n\t\t\t// heuristics, and perhaps user tuning.\n\t\t\t// See: https://github.com/KhronosGroup/glTF/pull/1719#issuecomment-674365677\n\t\t\tmaterial\n\t\t\t\t.setBaseColorFactor(specGloss.getDiffuseFactor())\n\t\t\t\t.setMetallicFactor(0)\n\t\t\t\t.setRoughnessFactor(1)\n\t\t\t\t.setExtension('KHR_materials_ior', iorExtension.createIOR().setIOR(1000))\n\t\t\t\t.setExtension('KHR_materials_specular', specular);\n\n\t\t\t// Move diffuse -> baseColor.\n\t\t\tconst diffuseTexture = specGloss.getDiffuseTexture();\n\t\t\tif (diffuseTexture) {\n\t\t\t\tmaterial.setBaseColorTexture(diffuseTexture);\n\t\t\t\tmaterial.getBaseColorTextureInfo()!.copy(specGloss.getDiffuseTextureInfo()!);\n\t\t\t}\n\n\t\t\t// Move specular + gloss -> specular + roughness.\n\t\t\tconst sgTexture = specGloss.getSpecularGlossinessTexture();\n\t\t\tif (sgTexture) {\n\t\t\t\t// specularGlossiness -> specular.\n\t\t\t\tconst sgTextureInfo = specGloss.getSpecularGlossinessTextureInfo()!;\n\t\t\t\tconst specularTexture = doc.createTexture();\n\t\t\t\tawait rewriteTexture(sgTexture, specularTexture, (pixels, i, j) => {\n\t\t\t\t\tpixels.set(i, j, 3, 255); // Remove glossiness.\n\t\t\t\t});\n\t\t\t\tspecular.setSpecularTexture(specularTexture);\n\t\t\t\tspecular.setSpecularColorTexture(specularTexture);\n\t\t\t\tspecular.getSpecularTextureInfo()!.copy(sgTextureInfo);\n\t\t\t\tspecular.getSpecularColorTextureInfo()!.copy(sgTextureInfo);\n\n\t\t\t\t// specularGlossiness -> roughness.\n\t\t\t\tconst glossinessFactor = specGloss.getGlossinessFactor();\n\t\t\t\tconst metalRoughTexture = doc.createTexture();\n\t\t\t\tawait rewriteTexture(sgTexture, metalRoughTexture, (pixels, i, j) => {\n\t\t\t\t\t// Invert glossiness.\n\t\t\t\t\tconst roughness = 255 - Math.round(pixels.get(i, j, 3) * glossinessFactor);\n\t\t\t\t\tpixels.set(i, j, 0, 0);\n\t\t\t\t\tpixels.set(i, j, 1, roughness);\n\t\t\t\t\tpixels.set(i, j, 2, 0);\n\t\t\t\t\tpixels.set(i, j, 3, 255);\n\t\t\t\t});\n\t\t\t\tmaterial.setMetallicRoughnessTexture(metalRoughTexture);\n\t\t\t\tmaterial.getMetallicRoughnessTextureInfo()!.copy(sgTextureInfo);\n\t\t\t} else {\n\t\t\t\tspecular.setSpecularColorFactor(specGloss.getSpecularFactor());\n\t\t\t\tmaterial.setRoughnessFactor(1 - specGloss.getGlossinessFactor());\n\t\t\t}\n\n\t\t\t// Remove KHR_materials_pbrSpecularGlossiness from the material.\n\t\t\tmaterial.setExtension('KHR_materials_pbrSpecularGlossiness', null);\n\t\t}\n\n\t\t// Remove KHR_materials_pbrSpecularGlossiness from the document.\n\t\tspecGlossExtension.dispose();\n\n\t\t// Clean up unused textures.\n\t\tfor (const tex of inputTextures) {\n\t\t\tif (tex && tex.listParents().length === 1) tex.dispose();\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\n\t};\n\n}\n","import { AnimationChannel, Document, Graph, Property, PropertyType, Root, Transform } from '@gltf-transform/core';\n\nconst NAME = 'prune';\n\nexport interface PruneOptions {\n\t/** List of {@link PropertyType} identifiers to be de-duplicated.*/\n\tpropertyTypes?: string[];\n}\nconst PRUNE_DEFAULTS: Required<PruneOptions> = {\n\tpropertyTypes: [\n\t\tPropertyType.NODE,\n\t\tPropertyType.SKIN,\n\t\tPropertyType.MESH,\n\t\tPropertyType.CAMERA,\n\t\tPropertyType.PRIMITIVE,\n\t\tPropertyType.PRIMITIVE_TARGET,\n\t\tPropertyType.ANIMATION,\n\t\tPropertyType.MATERIAL,\n\t\tPropertyType.TEXTURE,\n\t\tPropertyType.ACCESSOR,\n\t\tPropertyType.BUFFER,\n\t]\n};\n\n/**\n * Removes properties from the file if they are not referenced by a {@link Scene}. Commonly helpful\n * for cleaning up after other operations, e.g. allowing a node to be detached and any unused\n * meshes, materials, or other resources to be removed automatically.\n *\n * Example:\n *\n * ```\n * document.getRoot().listMaterials(); // → [Material, Material]\n *\n * await document.transform(prune());\n *\n * document.getRoot().listMaterials(); // → [Material]\n * ```\n *\n * No options are currently implemented for this function.\n */\nexport const prune = function (_options: PruneOptions = PRUNE_DEFAULTS): Transform {\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tconst options = {...PRUNE_DEFAULTS, ..._options} as Required<PruneOptions>;\n\tconst propertyTypes = options.propertyTypes;\n\n\treturn (doc: Document): void =>  {\n\t\tconst logger = doc.getLogger();\n\t\tconst root = doc.getRoot();\n\t\tconst graph = doc.getGraph();\n\n\t\tconst disposed: Record<string, number> = {};\n\n\t\t// Prune top-down, so that low-level properties like accessors can be removed if the\n\t\t// properties referencing them are removed.\n\n\t\tif (propertyTypes.includes(PropertyType.NODE)) root.listNodes().forEach(treeShake);\n\t\tif (propertyTypes.includes(PropertyType.SKIN)) root.listSkins().forEach(treeShake);\n\t\tif (propertyTypes.includes(PropertyType.MESH)) root.listMeshes().forEach(treeShake);\n\t\tif (propertyTypes.includes(PropertyType.CAMERA)) root.listCameras().forEach(treeShake);\n\n\t\tif (propertyTypes.includes(PropertyType.PRIMITIVE)) {\n\t\t\tindirectTreeShake(graph, PropertyType.PRIMITIVE);\n\t\t}\n\t\tif (propertyTypes.includes(PropertyType.PRIMITIVE_TARGET)) {\n\t\t\tindirectTreeShake(graph, PropertyType.PRIMITIVE_TARGET);\n\t\t}\n\n\t\t// Pruning animations is a bit more complicated:\n\t\t// (1) Remove channels without target nodes.\n\t\t// (2) Remove animations without channels.\n\t\t// (3) Remove samplers orphaned in the process.\n\t\tif (propertyTypes.includes(PropertyType.ANIMATION)) {\n\t\t\tfor (const anim of root.listAnimations()) {\n\t\t\t\tfor (const channel of anim.listChannels()) {\n\t\t\t\t\tif (!channel.getTargetNode()) {\n\t\t\t\t\t\tchannel.dispose();\n\t\t\t\t\t\tmarkDisposed(channel);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!anim.listChannels().length) {\n\t\t\t\t\tconst samplers = anim.listSamplers();\n\t\t\t\t\ttreeShake(anim);\n\t\t\t\t\tsamplers.forEach(treeShake);\n\t\t\t\t} else {\n\t\t\t\t\tanim.listSamplers().forEach(treeShake);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (propertyTypes.includes(PropertyType.MATERIAL)) root.listMaterials().forEach(treeShake);\n\t\tif (propertyTypes.includes(PropertyType.TEXTURE)) root.listTextures().forEach(treeShake);\n\t\tif (propertyTypes.includes(PropertyType.ACCESSOR)) root.listAccessors().forEach(treeShake);\n\t\tif (propertyTypes.includes(PropertyType.BUFFER)) root.listBuffers().forEach(treeShake);\n\n\t\t// TODO(bug): This process does not identify unused ExtensionProperty instances. That could\n\t\t// be a future enhancement, either tracking unlinked properties as if they were connected\n\t\t// to the Graph, or iterating over a property list provided by the Extension. Properties in\n\t\t// use by an Extension are correctly preserved, in the meantime.\n\n\t\tif (Object.keys(disposed).length) {\n\t\t\tconst str = Object.keys(disposed).map((t) => `${t} (${disposed[t]})`).join(', ');\n\t\t\tlogger.info(`${NAME}: Removed types... ${str}`);\n\t\t} else {\n\t\t\tlogger.info(`${NAME}: No unused properties found.`);\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\n\t\t//\n\n\t\t/** Disposes of the given property if it is unused. */\n\t\tfunction treeShake(prop: Property): void {\n\t\t\t// Consider a property unused if it has no references from another property, excluding\n\t\t\t// types Root and AnimationChannel.\n\t\t\tconst parents = prop.listParents()\n\t\t\t\t.filter((p) => !(p instanceof Root || p instanceof AnimationChannel));\n\t\t\tif (!parents.length) {\n\t\t\t\tprop.dispose();\n\t\t\t\tmarkDisposed(prop);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * For property types the Root does not maintain references to, we'll need to search the\n\t\t * graph. It's possible that objects may have been constructed without any outbound links,\n\t\t * but since they're not on the graph they don't need to be tree-shaken.\n\t\t */\n\t\tfunction indirectTreeShake(graph: Graph<Property>, propertyType: string): void {\n\t\t\tgraph.getLinks()\n\t\t\t\t.map((link) => link.getParent())\n\t\t\t\t.filter((parent) => parent.propertyType === propertyType)\n\t\t\t\t.forEach(treeShake);\n\t\t}\n\n\t\t/** Records properties disposed by type. */\n\t\tfunction markDisposed(prop: Property): void {\n\t\t\tdisposed[prop.propertyType] = disposed[prop.propertyType] || 0;\n\t\t\tdisposed[prop.propertyType]++;\n\t\t}\n\n\t};\n\n};\n","import { Document, Logger, PropertyType, Transform } from '@gltf-transform/core';\nimport { prune } from './prune';\n\nconst NAME = 'partition';\n\nexport interface PartitionOptions {\n\tanimations?: boolean | Array<string>;\n\tmeshes?: boolean | Array<string>;\n}\n\nconst PARTITION_DEFAULTS: Required<PartitionOptions> =  {\n\tanimations: true,\n\tmeshes: true,\n};\n\n/**\n * Partitions the binary payload of a glTF file so separate mesh or animation data is in separate\n * `.bin` {@link Buffer}s. This technique may be useful for engines that support lazy-loading\n * specific binary resources as needed over the application lifecycle.\n *\n * Example:\n *\n * ```ts\n * document.getRoot().listBuffers(); // → [Buffer]\n *\n * await document.transform(partition({meshes: true}));\n *\n * document.getRoot().listBuffers(); // → [Buffer, Buffer, ...]\n * ```\n */\nconst partition = (_options: PartitionOptions = PARTITION_DEFAULTS): Transform => {\n\n\tconst options = {...PARTITION_DEFAULTS, ..._options} as Required<PartitionOptions>;\n\n\treturn async (doc: Document): Promise<void> => {\n\t\tconst logger = doc.getLogger();\n\n\t\tif (options.meshes !== false) partitionMeshes(doc, logger, options);\n\t\tif (options.animations !== false) partitionAnimations(doc, logger, options);\n\n\t\tif (!options.meshes && !options.animations) {\n\t\t\tlogger.warn(`${NAME}: Select animations or meshes to create a partition.`);\n\t\t}\n\n\t\tawait doc.transform(prune({propertyTypes: [PropertyType.BUFFER]}));\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t};\n\n};\n\nfunction partitionMeshes (doc: Document, logger: Logger, options: PartitionOptions): void {\n\tconst existingURIs = new Set<string>(doc.getRoot().listBuffers().map((b) => b.getURI()));\n\n\tdoc.getRoot().listMeshes()\n\t\t.forEach((mesh, meshIndex) => {\n\t\t\tif (Array.isArray(options.meshes) && !options.meshes.includes(mesh.getName())) {\n\t\t\t\tlogger.debug(\n\t\t\t\t\t`${NAME}: Skipping mesh #${meshIndex} with name \"${mesh.getName()}\".`\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlogger.debug(`${NAME}: Creating buffer for mesh \"${mesh.getName()}\".`);\n\n\t\t\tconst buffer = doc.createBuffer(mesh.getName())\n\t\t\t\t.setURI(createBufferURI(mesh.getName() || 'mesh', existingURIs));\n\n\t\t\tmesh.listPrimitives()\n\t\t\t\t.forEach((primitive) => {\n\t\t\t\t\tconst indices = primitive.getIndices();\n\t\t\t\t\tif (indices) indices.setBuffer(buffer);\n\t\t\t\t\tprimitive.listAttributes()\n\t\t\t\t\t\t.forEach((attribute) => attribute.setBuffer(buffer));\n\t\t\t\t\tprimitive.listTargets()\n\t\t\t\t\t\t.forEach((primTarget) => {\n\t\t\t\t\t\t\tprimTarget.listAttributes()\n\t\t\t\t\t\t\t\t.forEach((attribute) => attribute.setBuffer(buffer));\n\t\t\t\t\t\t});\n\t\t\t\t});\n\t\t});\n}\n\nfunction partitionAnimations (doc: Document, logger: Logger, options: PartitionOptions): void {\n\tconst existingURIs = new Set<string>(doc.getRoot().listBuffers().map((b) => b.getURI()));\n\n\tdoc.getRoot().listAnimations()\n\t\t.forEach((anim, animIndex) => {\n\t\t\tif (Array.isArray(options.animations) && !options.animations.includes(anim.getName())) {\n\t\t\t\tlogger.debug(\n\t\t\t\t\t`${NAME}: Skipping animation #${animIndex} with name \"${anim.getName()}\".`\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlogger.debug(`${NAME}: Creating buffer for animation \"${anim.getName()}\".`);\n\n\t\t\tconst buffer = doc.createBuffer(anim.getName())\n\t\t\t\t.setURI(createBufferURI(anim.getName() || 'animation', existingURIs));\n\n\t\t\tanim.listSamplers()\n\t\t\t\t.forEach((sampler) => {\n\t\t\t\t\tconst input = sampler.getInput();\n\t\t\t\t\tconst output = sampler.getOutput();\n\t\t\t\t\tif (input) input.setBuffer(buffer);\n\t\t\t\t\tif (output) output.setBuffer(buffer);\n\t\t\t\t});\n\t\t});\n}\n\nfunction createBufferURI (basename: string, existing: Set<string>): string {\n\tlet uri = `${basename}.bin`;\n\tlet i = 1;\n\twhile (existing.has(uri)) uri = `${basename}_${i++}.bin`;\n\treturn uri;\n}\n\nexport { partition };\n","import { Accessor, AnimationChannel, bbox, Document, Logger, mat4, Mesh, Node, Primitive, PrimitiveTarget, PropertyType, Skin, Transform, vec2, vec3, vec4 } from '@gltf-transform/core';\nimport { dedup } from './dedup';\nimport { fromRotationTranslationScale, fromScaling, invert, multiply as multiplyMat4 } from 'gl-matrix/mat4';\nimport { max, min, scale, transformMat4 } from 'gl-matrix/vec3';\nimport { MeshQuantization } from '@gltf-transform/extensions';\nimport { prune } from './prune';\n\nconst NAME = 'quantize';\n\ntype TypedArrayConstructor = Int8ArrayConstructor\n\t| Int16ArrayConstructor\n\t| Uint8ArrayConstructor\n\t| Uint16ArrayConstructor;\nconst SIGNED_INT = [Int8Array, Int16Array, Int32Array] as TypedArrayConstructor[];\n\nconst { TRANSLATION, ROTATION, SCALE, WEIGHTS } = AnimationChannel.TargetPath;\nconst TRS_CHANNELS = [TRANSLATION, ROTATION, SCALE];\n\n/** Options for the {@link quantize} function. */\nexport interface QuantizeOptions {\n\t/** Pattern (regex) used to filter vertex attribute semantics for quantization. Default: all. */\n\tpattern?: RegExp;\n\t/** Bounds for quantization grid. */\n\tquantizationVolume?: 'mesh' | 'scene';\n\t/** Quantization bits for `POSITION` attributes. */\n\tquantizePosition?: number;\n\t/** Quantization bits for `NORMAL` attributes. */\n\tquantizeNormal?: number;\n\t/** Quantization bits for `TEXCOORD_*` attributes. */\n\tquantizeTexcoord?: number;\n\t/** Quantization bits for `COLOR_*` attributes. */\n\tquantizeColor?: number;\n\t/** Quantization bits for `WEIGHT_*` attributes. */\n\tquantizeWeight?: number;\n\t/** Quantization bits for application-specific (`_*`) attributes. */\n\tquantizeGeneric?: number;\n}\n\nexport const QUANTIZE_DEFAULTS: Required<QuantizeOptions> =  {\n\tpattern: /.*/,\n\tquantizationVolume: 'mesh',\n\tquantizePosition: 14,\n\tquantizeNormal: 10,\n\tquantizeTexcoord: 12,\n\tquantizeColor: 8,\n\tquantizeWeight: 8,\n\tquantizeGeneric: 12,\n};\n\n/**\n * References:\n * - https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization\n * - http://www.aclockworkberry.com/normal-unpacking-quantization-errors/\n * - https://www.mathworks.com/help/dsp/ref/uniformencoder.html\n * - https://oroboro.com/compressed-unit-vectors/\n */\n\n/**\n * Quantizes vertex attributes with `KHR_mesh_quantization`, reducing the size and memory footprint\n * of the file.\n */\nconst quantize = (_options: QuantizeOptions = QUANTIZE_DEFAULTS): Transform => {\n\n\tconst options = {...QUANTIZE_DEFAULTS, ..._options} as Required<QuantizeOptions>;\n\n\treturn async (doc: Document): Promise<void> => {\n\t\tconst logger = doc.getLogger();\n\t\tconst root = doc.getRoot();\n\n\t\tdoc.createExtension(MeshQuantization).setRequired(true);\n\n\t\t// Compute vertex position quantization volume.\n\t\tlet nodeTransform: VectorTransform<vec3> | undefined = undefined;\n\t\tif (options.quantizationVolume === 'scene') {\n\t\t\tnodeTransform = getNodeTransform(\n\t\t\t\texpandBounds(root.listMeshes().map(getPositionQuantizationVolume))\n\t\t\t);\n\t\t}\n\n\t\t// Quantize mesh primitives.\n\t\tfor (const mesh of doc.getRoot().listMeshes()) {\n\t\t\tif (options.quantizationVolume === 'mesh') {\n\t\t\t\tnodeTransform = getNodeTransform(getPositionQuantizationVolume(mesh));\n\t\t\t}\n\n\t\t\tif (nodeTransform && options.pattern.test('POSITION')) {\n\t\t\t\ttransformMeshParents(doc, mesh, nodeTransform);\n\t\t\t}\n\n\t\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t\tquantizePrimitive(doc, prim, nodeTransform!, options);\n\t\t\t\tfor (const target of prim.listTargets()) {\n\t\t\t\t\tquantizePrimitive(doc, target, nodeTransform!, options);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tawait doc.transform(\n\t\t\tprune({propertyTypes: [PropertyType.ACCESSOR, PropertyType.SKIN]}),\n\t\t\tdedup({propertyTypes: [PropertyType.ACCESSOR]}),\n\t\t);\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t};\n\n};\n\nfunction quantizePrimitive(\n\t\tdoc: Document,\n\t\tprim: Primitive | PrimitiveTarget,\n\t\tnodeTransform: VectorTransform<vec3>,\n\t\toptions: Required<QuantizeOptions>): void {\n\tconst logger = doc.getLogger();\n\n\tfor (const semantic of prim.listSemantics()) {\n\t\tif (!options.pattern.test(semantic)) continue;\n\n\t\tconst srcAttribute = prim.getAttribute(semantic)!;\n\t\tconst {bits, ctor} = getQuantizationSettings(semantic, srcAttribute, logger, options);\n\n\t\tif (!ctor) continue;\n\t\tif (bits < 8 || bits > 16) throw new Error(`${NAME}: Requires bits = 8–16.`);\n\t\tif (srcAttribute.getComponentSize() <= bits / 8) continue;\n\n\t\tconst dstAttribute = srcAttribute.clone();\n\n\t\t// Remap position data.\n\t\tif (semantic === 'POSITION') {\n\t\t\tconst scale = nodeTransform.scale;\n\t\t\tconst transform: mat4 = [] as unknown as mat4;\n\t\t\t// Morph targets are relative offsets, don't translate them.\n\t\t\tprim instanceof Primitive\n\t\t\t\t? invert(transform, fromTransform(nodeTransform))\n\t\t\t\t: fromScaling(transform, [1 / scale, 1 / scale, 1 / scale]);\n\t\t\tfor (let i = 0, el: vec3 = [0, 0, 0], il = dstAttribute.getCount(); i < il; i++) {\n\t\t\t\tdstAttribute.getElement(i, el);\n\t\t\t\tdstAttribute.setElement(i, transformMat4(el, el, transform) as vec3);\n\t\t\t}\n\t\t}\n\n\t\t// Quantize the vertex attribute.\n\t\tquantizeAttribute(dstAttribute, ctor, bits);\n\t\tprim.swap(srcAttribute, dstAttribute);\n\t}\n\n\t// Normalize skinning weights.\n\tif (prim.getAttribute('WEIGHTS_0')) {\n\t\tnormalizeWeights(prim);\n\t}\n\n\tif (prim instanceof Primitive\n\t\t\t&& prim.getIndices()\n\t\t\t&& prim.listAttributes().length\n\t\t\t&& prim.listAttributes()[0]!.getCount() < 65535) {\n\t\tconst indices = prim.getIndices()!;\n\t\tindices.setArray(new Uint16Array(indices.getArray()!));\n\t}\n}\n\n/** Computes node quantization transforms in local space. */\nfunction getNodeTransform(volume: bbox): VectorTransform<vec3> {\n\tconst {min, max} = volume;\n\n\t// Scaling factor transforms [-1,1] box to the mesh AABB in local space.\n\t// See: https://github.com/donmccurdy/glTF-Transform/issues/328\n\tconst scale = Math.max(\n\t\t(max[0] - min[0]) / 2, // Divide because interval [-1,1] has length 2.\n\t\t(max[1] - min[1]) / 2,\n\t\t(max[2] - min[2]) / 2,\n\t);\n\n\t// Original center of the mesh, in local space.\n\tconst offset: vec3 = [\n\t\tmin[0] + (max[0] - min[0]) / 2,\n\t\tmin[1] + (max[1] - min[1]) / 2,\n\t\tmin[2] + (max[2] - min[2]) / 2,\n\t];\n\n\treturn {offset, scale};\n}\n\n/** Applies corrective scale and offset to nodes referencing a quantized Mesh. */\nfunction transformMeshParents(\n\tdoc: Document,\n\tmesh: Mesh,\n\tnodeTransform: VectorTransform<vec3>\n): void {\n\tconst transformMatrix = fromTransform(nodeTransform);\n\tfor (const parent of mesh.listParents()) {\n\t\tif (parent instanceof Node) {\n\t\t\tconst animChannels = parent.listParents()\n\t\t\t\t.filter((p) => p instanceof AnimationChannel) as AnimationChannel[];\n\t\t\tconst isAnimated = animChannels\n\t\t\t\t.some((channel) => TRS_CHANNELS.includes(channel.getTargetPath()!));\n\t\t\tconst isParentNode = parent.listChildren().length > 0;\n\n\t\t\tif (parent.getSkin()) {\n\t\t\t\tparent.setSkin(transformSkin(parent.getSkin()!, nodeTransform));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlet targetNode: Node;\n\t\t\tif (isParentNode || isAnimated) {\n\t\t\t\ttargetNode = doc.createNode('').setMesh(mesh);\n\t\t\t\tparent.addChild(targetNode).setMesh(null);\n\t\t\t\tanimChannels\n\t\t\t\t\t.filter((channel) => channel.getTargetPath() === WEIGHTS)\n\t\t\t\t\t.forEach((channel) => channel.setTargetNode(targetNode));\n\t\t\t} else {\n\t\t\t\ttargetNode = parent;\n\t\t\t}\n\n\t\t\tconst nodeMatrix = targetNode.getMatrix();\n\t\t\tmultiplyMat4(nodeMatrix, nodeMatrix, transformMatrix);\n\t\t\ttargetNode.setMatrix(nodeMatrix);\n\t\t}\n\t}\n}\n\n/** Applies corrective scale and offset to skin IBMs. */\nfunction transformSkin(skin: Skin, nodeTransform: VectorTransform<vec3>): Skin {\n\tskin = skin.clone();\n\tconst transformMatrix = fromTransform(nodeTransform);\n\tconst inverseBindMatrices = skin.getInverseBindMatrices()!.clone();\n\tconst ibm = [] as unknown as mat4;\n\tfor (let i = 0, count = inverseBindMatrices.getCount(); i < count; i++) {\n\t\tinverseBindMatrices.getElement(i, ibm);\n\t\tmultiplyMat4(ibm, ibm, transformMatrix);\n\t\tinverseBindMatrices.setElement(i, ibm);\n\t}\n\treturn skin.setInverseBindMatrices(inverseBindMatrices);\n}\n\n/**\n * Quantizes an attribute to the given parameters.\n *\n * Uniformly remap 32-bit floats to reduced-precision 8- or 16-bit integers, so\n * that there are only 2^N unique values, for N within [8, 16].\n *\n * See: https://github.com/donmccurdy/glTF-Transform/issues/208\n */\nfunction quantizeAttribute(\n\t\tattribute: Accessor,\n\t\tctor: TypedArrayConstructor,\n\t\tbits: number\n\t): void {\n\n\tconst dstArray = new ctor(attribute.getArray()!.length);\n\n\tconst signBits = SIGNED_INT.includes(ctor) ? 1 : 0;\n\tconst quantBits = bits - signBits;\n\tconst storageBits = ctor.BYTES_PER_ELEMENT * 8 - signBits;\n\n\tconst scale = Math.pow(2, quantBits) - 1;\n\tconst lo = storageBits - quantBits;\n\tconst hi = 2 * quantBits - storageBits;\n\n\tfor (let i = 0, di = 0, el: number[] = []; i < attribute.getCount(); i++) {\n\t\tattribute.getElement(i, el);\n\t\tfor (let j = 0; j < el.length; j++) {\n\t\t\t// Map [0.0 ... 1.0] to [0 ... scale].\n\t\t\tlet value = Math.round(Math.abs(el[j]) * scale);\n\n\t\t\t// Replicate msb to missing lsb.\n\t\t\tvalue = (value << lo) | (value >> hi);\n\n\t\t\t// Restore sign.\n\t\t\tdstArray[di++] = value * Math.sign(el[j]);\n\t\t}\n\t}\n\n\tattribute.setArray(dstArray).setNormalized(true);\n}\n\nfunction getQuantizationSettings(\n\t\tsemantic: string,\n\t\tattribute: Accessor,\n\t\tlogger: Logger,\n\t\toptions: Required<QuantizeOptions>): {bits: number; ctor?: TypedArrayConstructor} {\n\n\tconst min = attribute.getMinNormalized([]);\n\tconst max = attribute.getMaxNormalized([]);\n\n\tlet bits: number;\n\tlet ctor: TypedArrayConstructor;\n\n\tif (semantic === 'POSITION') {\n\t\tbits = options.quantizePosition;\n\t\tctor = bits <= 8 ? Int8Array : Int16Array;\n\t} else if (semantic === 'NORMAL' || semantic === 'TANGENT') {\n\t\tbits = options.quantizeNormal;\n\t\tctor = bits <= 8 ? Int8Array : Int16Array;\n\t} else if (semantic.startsWith('COLOR_')) {\n\t\tbits = options.quantizeColor;\n\t\tctor = bits <= 8 ? Uint8Array : Uint16Array;\n\t} else if (semantic.startsWith('TEXCOORD_')) {\n\t\tif (min.some(v => v < 0) || max.some(v => v > 1)) {\n\t\t\tlogger.warn(`${NAME}: Skipping ${semantic}; out of [0,1] range.`);\n\t\t\treturn {bits: -1};\n\t\t}\n\t\tbits = options.quantizeTexcoord;\n\t\tctor = bits <= 8 ? Uint8Array : Uint16Array;\n\t} else if (semantic.startsWith('JOINTS_')) {\n\t\tbits = Math.max(...attribute.getMax([])) <= 255 ? 8 : 16;\n\t\tctor = bits <= 8 ? Uint8Array : Uint16Array;\n\t\tif (attribute.getComponentSize() > bits / 8) {\n\t\t\tattribute.setArray(new ctor(attribute.getArray()!));\n\t\t}\n\t\treturn {bits: -1};\n\t} else if (semantic.startsWith('WEIGHTS_')) {\n\t\tif (min.some(v => v < 0) || max.some(v => v > 1)) {\n\t\t\tlogger.warn(`${NAME}: Skipping ${semantic}; out of [0,1] range.`);\n\t\t\treturn {bits: -1};\n\t\t}\n\t\tbits = options.quantizeWeight;\n\t\tctor = bits <= 8 ? Uint8Array : Uint16Array;\n\t} else if (semantic.startsWith('_')) {\n\t\tif (min.some(v => v < -1) || max.some(v => v > 1)) {\n\t\t\tlogger.warn(`${NAME}: Skipping ${semantic}; out of [-1,1] range.`);\n\t\t\treturn {bits: -1};\n\t\t}\n\t\tbits = options.quantizeGeneric;\n\t\tctor = min.some(v => v < 0)\n\t\t\t? (ctor = bits <= 8 ? Int8Array : Int16Array)\n\t\t\t: (ctor = bits <= 8 ? Uint8Array : Uint16Array);\n\t} else {\n\t\tthrow new Error(`${NAME}: Unexpected semantic, \"${semantic}\".`);\n\t}\n\n\treturn {bits, ctor};\n}\n\nfunction getPositionQuantizationVolume(mesh: Mesh): bbox {\n\tconst positions: Accessor[] = [];\n\tconst relativePositions: Accessor[] = [];\n\tfor (const prim of mesh.listPrimitives()) {\n\t\tconst attribute = prim.getAttribute('POSITION');\n\t\tif (attribute) positions.push(attribute);\n\t\tfor (const target of prim.listTargets()) {\n\t\t\tconst attribute = target.getAttribute('POSITION');\n\t\t\tif (attribute) relativePositions.push(attribute);\n\t\t}\n\t}\n\n\tif (positions.length === 0) {\n\t\tthrow new Error(`${NAME}: Missing \"POSITION\" attribute.`);\n\t}\n\n\tconst bbox = flatBounds<vec3>(positions, 3);\n\n\t// Morph target quantization volume is computed differently. First, ensure that the origin\n\t// <0, 0, 0> is in the quantization volume. Because we can't offset target positions (they're\n\t// relative deltas), default remapping will only map to a [-2, 2] AABB. Double the bounding box\n\t// to ensure scaling puts them within a [-1, 1] AABB instead.\n\tif (relativePositions.length > 0) {\n\t\tconst {min: relMin, max: relMax} = flatBounds<vec3>(relativePositions, 3);\n\t\tmin(bbox.min, bbox.min, min(relMin, scale(relMin, relMin, 2), [0, 0, 0]));\n\t\tmax(bbox.max, bbox.max, max(relMax, scale(relMax, relMax, 2), [0, 0, 0]));\n\t}\n\n\treturn bbox;\n}\n\n/** Computes total min and max of all Accessors in a list. */\nfunction flatBounds<T = vec2|vec3>(accessors: Accessor[], elementSize: number): ({min: T, max: T}) {\n\tconst min: number[] = new Array(elementSize).fill(Infinity);\n\tconst max: number[] = new Array(elementSize).fill(-Infinity);\n\n\tconst tmpMin: number[] = [];\n\tconst tmpMax: number[] = [];\n\n\tfor (const accessor of accessors) {\n\t\taccessor.getMinNormalized(tmpMin);\n\t\taccessor.getMaxNormalized(tmpMax);\n\t\tfor (let i = 0; i < elementSize; i++) {\n\t\t\tmin[i] = Math.min(min[i], tmpMin[i]);\n\t\t\tmax[i] = Math.max(max[i], tmpMax[i]);\n\t\t}\n\t}\n\n\treturn {min, max} as unknown as {min: T, max: T};\n}\n\nfunction expandBounds(bboxes: bbox[]): bbox {\n\tconst result = bboxes[0];\n\tfor (const bbox of bboxes) {\n\t\tmin(result.min, result.min, bbox.min);\n\t\tmax(result.max, result.max, bbox.max);\n\t}\n\treturn result;\n}\n\ninterface VectorTransform<T = vec2|vec3|vec4> {\n\toffset: T;\n\tscale: number;\n}\n\nfunction fromTransform(transform: VectorTransform<vec3>): mat4 {\n\treturn fromRotationTranslationScale(\n\t\t[] as unknown as mat4,\n\t\t[0, 0, 0, 1],\n\t\ttransform.offset,\n\t\t[transform.scale, transform.scale, transform.scale],\n\t) as mat4;\n}\n\nfunction normalizeWeights(prim: Primitive | PrimitiveTarget): void {\n\tconst vertexCount = prim.getAttribute('POSITION')!.getCount();\n\tconst weightsEl: number[] = [];\n\n\tfor (let i = 0; i < vertexCount; i++) {\n\t\tlet vertexWeightsSum = 0;\n\n\t\tlet leastWeight = Infinity;\n\t\tlet leastIndex = -1;\n\t\tlet leastAttribute: Accessor | null = null;\n\n\t\tlet weights: Accessor | null;\n\t\tlet attributeIndex = 0;\n\n\t\t// Find sum of weights and the joint with the lowest non-zero weight.\n\t\twhile ((weights = prim.getAttribute(`WEIGHTS_${attributeIndex++}`))) {\n\t\t\tweights.getElement(i, weightsEl);\n\t\t\tfor (let j = 0; j < weightsEl.length; j++) {\n\t\t\t\tvertexWeightsSum += weightsEl[j];\n\t\t\t\tif (weightsEl[j] > 0 && weightsEl[j] < leastWeight) {\n\t\t\t\t\tleastAttribute = weights;\n\t\t\t\t\tleastWeight = weightsEl[j];\n\t\t\t\t\tleastIndex = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Normalize by updating least-significant joint weight.\n\t\tif (leastAttribute && vertexWeightsSum !== 1) {\n\t\t\tleastAttribute.getElement(i, weightsEl);\n\t\t\tweightsEl[leastIndex] += 1 - vertexWeightsSum;\n\t\t\tleastAttribute.setElement(i, weightsEl);\n\t\t}\n\t}\n}\n\nexport { quantize };\n","import { Accessor, AnimationSampler, Document, Root, Transform } from '@gltf-transform/core';\n\nconst NAME = 'resample';\n\nexport interface ResampleOptions {tolerance?: number}\n\nconst RESAMPLE_DEFAULTS: Required<ResampleOptions> =  {tolerance: 1e-4};\n\n/**\n * Resample {@link Animation}s, losslessly deduplicating keyframes to reduce file size. Duplicate\n * keyframes are commonly present in animation 'baked' by the authoring software to apply IK\n * constraints or other software-specific features. Based on THREE.KeyframeTrack.optimize().\n *\n * Example: (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\n */\nexport const resample = (_options: ResampleOptions = RESAMPLE_DEFAULTS): Transform => {\n\n\tconst options = {...RESAMPLE_DEFAULTS, ..._options} as Required<ResampleOptions>;\n\n\treturn (doc: Document): void => {\n\t\tconst accessorsVisited = new Set<Accessor>();\n\t\tconst accessorsCountPrev = doc.getRoot().listAccessors().length;\n\t\tconst logger = doc.getLogger();\n\n\t\tlet didSkipMorphTargets = false;\n\n\t\tfor (const animation of doc.getRoot().listAnimations()) {\n\t\t\t// Skip morph targets, see https://github.com/donmccurdy/glTF-Transform/issues/290.\n\t\t\tconst morphTargetSamplers = new Set<AnimationSampler>();\n\t\t\tfor (const channel of animation.listChannels()) {\n\t\t\t\tif (channel.getSampler() && channel.getTargetPath() === 'weights') {\n\t\t\t\t\tmorphTargetSamplers.add(channel.getSampler()!);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (const sampler of animation.listSamplers()) {\n\t\t\t\tif (morphTargetSamplers.has(sampler)) {\n\t\t\t\t\tdidSkipMorphTargets = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (sampler.getInterpolation() === 'STEP'\n\t\t\t\t\t|| sampler.getInterpolation() === 'LINEAR') {\n\t\t\t\t\taccessorsVisited.add(sampler.getInput()!);\n\t\t\t\t\taccessorsVisited.add(sampler.getOutput()!);\n\t\t\t\t\toptimize(sampler, options);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (const accessor of Array.from(accessorsVisited.values())) {\n\t\t\tconst used = accessor.listParents().some((p) => !(p instanceof Root));\n\t\t\tif (!used) accessor.dispose();\n\t\t}\n\n\t\tif (doc.getRoot().listAccessors().length > accessorsCountPrev) {\n\t\t\tlogger.warn(\n\t\t\t\t`${NAME}: Resampling required copying accessors, some of which may be duplicates.`\n\t\t\t\t+ ' Consider using \"dedup\" to consolidate any duplicates.'\n\t\t\t);\n\t\t}\n\n\t\tif (didSkipMorphTargets) {\n\t\t\tlogger.warn(`${NAME}: Skipped optimizing morph target keyframes, not yet supported.`);\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t};\n\n};\n\nfunction optimize (sampler: AnimationSampler, options: ResampleOptions): void {\n\tconst input = sampler.getInput()!.clone();\n\tconst output = sampler.getOutput()!.clone();\n\n\tconst tolerance = options.tolerance as number;\n\n\tconst lastIndex = input.getCount() - 1;\n\tconst tmp: number[] = [];\n\n\tlet writeIndex = 1;\n\n\tfor (let i = 1; i < lastIndex; ++ i) {\n\t\tconst time = input.getScalar(i);\n\t\tconst timePrev = input.getScalar(i - 1);\n\t\tconst timeNext = input.getScalar(i + 1);\n\t\tconst timeMix = (time - timePrev) / (timeNext - timePrev);\n\n\t\tlet keep = false;\n\n\t\t// Remove unnecessary adjacent keyframes.\n\t\tif (time !== timeNext && (i !== 1 || time !== input.getScalar(0))) {\n\t\t\tfor (let j = 0; j < output.getElementSize(); j++) {\n\t\t\t\tconst value = output.getElement(i, tmp)[j];\n\t\t\t\tconst valuePrev = output.getElement(i - 1, tmp)[j];\n\t\t\t\tconst valueNext = output.getElement(i + 1, tmp)[j];\n\n\t\t\t\tif (sampler.getInterpolation() === 'LINEAR') {\n\t\t\t\t\t// Prune keyframes that are colinear with prev/next keyframes.\n\t\t\t\t\tif (Math.abs(value - lerp(valuePrev, valueNext, timeMix)) > tolerance) {\n\t\t\t\t\t\tkeep = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else if (sampler.getInterpolation() === 'STEP') {\n\t\t\t\t\t// Prune keyframes that are identical to prev/next keyframes.\n\t\t\t\t\tif (value !== valuePrev || value !== valueNext) {\n\t\t\t\t\t\tkeep = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// In-place compaction.\n\t\tif (keep) {\n\t\t\tif (i !== writeIndex) {\n\t\t\t\tinput.setScalar(writeIndex, input.getScalar(i));\n\t\t\t\toutput.setElement(writeIndex, output.getElement(i, tmp));\n\t\t\t}\n\t\t\twriteIndex++;\n\t\t}\n\n\t}\n\n\t// Flush last keyframe (compaction looks ahead).\n\tif (lastIndex > 0) {\n\t\tinput.setScalar(writeIndex, input.getScalar(lastIndex));\n\t\toutput.setElement(writeIndex, output.getElement(lastIndex, tmp));\n\t\twriteIndex++;\n\t}\n\n\t// If the sampler was optimized, truncate and save the results. If not, clean up.\n\tif (writeIndex !== input.getCount()) {\n\t\tinput.setArray(input.getArray()!.slice(0, writeIndex));\n\t\toutput.setArray(output.getArray()!.slice(0, writeIndex * output.getElementSize()));\n\t\tsampler.setInput(input);\n\t\tsampler.setOutput(output);\n\t} else {\n\t\tinput.dispose();\n\t\toutput.dispose();\n\t}\n}\n\nfunction lerp (v0: number, v1: number, t: number): number {\n    return v0 * (1 - t) + v1 * t;\n}\n","import { Accessor, Document, GLTF, Primitive, PropertyType, Transform } from '@gltf-transform/core';\nimport { prune } from './prune';\nimport { SetMap } from './utils';\nimport type { MeshoptEncoder } from 'meshoptimizer';\n\nconst NAME = 'reorder';\n\n/** Options for the {@link reorder} function. */\nexport interface ReorderOptions {\n\t/** MeshoptEncoder instance. */\n\tencoder?: typeof MeshoptEncoder,\n\t/**\n\t * Whether the order should be optimal for transmission size (recommended for Web)\n\t * or for GPU rendering performance. Default is 'size'.\n\t */\n\ttarget?: 'size' | 'performance',\n}\n\nconst REORDER_DEFAULTS: Required<Omit<ReorderOptions, 'encoder'>> = {\n\ttarget: 'size',\n};\n\ninterface LayoutPlan {\n\tindicesToMode: Map<Accessor, GLTF.MeshPrimitiveMode>;\n\tindicesToAttributes: SetMap<Accessor, Accessor>;\n\tattributesToPrimitives: SetMap<Accessor, Primitive>;\n}\n\n/**\n * Optimizes {@link Mesh} {@link Primitive Primitives} for locality of reference. Choose whether\n * the order should be optimal for transmission size (recommended for Web) or for GPU rendering\n * performance. Requires a MeshoptEncoder instance from the Meshoptimizer library.\n *\n * Example:\n *\n * ```ts\n * import { MeshoptEncoder } from 'meshoptimizer';\n * import { reorder } from '@gltf-transform/functions';\n *\n * await document.transform(\n * \treorder({encoder: MeshoptEncoder})\n * );\n * ```\n */\nexport function reorder (_options: ReorderOptions = REORDER_DEFAULTS): Transform {\n\tconst options = {...REORDER_DEFAULTS, ..._options} as Required<ReorderOptions>;\n\tconst encoder = options.encoder;\n\n\treturn async (doc: Document): Promise<void> => {\n\t\tconst logger = doc.getLogger();\n\n\t\tawait encoder.ready;\n\n\t\tconst plan = preprocessPrimitives(doc);\n\n\t\tfor (const srcIndices of plan.indicesToAttributes.keys()) {\n\t\t\tconst dstIndices = srcIndices.clone();\n\t\t\tlet indicesArray = dstIndices.getArray()!.slice();\n\t\t\tif (!(indicesArray instanceof Uint32Array)) {\n\t\t\t\tindicesArray = new Uint32Array(indicesArray);\n\t\t\t}\n\n\t\t\t// Compute optimal order.\n\t\t\tconst [remap, unique] = encoder.reorderMesh(\n\t\t\t\tindicesArray,\n\t\t\t\tplan.indicesToMode.get(srcIndices) === Primitive.Mode.TRIANGLES,\n\t\t\t\toptions.target === 'size'\n\t\t\t);\n\n\t\t\tdstIndices.setArray(unique <= 65534 ? new Uint16Array(indicesArray) : indicesArray);\n\n\t\t\t// Update affected primitives.\n\t\t\tfor (const srcAttribute of plan.indicesToAttributes.get(srcIndices)) {\n\t\t\t\tconst dstAttribute = srcAttribute.clone();\n\t\t\t\tremapAttribute(dstAttribute, remap, unique);\n\t\t\t\tfor (const prim of plan.attributesToPrimitives.get(srcAttribute)) {\n\t\t\t\t\tif (prim.getIndices() === srcIndices) {\n\t\t\t\t\t\tprim.swap(srcIndices, dstIndices);\n\t\t\t\t\t}\n\t\t\t\t\tif (prim.getIndices() === dstIndices) {\n\t\t\t\t\t\tprim.swap(srcAttribute, dstAttribute);\n\t\t\t\t\t\tfor (const target of prim.listTargets()) {\n\t\t\t\t\t\t\ttarget.swap(srcAttribute, dstAttribute);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Clean up any attributes left unused by earlier cloning.\n\t\tawait doc.transform(prune({propertyTypes: [PropertyType.ACCESSOR]}));\n\n\t\tif (!plan.indicesToAttributes.size) {\n\t\t\tlogger.warn(`${NAME}: No qualifying primitives found; may need to weld first.`);\n\t\t} else {\n\t\t\tlogger.debug(`${NAME}: Complete.`);\n\t\t}\n\t};\n}\n\nfunction remapAttribute(attribute: Accessor, remap: Uint32Array, dstCount: number) {\n\tconst elementSize = attribute.getElementSize();\n\tconst srcCount = attribute.getCount();\n\tconst srcArray = attribute.getArray()!;\n\tconst dstArray = srcArray.slice(0, dstCount * elementSize);\n\n\tfor (let i = 0; i < srcCount; i++) {\n\t\tfor (let j = 0; j < elementSize; j++) {\n\t\t\tdstArray[remap[i] * elementSize + j] = srcArray[i * elementSize + j];\n\t\t}\n\t}\n\n\tattribute.setArray(dstArray);\n}\n\n/**\n * Constructs a plan for creating optimal vertex cache order, based on unique\n * index:attribute[] groups. Where different indices are used with the same\n * attributes, we'll end up splitting the primitives to not share attributes,\n * which appears to be consistent with the Meshopt implementation.\n */\nfunction preprocessPrimitives(doc: Document): LayoutPlan {\n\tconst indicesToAttributes = new SetMap<Accessor, Accessor>();\n\tconst indicesToMode = new Map<Accessor, GLTF.MeshPrimitiveMode>();\n\tconst attributesToPrimitives = new SetMap<Accessor, Primitive>();\n\n\tfor (const mesh of doc.getRoot().listMeshes()) {\n\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\tconst indices = prim.getIndices();\n\t\t\tif (!indices) continue;\n\n\t\t\tindicesToMode.set(indices, prim.getMode());\n\n\t\t\tfor (const attribute of listAttributes(prim)) {\n\t\t\t\tindicesToAttributes.add(indices, attribute);\n\t\t\t\tattributesToPrimitives.add(attribute, prim);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {indicesToAttributes, indicesToMode, attributesToPrimitives};\n}\n\nfunction listAttributes(prim: Primitive): Accessor[] {\n\tconst accessors: Accessor[] = [];\n\n\tfor (const attribute of prim.listAttributes()) {\n\t\taccessors.push(attribute);\n\t}\n\tfor (const target of prim.listTargets()) {\n\t\tfor (const attribute of target.listAttributes()) {\n\t\t\taccessors.push(attribute);\n\t\t}\n\t}\n\n\treturn Array.from(new Set(accessors));\n}\n","import { Accessor, AnimationChannel, AnimationSampler, Document, Transform } from '@gltf-transform/core';\n\nconst NAME = 'sequence';\n\nexport interface SequenceOptions {\n\t/** Frames per second, where one node is shown each frame. Default 10. */\n\tfps?: number;\n\t/** Pattern (regex) used to filter nodes for the sequence. Required. */\n\tpattern: RegExp;\n\t/** Name of the new animation. */\n\tname?: string;\n\t/** Whether to sort the nodes by name, or use original order. Default true. */\n\tsort?: boolean;\n}\n\nconst SEQUENCE_DEFAULTS: Required<SequenceOptions> = {\n\tname: '',\n\tfps: 10,\n\tpattern: /.*/,\n\tsort: true,\n};\n\n/**\n * Creates an {@link Animation} displaying each of the specified {@link Node}s sequentially.\n */\nexport function sequence (_options: SequenceOptions = SEQUENCE_DEFAULTS): Transform {\n\tconst options = {...SEQUENCE_DEFAULTS, ..._options} as Required<SequenceOptions>;\n\n\treturn (doc: Document): void => {\n\n\t\tconst logger = doc.getLogger();\n\t\tconst root = doc.getRoot();\n\t\tconst fps = options.fps;\n\n\t\t// Collect sequence nodes.\n\t\tconst sequenceNodes = root.listNodes()\n\t\t\t.filter((node) => node.getName().match(options.pattern));\n\n\t\t// Sort by node name.\n\t\tif (options.sort) {\n\t\t\tsequenceNodes.sort((a, b) => a.getName() > b.getName() ? 1 : -1);\n\t\t}\n\n\t\t// Create animation cycling visibility of each node.\n\t\tconst anim = doc.createAnimation(options.name);\n\t\tconst animBuffer = root.listBuffers()[0];\n\t\tsequenceNodes.forEach((node, i) => {\n\t\t\t// Create keyframe tracks that show each node for a single frame.\n\t\t\tlet inputArray;\n\t\t\tlet outputArray;\n\t\t\tif (i === 0) {\n\t\t\t\tinputArray = [i / fps, (i + 1) / fps];\n\t\t\t\toutputArray = [1, 1, 1, 0, 0, 0];\n\t\t\t} else if (i === sequenceNodes.length - 1) {\n\t\t\t\tinputArray = [(i - 1) / fps, i / fps];\n\t\t\t\toutputArray = [0, 0, 0, 1, 1, 1];\n\t\t\t} else {\n\t\t\t\tinputArray = [(i - 1) / fps, i / fps, (i + 1) / fps];\n\t\t\t\toutputArray = [0, 0, 0, 1, 1, 1, 0, 0, 0];\n\t\t\t}\n\n\t\t\t// Append channel to animation sequence.\n\t\t\tconst input = doc.createAccessor()\n\t\t\t\t.setArray(new Float32Array(inputArray))\n\t\t\t\t.setBuffer(animBuffer);\n\t\t\tconst output = doc.createAccessor()\n\t\t\t\t.setArray(new Float32Array(outputArray))\n\t\t\t\t.setBuffer(animBuffer)\n\t\t\t\t.setType(Accessor.Type.VEC3);\n\t\t\tconst sampler = doc.createAnimationSampler()\n\t\t\t\t.setInterpolation(AnimationSampler.Interpolation.STEP)\n\t\t\t\t.setInput(input)\n\t\t\t\t.setOutput(output);\n\t\t\tconst channel = doc.createAnimationChannel()\n\t\t\t\t.setTargetNode(node)\n\t\t\t\t.setTargetPath(AnimationChannel.TargetPath.SCALE)\n\t\t\t\t.setSampler(sampler);\n\t\t\tanim.addSampler(sampler).addChannel(channel);\n\t\t});\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\n\t};\n\n}\n","import { Accessor, Document, Logger, Primitive, Transform, TypedArray, uuid } from '@gltf-transform/core';\n\nconst NAME = 'tangents';\n\n/** Options for the {@link tangents} function. */\nexport interface TangentsOptions {\n\t/**\n\t * Callback function to generate tangents from position, uv, and normal attributes.\n\t * Generally, users will want to provide the `generateTangents` from the\n\t * [mikktspace](https://github.com/donmccurdy/mikktspace-wasm) library, which is not\n\t * included by default.\n\t */\n\tgenerateTangents?: (pos: Float32Array, norm: Float32Array, uv: Float32Array) => Float32Array,\n\t/** Whether to overwrite existing `TANGENT` attributes. */\n\toverwrite?: boolean,\n}\n\nconst TANGENTS_DEFAULTS: Required<Omit<TangentsOptions, 'generateTangents'>> = {\n\toverwrite: false,\n};\n\n/**\n * Generates MikkTSpace vertex tangents for mesh primitives, which may fix rendering issues\n * occuring with some baked normal maps. Requires access to the [mikktspace](https://github.com/donmccurdy/mikktspace-wasm)\n * WASM package, or equivalent.\n *\n * Example:\n *\n * ```ts\n * import { generateTangents } from 'mikktspace';\n * import { tangents } from '@gltf-transform/functions';\n *\n * await document.transform(\n * \ttangents({generateTangents})\n * );\n * ```\n */\nexport function tangents (_options: TangentsOptions = TANGENTS_DEFAULTS): Transform {\n\tif (!_options.generateTangents) {\n\t\tthrow new Error(`${NAME}: generateTangents callback required — install \"mikktspace\".`);\n\t}\n\n\tconst options = {...TANGENTS_DEFAULTS, ..._options} as Required<TangentsOptions>;\n\n\treturn (doc: Document): void => {\n\t\tconst logger = doc.getLogger();\n\t\tconst attributeIDs = new Map<TypedArray, string>();\n\t\tconst tangentCache = new Map<string, Accessor>();\n\t\tlet modified = 0;\n\n\t\tfor (const mesh of doc.getRoot().listMeshes()) {\n\t\t\tconst meshName = mesh.getName();\n\t\t\tconst meshPrimitives = mesh.listPrimitives();\n\n\t\t\tfor (let i = 0; i < meshPrimitives.length; i++) {\n\t\t\t\tconst prim = meshPrimitives[i];\n\n\t\t\t\t// Skip primitives for which we can't compute tangents.\n\t\t\t\tif (!filterPrimitive(prim, logger, meshName, i, options.overwrite)) continue;\n\n\t\t\t\tconst texcoordSemantic = getNormalTexcoord(prim);\n\n\t\t\t\t// Nullability conditions checked by filterPrimitive() above.\n\t\t\t\tconst position = prim.getAttribute('POSITION')!.getArray()!;\n\t\t\t\tconst normal = prim.getAttribute('NORMAL')!.getArray()!;\n\t\t\t\tconst texcoord = prim.getAttribute(texcoordSemantic)!.getArray()!;\n\n\t\t\t\t// Compute UUIDs for each attribute.\n\t\t\t\tconst positionID = attributeIDs.get(position) || uuid();\n\t\t\t\tattributeIDs.set(position, positionID);\n\n\t\t\t\tconst normalID = attributeIDs.get(normal) || uuid();\n\t\t\t\tattributeIDs.set(normal, normalID);\n\n\t\t\t\tconst texcoordID = attributeIDs.get(texcoord) || uuid();\n\t\t\t\tattributeIDs.set(texcoord, texcoordID);\n\n\t\t\t\t// Dispose of previous TANGENT accessor if only used by this primitive (and Root).\n\t\t\t\tconst prevTangent = prim.getAttribute('TANGENT');\n\t\t\t\tif (prevTangent && prevTangent.listParents().length === 2) prevTangent.dispose();\n\n\t\t\t\t// If we've already computed tangents for this pos/norm/uv set, reuse them.\n\t\t\t\tconst attributeHash = `${positionID}|${normalID}|${texcoordID}`;\n\t\t\t\tlet tangent = tangentCache.get(attributeHash);\n\t\t\t\tif (tangent) {\n\t\t\t\t\tlogger.debug(`${NAME}: Found cache for primitive ${i} of mesh \"${meshName}\".`);\n\t\t\t\t\tprim.setAttribute('TANGENT', tangent);\n\t\t\t\t\tmodified++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Otherwise, generate tangents with the 'mikktspace' WASM library.\n\t\t\t\tlogger.debug(`${NAME}: Generating for primitive ${i} of mesh \"${meshName}\".`);\n\t\t\t\tconst tangentBuffer = prim.getAttribute('POSITION')!.getBuffer();\n\t\t\t\tconst tangentArray = options.generateTangents(\n\t\t\t\t\tposition instanceof Float32Array ? position : new Float32Array(position),\n\t\t\t\t\tnormal instanceof Float32Array ? normal : new Float32Array(normal),\n\t\t\t\t\ttexcoord instanceof Float32Array ? texcoord : new Float32Array(texcoord)\n\t\t\t\t);\n\n\t\t\t\t// See: https://github.com/KhronosGroup/glTF-Sample-Models/issues/174\n\t\t\t\tfor (let i = 3; i < tangentArray.length; i += 4) tangentArray[i] *= -1;\n\n\t\t\t\ttangent = doc.createAccessor()\n\t\t\t\t\t.setBuffer(tangentBuffer)\n\t\t\t\t\t.setArray(tangentArray)\n\t\t\t\t\t.setType('VEC4');\n\t\t\t\tprim.setAttribute('TANGENT', tangent);\n\n\t\t\t\ttangentCache.set(attributeHash, tangent);\n\t\t\t\tmodified++;\n\t\t\t}\n\t\t}\n\n\t\tif (!modified) {\n\t\t\tlogger.warn(`${NAME}: No qualifying primitives found. See debug output.`);\n\t\t} else {\n\t\t\tlogger.debug(`${NAME}: Complete.`);\n\t\t}\n\t};\n}\n\nfunction getNormalTexcoord(prim: Primitive): string {\n\tconst material = prim.getMaterial();\n\tif (!material) return 'TEXCOORD_0';\n\n\tconst normalTextureInfo = material.getNormalTextureInfo();\n\tif (!normalTextureInfo) return 'TEXCOORD_0';\n\n\tconst texcoord = normalTextureInfo.getTexCoord();\n\tconst semantic = `TEXCOORD_${texcoord}`;\n\tif (prim.getAttribute(semantic)) return semantic;\n\n\treturn 'TEXCOORD_0';\n}\n\nfunction filterPrimitive(\n\t\tprim: Primitive,\n\t\tlogger: Logger,\n\t\tmeshName: string,\n\t\ti: number,\n\t\toverwrite: boolean): boolean {\n\n\tif (prim.getMode() !== Primitive.Mode.TRIANGLES\n\t\t\t|| !prim.getAttribute('POSITION')\n\t\t\t|| !prim.getAttribute('NORMAL')\n\t\t\t|| !prim.getAttribute('TEXCOORD_0')) {\n\t\tlogger.debug(\n\t\t\t`${NAME}: Skipping primitive ${i} of mesh \"${meshName}\": primitives must`\n\t\t\t+ ' have attributes=[POSITION, NORMAL, TEXCOORD_0] and mode=TRIANGLES.'\n\t\t);\n\t\treturn false;\n\t}\n\n\tif (prim.getAttribute('TANGENT') && !overwrite) {\n\t\tlogger.debug(\n\t\t\t`${NAME}: Skipping primitive ${i} of mesh \"${meshName}\": TANGENT found.`\n\t\t);\n\t\treturn false;\n\t}\n\n\tif (prim.getIndices()) {\n\t\t// TODO(feat): Do this automatically for qualifying primitives.\n\t\tlogger.warn(\n\t\t\t`${NAME}: Skipping primitive ${i} of mesh \"${meshName}\": primitives must`\n\t\t\t+ ' be unwelded.'\n\t\t);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n","import ndarray from 'ndarray';\nimport { lanczos2, lanczos3 } from 'ndarray-lanczos';\nimport { getPixels, savePixels } from 'ndarray-pixels';\nimport { Document, Transform, vec2 } from '@gltf-transform/core';\n\nconst NAME = 'textureResize';\n\n/** Options for the {@link textureResize} function. */\nexport interface TextureResizeOptions {\n\t/**\n\t * Maximum width/height to enforce, preserving aspect ratio. For example,\n\t * a 4096x8192 texture, resized with limit [2048, 2048] will be reduced\n\t * to 1024x2048.\n\t */\n\tsize: vec2;\n\t/** Resampling filter method. LANCZOS3 is sharper, LANCZOS2 is smoother. */\n\tfilter?: TextureResizeFilter;\n\t/** Pattern identifying textures to resize, matched to name or URI. */\n\tpattern?: RegExp | null;\n}\n\n/** Resampling filter methods. LANCZOS3 is sharper, LANCZOS2 is smoother. */\nexport enum TextureResizeFilter {\n\t/** Lanczos3 (sharp) */\n\tLANCZOS3 = 'lanczos3',\n\t/** Lanczos2 (smooth) */\n\tLANCZOS2 = 'lanczos2',\n}\n\nexport const TEXTURE_RESIZE_DEFAULTS: TextureResizeOptions = {\n\tsize: [2048, 2048],\n\tfilter: TextureResizeFilter.LANCZOS3,\n\tpattern: null\n};\n\n/**\n * Resize PNG or JPEG {@link Texture Textures}, with {@link https://en.wikipedia.org/wiki/Lanczos_algorithm Lanczos filtering}.\n * Implementation provided by {@link https://github.com/donmccurdy/ndarray-lanczos ndarray-lanczos} package.\n */\nexport function textureResize(_options: TextureResizeOptions = TEXTURE_RESIZE_DEFAULTS): Transform {\n\tconst options = {...TEXTURE_RESIZE_DEFAULTS, ..._options} as Required<TextureResizeOptions>;\n\n\treturn async (doc: Document): Promise<void> => {\n\n\t\tconst logger = doc.getLogger();\n\n\t\tfor (const texture of doc.getRoot().listTextures()) {\n\t\t\tconst name = texture.getName();\n\t\t\tconst uri = texture.getURI();\n\t\t\tconst match = !options.pattern\n\t\t\t\t|| options.pattern.test(name)\n\t\t\t\t|| options.pattern.test(uri);\n\t\t\tif (!match) continue;\n\n\t\t\tif (texture.getMimeType() !== 'image/png' && texture.getMimeType() !== 'image/jpeg') {\n\t\t\t\tlogger.warn(`Skipping unsupported texture type, \"${texture.getMimeType()}\".`);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst [maxWidth, maxHeight] = options.size;\n\t\t\tconst [srcWidth, srcHeight] = texture.getSize()!;\n\n\t\t\tif (srcWidth <= maxWidth && srcHeight <= maxHeight) {\n\t\t\t\tlogger.debug(`${NAME}: Skipping \"${uri || name}\", within size range.`);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlet dstWidth = srcWidth;\n\t\t\tlet dstHeight = srcHeight;\n\n\t\t\tif (dstWidth > maxWidth) {\n\t\t\t\tdstHeight = Math.floor(dstHeight * (maxWidth / dstWidth));\n\t\t\t\tdstWidth = maxWidth;\n\t\t\t}\n\n\t\t\tif (dstHeight > maxHeight) {\n\t\t\t\tdstWidth = Math.floor(dstWidth * (maxHeight / dstHeight));\n\t\t\t\tdstHeight = maxHeight;\n\t\t\t}\n\n\t\t\tconst srcImage = new Uint8Array(texture.getImage() as ArrayBuffer);\n\t\t\tconst srcPixels = await getPixels(srcImage, texture.getMimeType());\n\t\t\tconst dstPixels = ndarray(\n\t\t\t\tnew Uint8Array(dstWidth * dstHeight * 4), [dstWidth, dstHeight, 4]\n\t\t\t);\n\n\t\t\tlogger.debug(\n\t\t\t\t`${NAME}: Resizing \"${uri || name}\", ${srcPixels.shape} → ${dstPixels.shape}...`\n\t\t\t);\n\n\t\t\ttry {\n\t\t\t\toptions.filter === TextureResizeFilter.LANCZOS3\n\t\t\t\t\t? lanczos3(srcPixels, dstPixels)\n\t\t\t\t\t: lanczos2(srcPixels, dstPixels);\n\t\t\t} catch (e) {\n\t\t\t\tif (e instanceof Error) {\n\t\t\t\t\tlogger.warn(`${NAME}: Failed to resize \"${uri || name}\": \"${e.message}\".`);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tthrow e;\n\t\t\t}\n\n\t\t\ttexture.setImage((await savePixels(dstPixels, texture.getMimeType())).buffer);\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\n\t};\n\n}\n","import { Accessor, Document, Logger, Transform, TypedArray } from '@gltf-transform/core';\n\nconst NAME = 'unweld';\n\n/** Options for the {@link unweld} function. */\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface UnweldOptions {}\n\nconst UNWELD_DEFAULTS: UnweldOptions = {};\n\n/**\n * De-index {@link Primitive}s, disconnecting any shared vertices. This operation will generally\n * increase the number of vertices in a mesh, but may be helpful for some geometry operations or\n * for creating hard edges.\n *\n * No options are currently implemented for this function.\n */\nexport function unweld (_options: UnweldOptions = UNWELD_DEFAULTS): Transform {\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tconst options = {...UNWELD_DEFAULTS, ..._options} as Required<UnweldOptions>;\n\n\treturn (doc: Document): void => {\n\n\t\tconst logger = doc.getLogger();\n\t\tconst visited = new Map<Accessor, Map<Accessor, Accessor>>();\n\n\t\tfor (const mesh of doc.getRoot().listMeshes()) {\n\t\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t\tconst indices = prim.getIndices();\n\t\t\t\tif (!indices) continue;\n\n\t\t\t\t// Vertex attributes.\n\t\t\t\tfor (const srcAttribute of prim.listAttributes()) {\n\t\t\t\t\tprim.swap(\n\t\t\t\t\t\tsrcAttribute,\n\t\t\t\t\t\tunweldAttribute(srcAttribute, indices, logger, visited)\n\t\t\t\t\t);\n\n\t\t\t\t\t// Clean up.\n\t\t\t\t\tif (srcAttribute.listParents().length === 1) srcAttribute.dispose();\n\t\t\t\t}\n\n\t\t\t\t// Morph target vertex attributes.\n\t\t\t\tfor (const target of prim.listTargets()) {\n\t\t\t\t\tfor (const srcAttribute of target.listAttributes()) {\n\t\t\t\t\t\ttarget.swap(\n\t\t\t\t\t\t\tsrcAttribute,\n\t\t\t\t\t\t\tunweldAttribute(srcAttribute, indices, logger, visited)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// Clean up.\n\t\t\t\t\t\tif (srcAttribute.listParents().length === 1) srcAttribute.dispose();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Clean up.\n\t\t\t\tprim.setIndices(null);\n\t\t\t\tif (indices.listParents().length === 1) indices.dispose();\n\t\t\t}\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t};\n}\n\nfunction unweldAttribute(\n\t\tsrcAttribute: Accessor,\n\t\tindices: Accessor,\n\t\tlogger: Logger,\n\t\tvisited: Map<Accessor, Map<Accessor, Accessor>>): Accessor {\n\tif (visited.has(srcAttribute) && visited.get(srcAttribute)!.has(indices)) {\n\t\tlogger.debug(`${NAME}: Cache hit for reused attribute, \"${srcAttribute.getName()}\".`);\n\t\treturn visited.get(srcAttribute)!.get(indices)!;\n\t}\n\n\tconst dstAttribute = srcAttribute.clone();\n\tconst ArrayCtor = srcAttribute.getArray()!.constructor as\n\t\tnew (len: number) => TypedArray;\n\tdstAttribute.setArray(\n\t\tnew ArrayCtor(indices.getCount() * srcAttribute.getElementSize())\n\t);\n\n\tconst el: number[] = [];\n\tfor (let i = 0; i < indices.getCount(); i++) {\n\t\tdstAttribute.setElement(i, srcAttribute.getElement(indices.getScalar(i), el));\n\t}\n\n\tif (!visited.has(srcAttribute)) visited.set(srcAttribute, new Map());\n\tvisited.get(srcAttribute)!.set(indices, dstAttribute);\n\n\treturn dstAttribute;\n}\n","import { Accessor, Document, Primitive, PrimitiveTarget, Transform, TypedArray } from '@gltf-transform/core';\nimport { getGLPrimitiveCount } from './utils';\n\nconst NAME = 'weld';\n\n/** Options for the {@link weld} function. */\nexport interface WeldOptions {\n\t/** Per-attribute tolerance used when merging similar vertices. */\n\ttolerance?: number\n}\n\nconst WELD_DEFAULTS: Required<WeldOptions> = {tolerance: 1e-4};\n\n/**\n * Index {@link Primitive}s and (optionally) merge similar vertices.\n */\nexport function weld (_options: WeldOptions = WELD_DEFAULTS): Transform {\n\tconst options = {...WELD_DEFAULTS, ..._options} as Required<WeldOptions>;\n\n\treturn (doc: Document): void => {\n\t\tconst logger = doc.getLogger();\n\n\t\tfor (const mesh of doc.getRoot().listMeshes()) {\n\t\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t\tif (options.tolerance === 0) {\n\t\t\t\t\tweldOnly(doc, prim);\n\t\t\t\t} else {\n\t\t\t\t\tweldAndMerge(doc, prim, options);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t};\n}\n\n/**  In-place weld, adds indices without changing number of vertices. */\nfunction weldOnly (doc: Document, prim: Primitive): void {\n\tif (prim.getIndices()) return;\n\tconst attr = prim.listAttributes()[0];\n\tconst numVertices = attr.getCount();\n\tconst buffer = attr.getBuffer();\n\tconst indicesArray = numVertices <= 65534\n\t\t? new Uint16Array(getGLPrimitiveCount(prim) * 3)\n\t\t: new Uint32Array(getGLPrimitiveCount(prim) * 3);\n\tconst indices = doc.createAccessor()\n\t\t.setBuffer(buffer)\n\t\t.setType(Accessor.Type.SCALAR)\n\t\t.setArray(indicesArray);\n\tfor (let i = 0; i < indices.getCount(); i++) indices.setScalar(i, i);\n\tprim.setIndices(indices);\n}\n\n/**\n * Weld and merge, combining vertices that are similar on all vertex attributes. Morph target\n * attributes are not considered when scoring vertex similarity, but are retained when merging.\n */\nfunction weldAndMerge (doc: Document, prim: Primitive, options: Required<WeldOptions>): void {\n\tconst tolerance = Math.max(options.tolerance, Number.EPSILON);\n\tconst decimalShift = Math.log10(1 / tolerance);\n\tconst shiftFactor = Math.pow(10, decimalShift);\n\n\tconst hashToIndex: {[key: string]: number} = {};\n\tconst srcIndices = prim.getIndices();\n\tconst vertexCount = srcIndices\n\t\t? srcIndices.getCount()\n\t\t: prim.listAttributes()[0].getCount();\n\n\t// Prepare storage for new elements of each attribute.\n\tconst dstAttributes = new Map<Accessor, number[][]>();\n\tprim.listAttributes().forEach((attr) => dstAttributes.set(attr, []));\n\tprim.listTargets().forEach((target) => {\n\t\ttarget.listAttributes().forEach((attr) => dstAttributes.set(attr, []));\n\t});\n\n\tconst dstIndicesArray = [];\n\tlet nextIndex = 0;\n\n\t// For each vertex, compute a hash based on its tolerance and merge with any sufficiently\n\t// similar vertices.\n\tfor (let i = 0; i < vertexCount; i++) {\n\t\tconst index = srcIndices ? srcIndices.getScalar(i) : i;\n\n\t\tconst hashElements: number[] = [];\n\t\tconst el: number[] = [];\n\t\tfor (const attribute of prim.listAttributes()) {\n\t\t\tfor (let j = 0; j < attribute.getElementSize(); j++) {\n\t\t\t\thashElements.push(~ ~ (attribute.getElement(index, el)[j] * shiftFactor));\n\t\t\t}\n\t\t}\n\n\t\tconst hash = hashElements.join('|');\n\t\tif (hash in hashToIndex) {\n\t\t\tdstIndicesArray.push(hashToIndex[hash]);\n\t\t} else {\n\t\t\tfor (const attr of prim.listAttributes()) {\n\t\t\t\tdstAttributes.get(attr)!.push(attr.getElement(index, []));\n\t\t\t}\n\t\t\tfor (const target of prim.listTargets()) {\n\t\t\t\tfor (const attr of target.listAttributes()) {\n\t\t\t\t\tdstAttributes.get(attr)!.push(attr.getElement(index, []));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\thashToIndex[hash] = nextIndex;\n\t\t\tdstIndicesArray.push(nextIndex);\n\t\t\tnextIndex++;\n\t\t}\n\t}\n\n\tconst srcVertexCount = prim.listAttributes()[0].getCount();\n\tconst dstVertexCount = dstAttributes.get(prim.getAttribute('POSITION')!)!.length;\n\tdoc.getLogger().debug(`${NAME}: ${srcVertexCount} → ${dstVertexCount} vertices.`);\n\n\t// Update the primitive.\n\tfor (const srcAttr of prim.listAttributes()) {\n\t\tswapAttributes(prim, srcAttr, dstAttributes.get(srcAttr)!);\n\n\t\t// Clean up.\n\t\tif (srcAttr.listParents().length === 1) srcAttr.dispose();\n\t}\n\tfor (const target of prim.listTargets()) {\n\t\tfor (const srcAttr of target.listAttributes()) {\n\t\t\tswapAttributes(target, srcAttr, dstAttributes.get(srcAttr)!);\n\n\t\t\t// Clean up.\n\t\t\tif (srcAttr.listParents().length === 1) srcAttr.dispose();\n\t\t}\n\t}\n\tif (srcIndices) {\n\t\tconst dstIndicesTypedArray\n\t\t\t= createArrayOfType(srcIndices.getArray()!, dstIndicesArray.length);\n\t\tdstIndicesTypedArray.set(dstIndicesArray);\n\t\tprim.setIndices(srcIndices.clone().setArray(dstIndicesTypedArray));\n\n\t\t// Clean up.\n\t\tif (srcIndices.listParents().length === 1) srcIndices.dispose();\n\t} else {\n\t\tconst indicesArray = srcVertexCount <= 65534\n\t\t\t? new Uint16Array(dstIndicesArray)\n\t\t\t: new Uint32Array(dstIndicesArray);\n\t\tprim.setIndices(doc.createAccessor().setArray(indicesArray));\n\t}\n}\n\n/** Creates a new TypedArray of the same type as an original, with a new length. */\nfunction createArrayOfType<T extends TypedArray>(array: T, length: number): T {\n\tconst ArrayCtor = array.constructor as new (length: number) => T;\n\treturn new ArrayCtor(length);\n}\n\n/** Replaces an {@link Attribute}, creating a new one with the given elements. */\nfunction swapAttributes(\n\t\tparent: Primitive | PrimitiveTarget,\n\t\tsrcAttr: Accessor,\n\t\tdstAttrElements: number[][]): void {\n\tconst dstAttrArrayLength = dstAttrElements.length * srcAttr.getElementSize();\n\tconst dstAttrArray = createArrayOfType(srcAttr.getArray()!, dstAttrArrayLength);\n\tconst dstAttr = srcAttr.clone().setArray(dstAttrArray);\n\n\tfor (let i = 0; i < dstAttrElements.length; i++) {\n\t\tdstAttr.setElement(i, dstAttrElements[i]);\n\t}\n\n\tparent.swap(srcAttr, dstAttr);\n}\n","import { Accessor, Document, Primitive, Transform, vec3 } from '@gltf-transform/core';\n\nconst NAME = 'colorspace';\n\n/** Options for the {@link colorspace} function. */\nexport interface ColorspaceOptions {\n\t/** Must be `\"sRGB\"`. Required. */\n    inputEncoding: string;\n}\n\n/**\n * Vertex color colorspace correction. The glTF format requires vertex colors to be stored\n * as linear values, and this function provides a way to correct vertex colors that are\n * (incorrectly) sRGB.\n */\nexport function colorspace (options: ColorspaceOptions): Transform {\n\n\treturn (doc: Document): void => {\n\n\t\tconst logger = doc.getLogger();\n\n\t\tif (options.inputEncoding === 'linear') {\n\t\t\tlogger.info(`${NAME}: Vertex colors already linear. Skipping conversion.`);\n\t\t\treturn;\n\t\t}\n\n\t\tif (options.inputEncoding !== 'sRGB') {\n\t\t\tlogger.error(\n\t\t\t\t`${NAME}: Unknown input encoding \"${options.inputEncoding}\" – should be \"sRGB\" or `\n\t\t\t\t+ '\"linear\". Skipping conversion.'\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\tconst converted = new Set<Accessor>();\n\n\t\t// Source: THREE.Color\n\t\tfunction sRGBToLinear( c: number ): number {\n\n\t\t\treturn ( c < 0.04045 )\n\t\t\t\t? c * 0.0773993808\n\t\t\t\t: Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );\n\n\t\t}\n\n\t\tfunction updatePrimitive(primitive: Primitive): void {\n\t\t\tconst color = [0, 0, 0] as vec3;\n\t\t\tlet attribute: Accessor | null;\n\t\t\tfor (let i = 0; (attribute = primitive.getAttribute(`COLOR_${i}`)); i++) {\n\t\t\t\tif (converted.has(attribute)) continue;\n\n\t\t\t\tfor (let j = 0; j < attribute.getCount(); j++) {\n\t\t\t\t\tattribute.getElement(j, color);\n\t\t\t\t\tcolor[0] = sRGBToLinear(color[0]);\n\t\t\t\t\tcolor[1] = sRGBToLinear(color[1]);\n\t\t\t\t\tcolor[2] = sRGBToLinear(color[2]);\n\t\t\t\t\tattribute.setElement(j, color);\n\t\t\t\t}\n\n\t\t\t\tconverted.add(attribute);\n\t\t\t}\n\t\t}\n\n\t\tdoc.getRoot()\n\t\t\t.listMeshes()\n\t\t\t.forEach((mesh) => mesh.listPrimitives().forEach(updatePrimitive));\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\n\t};\n\n}\n"],"names":["NAME","CENTER_DEFAULTS","pivot","DEDUP_DEFAULTS","propertyTypes","PropertyType","ACCESSOR","MESH","TEXTURE","dedup","_options","options","Set","propertyType","includes","Error","doc","logger","getLogger","has","indicesAccessors","attributeAccessors","meshes","getRoot","listMeshes","detectDuplicates","accessors","duplicateAccessors","Map","i","length","a","aData","getArray","slice","buffer","j","b","getType","getComponentType","getCount","getNormalized","BufferUtils","equals","set","forEach","mesh","listPrimitives","primitive","listAttributes","accessor","add","indices","getIndices","duplicateIndices","Array","from","debug","size","duplicateAttributes","swap","get","keys","dispose","attribute","dedupAccessors","root","accessorIndices","listAccessors","index","numMeshes","uniqueMeshes","src","srcKeyItems","prim","primKeyItems","listSemantics","semantic","getAttribute","push","join","meshKey","targetMesh","listParents","parent","ROOT","dedupMeshes","textures","listTextures","duplicates","getImage","bData","getMimeType","aSize","getSize","bSize","entries","dst","property","Root","dedupImages","rewriteTexture","source","target","fn","srcImage","getPixels","Uint8Array","pixels","shape","savePixels","setImage","_savePixels","setMimeType","getGLPrimitiveCount","position","getMode","Primitive","Mode","POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","SetMap","_map","k","v","entry","this","listScenes","properties","map","scene","listChildren","sceneBounds","bounds","name","getName","rootName","bboxMin","toPrecision","min","bboxMax","max","instances","filter","glPrimitives","verts","semantics","meshIndices","meshAccessors","attr","arrayToType","listTargets","byteLength","modes","MeshPrimitiveModeLabels","mode","primitives","vertices","sort","attributes","listMaterials","material","extensions","listExtensions","slots","getGraph","getLinks","link","child","getChild","getParent","Texture","ExtensionProperty","alphaMode","getAlphaMode","doubleSided","getDoubleSided","texture","listParentLinks","resolution","ImageUtils","uri","getURI","mimeType","gpuSize","getMemSize","listAnimations","anim","minTime","Infinity","maxTime","listSamplers","sampler","input","getInput","Math","getMin","getMax","keyframes","output","getOutput","channels","listChannels","samplers","duration","round","toFixed","Number","array","constructor","replace","toLowerCase","INSTANCE_DEFAULTS","pruneUnusedNodes","nodes","node","unusedNodes","pop","getCamera","getMesh","getSkin","nodeParent","Node","createBatch","batchExtension","count","getBuffer","batchTranslation","createAccessor","setType","setArray","Float32Array","setBuffer","batchRotation","batchScale","createInstancedMesh","setAttribute","value","result","e","_isSettledPact","METALROUGH_DEFAULTS","PRUNE_DEFAULTS","NODE","SKIN","CAMERA","PRIMITIVE","PRIMITIVE_TARGET","ANIMATION","MATERIAL","BUFFER","prune","graph","disposed","listNodes","treeShake","listSkins","listCameras","indirectTreeShake","channel","getTargetNode","markDisposed","listBuffers","Object","str","t","info","prop","p","AnimationChannel","PARTITION_DEFAULTS","animations","createBufferURI","basename","existing","SIGNED_INT","Int8Array","Int16Array","Int32Array","TargetPath","WEIGHTS","TRS_CHANNELS","TRANSLATION","ROTATION","SCALE","QUANTIZE_DEFAULTS","pattern","quantizationVolume","quantizePosition","quantizeNormal","quantizeTexcoord","quantizeColor","quantizeWeight","quantizeGeneric","quantizePrimitive","nodeTransform","test","srcAttribute","getQuantizationSettings","bits","ctor","getComponentSize","dstAttribute","clone","scale","transform","invert","fromTransform","fromScaling","el","il","getElement","setElement","transformMat4","quantizeAttribute","vertexCount","weightsEl","vertexWeightsSum","leastWeight","leastIndex","leastAttribute","weights","attributeIndex","normalizeWeights","Uint16Array","getNodeTransform","volume","offset","transformMeshParents","transformMatrix","animChannels","isAnimated","some","getTargetPath","isParentNode","setSkin","transformSkin","targetNode","createNode","setMesh","addChild","setTargetNode","nodeMatrix","getMatrix","multiplyMat4","setMatrix","skin","inverseBindMatrices","getInverseBindMatrices","ibm","setInverseBindMatrices","dstArray","signBits","quantBits","storageBits","BYTES_PER_ELEMENT","pow","lo","hi","di","abs","sign","setNormalized","getMinNormalized","getMaxNormalized","startsWith","warn","getPositionQuantizationVolume","positions","relativePositions","bbox","flatBounds","relMin","relMax","elementSize","fill","tmpMin","tmpMax","fromRotationTranslationScale","RESAMPLE_DEFAULTS","tolerance","optimize","lastIndex","tmp","writeIndex","time","getScalar","timePrev","timeNext","timeMix","keep","getElementSize","valuePrev","valueNext","getInterpolation","setScalar","setInput","setOutput","REORDER_DEFAULTS","remapAttribute","remap","dstCount","srcCount","srcArray","SEQUENCE_DEFAULTS","fps","TANGENTS_DEFAULTS","overwrite","getNormalTexcoord","getMaterial","normalTextureInfo","getNormalTextureInfo","getTexCoord","filterPrimitive","meshName","_settle","pact","s","o","TextureResizeFilter","TEXTURE_RESIZE_DEFAULTS","LANCZOS3","UNWELD_DEFAULTS","unweldAttribute","visited","ArrayCtor","WELD_DEFAULTS","weldOnly","numVertices","indicesArray","Uint32Array","Accessor","Type","SCALAR","setIndices","weldAndMerge","EPSILON","decimalShift","log10","shiftFactor","hashToIndex","srcIndices","dstAttributes","dstIndicesArray","nextIndex","hashElements","hash","srcVertexCount","dstVertexCount","srcAttr","swapAttributes","dstIndicesTypedArray","createArrayOfType","dstAttrElements","dstAttrArrayLength","dstAttrArray","dstAttr","offsetNode","setTranslation","getTranslation","inputEncoding","converted","updatePrimitive","error","sRGBToLinear","c","color","scenes","materials","createExtension","MeshGPUInstancing","numBatches","numInstances","meshInstances","traverse","modifiedNodes","batch","batchNode","setExtension","needsTranslation","needsRotation","needsScale","r","getWorldTranslation","getWorldRotation","getWorldScale","MathUtils","eq","specGlossExtension","inputTextures","tex","extensionName","MaterialsPBRSpecularGlossiness","EXTENSION_NAME","listExtensionsUsed","ext","iorExtension","MaterialsIOR","specExtension","MaterialsSpecular","specGloss","getExtension","specular","createSpecular","setSpecularFactor","setSpecularColorFactor","getSpecularFactor","getSpecularGlossinessTexture","getBaseColorTexture","getMetallicRoughnessTexture","setBaseColorFactor","getDiffuseFactor","setMetallicFactor","setRoughnessFactor","createIOR","setIOR","diffuseTexture","getDiffuseTexture","setBaseColorTexture","getBaseColorTextureInfo","copy","getDiffuseTextureInfo","sgTexture","sgTextureInfo","getSpecularGlossinessTextureInfo","specularTexture","createTexture","setSpecularTexture","setSpecularColorTexture","getSpecularTextureInfo","getSpecularColorTextureInfo","glossinessFactor","getGlossinessFactor","metalRoughTexture","roughness","setMetallicRoughnessTexture","getMetallicRoughnessTextureInfo","existingURIs","meshIndex","isArray","createBuffer","setURI","primTarget","partitionMeshes","animIndex","partitionAnimations","MeshQuantization","setRequired","undefined","bboxes","expandBounds","encoder","ready","plan","indicesToAttributes","indicesToMode","attributesToPrimitives","preprocessPrimitives","dstIndices","reorderMesh","unique","accessorsVisited","accessorsCountPrev","didSkipMorphTargets","animation","morphTargetSamplers","getSampler","values","sequenceNodes","match","createAnimation","animBuffer","inputArray","outputArray","VEC3","createAnimationSampler","setInterpolation","AnimationSampler","Interpolation","STEP","createAnimationChannel","setTargetPath","setSampler","addSampler","addChannel","generateTangents","attributeIDs","tangentCache","modified","meshPrimitives","texcoordSemantic","normal","texcoord","positionID","uuid","normalID","texcoordID","prevTangent","attributeHash","tangent","tangentBuffer","tangentArray","maxWidth","maxHeight","srcWidth","srcHeight","dstWidth","dstHeight","floor","srcPixels","dstPixels","ndarray","lanczos3","lanczos2","message","_setImage"],"mappings":"2yCAGA,IAAMA,EAAO,SAQPC,EAA2C,CAACC,MAAO,UCAnDC,EAAyC,CAC9CC,cAAe,CAACC,eAAaC,SAAUD,eAAaE,KAAMF,eAAaG,UAiB3DC,EAAQ,SAAUC,YAAAA,IAAAA,EAAyBP,GAIvD,IAHA,MAAMQ,OAAcR,EAAmBO,GAEjCN,EAAgB,IAAIQ,IAAID,EAAQP,mBACXO,EAAQP,8BAAe,KAAvCS,UACV,IAAKV,EAAeC,cAAcU,SAASD,GAC1C,UAAUE,MAASf,6CAA4Ca,QAIjE,gBAAQG,GACP,IAAMC,EAASD,EAAIE,YAEfd,EAAce,IAAId,eAAaC,WASrC,SAAwBW,EAAgBD,GAEvC,IAAMI,EAAkC,IAAIR,IACtCS,EAAoC,IAAIT,IAExCU,EAASN,EAAIO,UAAUC,aAU7B,SAASC,EAAiBC,GAGzB,IAFA,IAAMC,EAA8C,IAAIC,IAE/CC,EAAI,EAAGA,EAAIH,EAAUI,OAAQD,IAAK,CAC1C,IAAME,EAAIL,EAAUG,GACdG,EAAQD,EAAEE,WAAYC,QAAQC,OAEpC,IAAIR,EAAmBR,IAAIY,GAE3B,IAAK,IAAIK,EAAI,EAAGA,EAAIV,EAAUI,OAAQM,IAAK,CAC1C,IAAMC,EAAIX,EAAUU,GAEhBL,IAAMM,IACNV,EAAmBR,IAAIkB,IAEvBN,EAAEO,YAAcD,EAAEC,WAClBP,EAAEQ,qBAAuBF,EAAEE,oBAC3BR,EAAES,aAAeH,EAAEG,YACnBT,EAAEU,kBAAoBJ,EAAEI,iBACxBC,cAAYC,OAAOX,EAAOK,EAAEJ,WAAYC,QAAQC,SACnDR,EAAmBiB,IAAIP,EAAGN,KAK7B,OAAOJ,EAlCRL,EAAOuB,QAAQ,SAACC,GACfA,EAAKC,iBAAiBF,QAAQ,SAACG,GAC9BA,EAAUC,iBAAiBJ,QAAQ,SAACK,UAAc7B,EAAmB8B,IAAID,KACzE,IAAME,EAAUJ,EAAUK,aACtBD,GAAShC,EAAiB+B,IAAIC,OAiCpC,IAAME,EAAmB7B,EAAiB8B,MAAMC,KAAKpC,IACrDH,EAAOwC,MACHzD,gBAAesD,EAAiBI,0BAAyBtC,EAAiBsC,kBAG9E,IAAMC,EAAsBlC,EAAiB8B,MAAMC,KAAKnC,IACxDJ,EAAOwC,MACHzD,gBAAe2D,EAAoBD,0BAAyBrC,EAAmBqC,KAChF,gBAIHpC,EAAOuB,QAAQ,SAACC,GACfA,EAAKC,iBAAiBF,QAAQ,SAACG,GAC9BA,EAAUC,iBAAiBJ,QAAQ,SAACK,GAC/BS,EAAoBxC,IAAI+B,IAC3BF,EAAUY,KAAKV,EAAUS,EAAoBE,IAAIX,MAGnD,IAAME,EAAUJ,EAAUK,aACtBD,GAAWE,EAAiBnC,IAAIiC,IACnCJ,EAAUY,KAAKR,EAASE,EAAiBO,IAAIT,QAIhDG,MAAMC,KAAKF,EAAiBQ,QAAQjB,QAAQ,SAACO,UAAYA,EAAQW,YACjER,MAAMC,KAAKG,EAAoBG,QAAQjB,QAAQ,SAACmB,UAAcA,EAAUD,YA9EzBE,CAAehD,EAAQD,GACjEZ,EAAce,IAAId,eAAaE,OAgFrC,SAAqBU,EAAgBD,GACpC,IAAMkD,EAAOlD,EAAIO,UAGX4C,EAAkB,IAAIvC,IAC5BsC,EAAKE,gBAAgBvB,QAAQ,SAACK,EAAUmB,GACvCF,EAAgBvB,IAAIM,EAAUmB,KAM/B,IAFA,MAAMC,EAAYJ,EAAK1C,aAAaM,OAC9ByC,EAAe,IAAI3C,iBAIxB,UAHU4C,UAEJC,EAAc,OACDD,EAAIzB,iCAAkB,CAExC,UAFU2B,UACJC,EAAe,OACED,EAAKE,gCAAiB,KAAlCC,UACJb,EAAYU,EAAKI,aAAaD,GACpCF,EAAaI,KAAKF,EAAW,IAAMV,EAAgBN,IAAIG,IAExD,IAAMZ,EAAUsB,EAAKrB,aACjBD,GACHuB,EAAaI,KAAK,WAAaZ,EAAgBN,IAAIT,IAEpDqB,EAAYM,KAAKJ,EAAaK,KAAK,MAKpC,IAAMC,EAAUR,EAAYO,KAAK,KACjC,GAAIT,EAAapD,IAAI8D,GAAU,CAC9B,IAAMC,EAAaX,EAAaV,IAAIoB,GACpCT,EAAIW,cAActC,QAAQ,SAACuC,GACtBA,EAAOvE,eAAiBR,eAAagF,MACxCD,EAAOxB,KAAKY,EAAKU,KAGnBV,EAAIT,eAEJQ,EAAa3B,IAAIqC,EAAST,QA5BVN,EAAK1C,iCAgCvBP,EAAOwC,MACHzD,iBAAesE,EAAYC,EAAab,2BAAyBY,cA7H1BgB,CAAYrE,EAAQD,GAC1DZ,EAAce,IAAId,eAAaG,UAgIrC,SAAqBS,EAAgBD,GAKpC,IAJA,IAAMkD,EAAOlD,EAAIO,UACXgE,EAAWrB,EAAKsB,eAChBC,EAAoC,IAAI7D,IAErCC,EAAI,EAAGA,EAAI0D,EAASzD,OAAQD,IAAK,CACzC,IAAME,EAAIwD,EAAS1D,GACbG,EAAQD,EAAE2D,WAEhB,IAAID,EAAWtE,IAAIY,GAEnB,IAAK,IAAIK,EAAI,EAAGA,EAAImD,EAASzD,OAAQM,IAAK,CACzC,IAAMC,EAAIkD,EAASnD,GACbuD,EAAQtD,EAAEqD,WAEhB,GAAI3D,IAAMM,IACNoD,EAAWtE,IAAIkB,IAGfN,EAAE6D,gBAAkBvD,EAAEuD,cAA1B,CAEA,IAAMC,EAAQ9D,EAAE+D,UACVC,EAAQ1D,EAAEyD,UACXD,GAAUE,GACXF,EAAM,KAAOE,EAAM,IACnBF,EAAM,KAAOE,EAAM,IAClB/D,GAAU2D,GACXjD,cAAYC,OAAOX,EAAO2D,IAC7BF,EAAW7C,IAAIP,EAAGN,KAKrBd,EAAOwC,MACHzD,gBAAeyF,EAAW/B,0BAAyBQ,EAAKsB,eAAe1D,qBAG3EyB,MAAMC,KAAKiC,EAAWO,WAAWnD,QAAQ,gBAAE2B,OAAKyB,OAC/CzB,EAAIW,cAActC,QAAQ,SAACqD,GACpBA,aAAoBC,QAAOD,EAAStC,KAAKY,EAAKyB,KAErDzB,EAAIT,YAzKyCqC,CAAYnF,EAAQD,GAEjEC,EAAOwC,MAASzD,sBCzCIqG,WACpBC,EACAC,EACAC,OAED,IAAKF,EAAQ,uBAAO,MAEpB,IAAMG,EAAWH,EAAOZ,WACxB,OAAKe,kBAEgBC,YAAU,IAAIC,WAAWF,GAAWH,EAAOV,8BAA1DgB,GAEN,IAAI,IAAI/E,EAAI,EAAGA,EAAI+E,EAAOC,MAAM,KAAMhF,EACrC,IAAI,IAAIO,EAAI,EAAGA,EAAIwE,EAAOC,MAAM,KAAMzE,EACrCoE,EAAGI,EAAQ/E,EAAGO,0BAIQ0E,aAAWF,EAAQ,+BAC3C,OAAOL,EAAOQ,SADGC,EAAwC7E,QACxB8E,YAAY,iCAXvB,MARvB,6CAsBgBC,EAAoBxC,GACnC,IAAMtB,EAAUsB,EAAKrB,aACf8D,EAAWzC,EAAKI,aAAa,YAGnC,OAAQJ,EAAK0C,WACZ,KAAKC,YAAUC,KAAKC,OACnB,OAAOJ,EAAS3E,WACjB,KAAK6E,YAAUC,KAAKE,MACnB,OAAOpE,EACJA,EAAQZ,WAAa,EACrB2E,EAAS3E,WAAa,EAC1B,KAAK6E,YAAUC,KAAKG,UACnB,OAAON,EAAS3E,WACjB,KAAK6E,YAAUC,KAAKI,WACnB,OAAOP,EAAS3E,WAAa,EAC9B,KAAK6E,YAAUC,KAAKK,UACnB,OAAOvE,EACJA,EAAQZ,WAAa,EACrB2E,EAAS3E,WAAa,EAC1B,KAAK6E,YAAUC,KAAKM,eACpB,KAAKP,YAAUC,KAAKO,aACnB,OAAOV,EAAS3E,WAAa,EAC9B,QACC,UAAUzB,MAAM,oBAAsB2D,EAAK0C,gBAIjCU,+BACJC,KAAO,IAAInG,iCAIZT,IAAA,SAAI6G,GACV,YAAYD,KAAK5G,IAAI6G,MAEf7E,IAAA,SAAI6E,EAAMC,GAChB,IAAIC,EAAQC,KAAKJ,KAAKlE,IAAImE,GAM1B,OALKE,IACJA,EAAQ,IAAItH,IACZuH,KAAKJ,KAAKnF,IAAIoF,EAAGE,IAElBA,EAAM/E,IAAI8E,WAGJpE,IAAA,SAAImE,GACV,YAAYD,KAAKlE,IAAImE,IAAM,IAAIpH,OAEzBkD,KAAA,WACN,YAAYiE,KAAKjE,4BAnBlB,WACC,YAAYiE,KAAKrE,mMC3CnB,SAAS0E,EAAYpH,GAWpB,MAAO,CAACqH,WAVOrH,EAAIO,UAAU6G,aAAaE,IAAI,SAACC,GAC9C,IAAMrE,EAAOqE,EAAMC,eAAe,GAC5BC,EAAcC,SAAOH,GAC3B,MAAO,CACNI,KAAMJ,EAAMK,UACZC,SAAU3E,EAAOA,EAAK0E,UAAY,GAClCE,QAASC,EAAYN,EAAYO,KACjCC,QAASF,EAAYN,EAAYS,SAOpC,SAAS1H,EAAYR,GAgDpB,MAAO,CAACqH,WA/C4BrH,EAAIO,UAAUC,aAAa8G,IAAI,SAACxF,GACnE,IAAMqG,EAAYrG,EAAKqC,cACrBiE,OAAO,SAAChE,SAAmC,SAAxBA,EAAOvE,eAC1BiB,OACEuH,EAAe,EACfC,EAAQ,EACNC,EAAY,IAAI3I,IAChB4I,EAAc,IAAI5I,IAClB6I,EAA+B,IAAI7I,IAEzCkC,EAAKC,iBAAiBF,QAAQ,SAAC6B,GAC9B,cAAuBA,EAAKE,gCAAiB,KAAlCC,UACJ6E,EAAOhF,EAAKI,aAAaD,GAC/B0E,EAAUpG,IAAI0B,EAAW,IAAM8E,EAAYD,EAAKzH,aAChDwH,EAActG,IAAIuG,GAEnB,cAAmBhF,EAAKkF,sCAClB3G,iBAAiBJ,QAAQ,SAAC6G,UAASD,EAActG,IAAIuG,KAE3D,IAAMtG,EAAUsB,EAAKrB,aACjBD,IACHoG,EAAYrG,IAAIwG,EAAYvG,EAAQnB,aACpCwH,EAActG,IAAIC,IAEnBkG,GAAS5E,EAAKzB,iBAAiB,GAAGT,WAClC6G,GAAgBnC,EAAoBxC,KAGrC,IAAIhB,EAAO,EACXH,MAAMC,KAAKiG,GAAe5G,QAAQ,SAACd,UAAO2B,GAAQ3B,EAAEE,WAAY4H,aAEhE,IAAMC,EAAQhH,EAAKC,iBACjBuF,IAAI,SAAC5D,UAASqF,EAAwBrF,EAAK0C,aAE7C,MAAO,CACNuB,KAAM7F,EAAK8F,UACXoB,KAAMzG,MAAMC,KAAK,IAAI5C,IAAIkJ,IACzBG,WAAYnH,EAAKC,iBAAiBjB,OAClCuH,aAAcA,EACda,SAAUZ,EACVlG,QAASG,MAAMC,KAAKgG,GAAaW,OACjCC,WAAY7G,MAAMC,KAAK+F,GAAWY,OAClChB,UAAWA,EACXzF,KAAMA,MAQT,SAAS2G,EAAerJ,GAiCvB,MAAO,CAACqH,WAhCmCrH,EAAIO,UAAU8I,gBAAgB/B,IAAI,SAACgC,GAC7E,IAAMnB,EAAYmB,EAASnF,cACzBiE,OAAO,SAAChE,SAAmC,SAAxBA,EAAOvE,eAC1BiB,OAGIyI,EAAa,IAAI3J,IAAuB0J,EAASE,kBACjDC,EAAQzJ,EAAI0J,WAAWC,WAC3BvB,OAAO,SAACwB,GACR,IAAMC,EAAQD,EAAKE,WACb1F,EAASwF,EAAKG,YACpB,OAAIF,aAAiBG,WAAW5F,IAAWkF,MAGvCO,aAAiBG,WAChB5F,aAAkB6F,qBAClBV,EAAWpJ,IAAIiE,MAKpBkD,IAAI,SAACsC,UAASA,EAAKhC,YAErB,MAAO,CACND,KAAM2B,EAAS1B,UACfO,UAAAA,EACA5D,SAAUkF,EACVS,UAAWZ,EAASa,eACpBC,YAAad,EAASe,qBAQzB,SAAS7F,EAAcxE,GAwBtB,MAAO,CAACqH,WAvBiCrH,EAAIO,UAAUiE,eAAe8C,IAAI,SAACgD,GAC1E,IAAMnC,EAAYmC,EAAQnG,cACxBiE,OAAO,SAAChE,SAAmC,SAAxBA,EAAOvE,eAC1BiB,OAEI2I,EAAQzJ,EAAI0J,WAAWa,gBAAgBD,GAC3ChD,IAAI,SAACsC,UAASA,EAAKhC,YACnBQ,OAAO,SAACT,SAAkB,YAATA,IAEb6C,EAAaC,aAAW3F,QAAQwF,EAAQ5F,WAAa4F,EAAQ1F,eAEnE,MAAO,CACN+C,KAAM2C,EAAQ1C,UACd8C,IAAKJ,EAAQK,SACblB,MAAOlH,MAAMC,KAAK,IAAI5C,IAAI6J,IAC1BtB,UAAAA,EACAyC,SAAUN,EAAQ1F,cAClB4F,WAAYA,EAAaA,EAAWxG,KAAK,KAAO,GAChDtB,KAAM4H,EAAQ5F,WAAYmE,WAC1BgC,QAASJ,aAAWK,WAAWR,EAAQ5F,WAAa4F,EAAQ1F,mBAQ/D,SAASmG,EAAgB/K,GAqCxB,MAAO,CAACqH,WApCqCrH,EAAIO,UAAUwK,iBAAiBzD,IAAI,SAAC0D,GAChF,IAAIC,EAAUC,SACVC,GAAWD,SACfF,EAAKI,eAAevJ,QAAQ,SAACwJ,GAC5B,IAAMC,EAAQD,EAAQE,WACjBD,IACLL,EAAUO,KAAKxD,IAAIiD,EAASK,EAAMG,OAAO,IAAI,IAC7CN,EAAUK,KAAKtD,IAAIiD,EAASG,EAAMI,OAAO,IAAI,OAG9C,IAAIhJ,EAAO,EACPiJ,EAAY,EACVjL,EAA2B,IAAId,IAcrC,OAbAoL,EAAKI,eAAevJ,QAAQ,SAACwJ,GAC5B,IAAMC,EAAQD,EAAQE,WAChBK,EAASP,EAAQQ,YAClBP,IACLK,GAAaL,EAAM9J,WACnBd,EAAUyB,IAAImJ,GACTM,GACLlL,EAAUyB,IAAIyJ,MAEfrJ,MAAMC,KAAK9B,GAAWmB,QAAQ,SAACK,GAC9BQ,GAAQR,EAASjB,WAAY4H,aAGvB,CACNlB,KAAMqD,EAAKpD,UACXkE,SAAUd,EAAKe,eAAejL,OAC9BkL,SAAUhB,EAAKI,eAAetK,OAC9BmL,SAAUT,KAAKU,MAA4B,KAArBf,EAAUF,IAAmB,IACnDU,UAAWA,EACXjJ,KAAMA,MAoET,IAAMqG,EAA0B,CAC/B,SACA,QACA,YACA,aACA,YACA,iBACA,gBAID,SAAShB,EAAYd,GACpB,IAAK,IAAIpG,EAAI,EAAGA,EAAIoG,EAAEnG,OAAQD,IACxBoG,EAAEpG,GAAcsL,UAASlF,EAAEpG,GAAKuL,OAAOnF,EAAEpG,GAAGsL,QAAQ,KAE1D,OAAOlF,EAGR,SAAS0B,EAAY0D,GACpB,OAAOA,EAAMC,YAAY3E,KAAK4E,QAAQ,QAAS,IAAIC,cCxQpD,IAAMxN,EAAO,WAKPyN,EAA+C,GA+FrD,SAASC,EAAiBC,EAAe1M,GAGxC,IAFA,IAAI2M,EACAC,EAAc,EACVD,EAAOD,EAAMG,OACpB,KAAIF,EAAKpF,eAAe1G,QACnB8L,EAAKG,aACLH,EAAKI,WACLJ,EAAKK,WACLL,EAAKpD,iBAAiB1I,QAJ3B,CAOA,IAAMoM,EAAaN,EAAK7C,YACpBmD,aAAsBC,QACzBR,EAAM5I,KAAKmJ,GAEZN,EAAK7J,UACL8J,IAGD5M,EAAOwC,MAASzD,eAAiB6N,oBAGlC,SAASO,EACPpN,EACAqN,EACAvL,EACAwL,GACD,IAAMnM,EAASW,EAAKC,iBAAiB,GAAG+B,aAAa,YAAayJ,YAE5DC,EAAmBxN,EAAIyN,iBAC3BC,QAAQ,QACRC,SAAS,IAAIC,aAAa,EAAIN,IAC9BO,UAAU1M,GACN2M,EAAgB9N,EAAIyN,iBACxBC,QAAQ,QACRC,SAAS,IAAIC,aAAa,EAAIN,IAC9BO,UAAU1M,GACN4M,EAAa/N,EAAIyN,iBACrBC,QAAQ,QACRC,SAAS,IAAIC,aAAa,EAAIN,IAC9BO,UAAU1M,GAEZ,OAAOkM,EAAeW,sBACpBC,aAAa,cAAeT,GAC5BS,aAAa,WAAYH,GACzBG,aAAa,QAASF,iRC7EuB,qMAlD/C,6FAe4BG,MAKtBC,aAGJC,+BAwCCC,kCA3EJ,IAAMC,EAAmD,GCDnDC,EAAyC,CAC9CnP,cAAe,CACdC,eAAamP,KACbnP,eAAaoP,KACbpP,eAAaE,KACbF,eAAaqP,OACbrP,eAAasP,UACbtP,eAAauP,iBACbvP,eAAawP,UACbxP,eAAayP,SACbzP,eAAaG,QACbH,eAAaC,SACbD,eAAa0P,SAqBFC,EAAQ,SAAUtP,YAAAA,IAAAA,EAAyB6O,GAEvD,IACMnP,OADcmP,EAAmB7O,GACTN,cAE9B,gBAAQY,GACP,IAAMC,EAASD,EAAIE,YACbgD,EAAOlD,EAAIO,UACX0O,EAAQjP,EAAI0J,WAEZwF,EAAmC,GAqBzC,GAhBI9P,EAAcU,SAAST,eAAamP,OAAOtL,EAAKiM,YAAYtN,QAAQuN,GACpEhQ,EAAcU,SAAST,eAAaoP,OAAOvL,EAAKmM,YAAYxN,QAAQuN,GACpEhQ,EAAcU,SAAST,eAAaE,OAAO2D,EAAK1C,aAAaqB,QAAQuN,GACrEhQ,EAAcU,SAAST,eAAaqP,SAASxL,EAAKoM,cAAczN,QAAQuN,GAExEhQ,EAAcU,SAAST,eAAasP,YACvCY,EAAkBN,EAAO5P,eAAasP,WAEnCvP,EAAcU,SAAST,eAAauP,mBACvCW,EAAkBN,EAAO5P,eAAauP,kBAOnCxP,EAAcU,SAAST,eAAawP,WACvC,cAAmB3L,EAAK6H,iCAAkB,CACzC,UADUC,cACYA,EAAKe,+BAAgB,KAAhCyD,UACLA,EAAQC,kBACZD,EAAQzM,UACR2M,EAAaF,IAGf,GAAKxE,EAAKe,eAAejL,OAKxBkK,EAAKI,eAAevJ,QAAQuN,OALI,CAChC,IAAMpD,EAAWhB,EAAKI,eACtBgE,EAAUpE,GACVgB,EAASnK,QAAQuN,IAiBpB,GAVIhQ,EAAcU,SAAST,eAAayP,WAAW5L,EAAKmG,gBAAgBxH,QAAQuN,GAC5EhQ,EAAcU,SAAST,eAAaG,UAAU0D,EAAKsB,eAAe3C,QAAQuN,GAC1EhQ,EAAcU,SAAST,eAAaC,WAAW4D,EAAKE,gBAAgBvB,QAAQuN,GAC5EhQ,EAAcU,SAAST,eAAa0P,SAAS7L,EAAKyM,cAAc9N,QAAQuN,GAOxEQ,OAAO9M,KAAKoM,GAAUpO,OAAQ,CACjC,IAAM+O,EAAMD,OAAO9M,KAAKoM,GAAU5H,IAAI,SAACwI,UAASA,OAAMZ,EAASY,SAAO9L,KAAK,MAC3E/D,EAAO8P,KAAQ/Q,2BAA0B6Q,QAEzC5P,EAAO8P,KAAQ/Q,sCAQhB,SAASoQ,EAAUY,GAGFA,EAAK7L,cACnBiE,OAAO,SAAC6H,WAAQA,aAAa9K,QAAQ8K,aAAaC,sBACvCpP,SACZkP,EAAKjN,UACL2M,EAAaM,IASf,SAAST,EAAkBN,EAAwBpP,GAClDoP,EAAMtF,WACJrC,IAAI,SAACsC,UAASA,EAAKG,cACnB3B,OAAO,SAAChE,UAAWA,EAAOvE,eAAiBA,IAC3CgC,QAAQuN,GAIX,SAASM,EAAaM,GACrBd,EAASc,EAAKnQ,cAAgBqP,EAASc,EAAKnQ,eAAiB,EAC7DqP,EAASc,EAAKnQ,gBA/BfI,EAAOwC,MAASzD,sBCxGZA,EAAO,YAOPmR,EAAkD,CACvDC,YAAY,EACZ9P,QAAQ,GAkGT,SAAS+P,EAAiBC,EAAkBC,GAG3C,IAFA,IAAI7F,EAAS4F,SACTzP,EAAI,EACD0P,EAASpQ,IAAIuK,IAAMA,EAAS4F,MAAYzP,WAC/C,OAAO6J,EC3GR,IAAM1L,EAAO,WAMPwR,EAAa,CAACC,UAAWC,WAAYC,cAEOT,mBAAiBU,WAA7BC,IAAAA,QAChCC,EAAe,GADbC,cAAaC,WAAUC,OAuBlBC,EAAgD,CAC5DC,QAAS,KACTC,mBAAoB,OACpBC,iBAAkB,GAClBC,eAAgB,GAChBC,iBAAkB,GAClBC,cAAe,EACfC,eAAgB,EAChBC,gBAAiB,IA6DlB,SAASC,EACP3R,EACA0D,EACAkO,EACAjS,GAGD,IAFA,MAAMM,EAASD,EAAIE,gBAEIwD,EAAKE,gCAAiB,KAAlCC,UACV,GAAKlE,EAAQwR,QAAQU,KAAKhO,GAA1B,CAEA,IAAMiO,EAAepO,EAAKI,aAAaD,KAClBkO,EAAwBlO,EAAUiO,EAAc7R,EAAQN,GAAtEqS,IAAAA,KAAMC,IAAAA,KAEb,GAAKA,EAAL,CACA,GAAID,EAAO,GAAKA,EAAO,GAAI,UAAUjS,MAASf,6BAC9C,KAAI8S,EAAaI,oBAAsBF,EAAO,GAA9C,CAEA,IAAMG,EAAeL,EAAaM,QAGlC,GAAiB,aAAbvO,EAAyB,CAC5B,IAAMwO,EAAQT,EAAcS,MACtBC,EAAkB,GAExB5O,aAAgB2C,YACbkM,SAAOD,EAAWE,GAAcZ,IAChCa,cAAYH,EAAW,CAAC,EAAID,EAAO,EAAIA,EAAO,EAAIA,IACrD,IAAK,IAAIxR,EAAI,EAAG6R,EAAW,CAAC,EAAG,EAAG,GAAIC,EAAKR,EAAa3Q,WAAYX,EAAI8R,EAAI9R,IAC3EsR,EAAaS,WAAW/R,EAAG6R,GAC3BP,EAAaU,WAAWhS,EAAGiS,gBAAcJ,EAAIA,EAAIJ,IAKnDS,EAAkBZ,EAAcF,EAAMD,GACtCtO,EAAKd,KAAKkP,EAAcK,MAQzB,GAJIzO,EAAKI,aAAa,cAoQvB,SAA0BJ,GAIzB,IAHA,IAAMsP,EAActP,EAAKI,aAAa,YAAatC,WAC7CyR,EAAsB,GAEnBpS,EAAI,EAAGA,EAAImS,EAAanS,IAAK,CAWrC,IAVA,IAAIqS,EAAmB,EAEnBC,EAAcjI,SACdkI,GAAc,EACdC,EAAkC,KAElCC,SACAC,EAAiB,EAGbD,EAAU5P,EAAKI,wBAAwByP,MAAsB,CACpED,EAAQV,WAAW/R,EAAGoS,GACtB,IAAK,IAAI7R,EAAI,EAAGA,EAAI6R,EAAUnS,OAAQM,IACrC8R,GAAoBD,EAAU7R,GAC1B6R,EAAU7R,GAAK,GAAK6R,EAAU7R,GAAK+R,IACtCE,EAAiBC,EACjBH,EAAcF,EAAU7R,GACxBgS,EAAahS,GAMZiS,GAAuC,IAArBH,IACrBG,EAAeT,WAAW/R,EAAGoS,GAC7BA,EAAUG,IAAe,EAAIF,EAC7BG,EAAeR,WAAWhS,EAAGoS,KAlS9BO,CAAiB9P,GAGdA,aAAgB2C,aACf3C,EAAKrB,cACLqB,EAAKzB,iBAAiBnB,QACtB4C,EAAKzB,iBAAiB,GAAIT,WAAa,MAAO,CAClD,IAAMY,EAAUsB,EAAKrB,aACrBD,EAAQuL,SAAS,IAAI8F,YAAYrR,EAAQnB,cAK3C,SAASyS,EAAiBC,OAClB3L,EAAY2L,EAAZ3L,IAAKE,EAAOyL,EAAPzL,IAINmK,EAAQ7G,KAAKtD,KACjBA,EAAI,GAAKF,EAAI,IAAM,GACnBE,EAAI,GAAKF,EAAI,IAAM,GACnBE,EAAI,GAAKF,EAAI,IAAM,GAUrB,MAAO,CAAC4L,OANa,CACpB5L,EAAI,IAAME,EAAI,GAAKF,EAAI,IAAM,EAC7BA,EAAI,IAAME,EAAI,GAAKF,EAAI,IAAM,EAC7BA,EAAI,IAAME,EAAI,GAAKF,EAAI,IAAM,GAGdqK,MAAAA,GAIjB,SAASwB,EACR7T,EACA8B,EACA8P,GAGA,IADA,MAAMkC,EAAkBtB,GAAcZ,OACjB9P,EAAKqC,8BAAe,KAA9BC,UACNA,aAAkB+I,mBACrB,IAAM4G,EAAe3P,EAAOD,cAC1BiE,OAAO,SAAC6H,UAAMA,aAAaC,qBACvB8D,EAAaD,EACjBE,KAAK,SAACzE,UAAYsB,EAAahR,SAAS0P,EAAQ0E,mBAC5CC,EAAe/P,EAAOoD,eAAe1G,OAAS,EAEpD,GAAIsD,EAAO6I,UAEV,OADA7I,EAAOgQ,QAAQC,EAAcjQ,EAAO6I,UAAY2E,eAIjD,IAAI0C,SACAH,GAAgBH,GACnBM,EAAatU,EAAIuU,WAAW,IAAIC,QAAQ1S,GACxCsC,EAAOqQ,SAASH,GAAYE,QAAQ,MACpCT,EACE3L,OAAO,SAACoH,UAAYA,EAAQ0E,kBAAoBrD,IAChDhP,QAAQ,SAAC2N,UAAYA,EAAQkF,cAAcJ,MAE7CA,EAAalQ,EAGd,IAAMuQ,EAAaL,EAAWM,YAC9BC,WAAaF,EAAYA,EAAYb,GACrCQ,EAAWQ,UAAUH,OAMxB,SAASN,EAAcU,EAAYnD,GAClCmD,EAAOA,EAAK3C,QAIZ,IAHA,IAAM0B,EAAkBtB,GAAcZ,GAChCoD,EAAsBD,EAAKE,yBAA0B7C,QACrD8C,EAAM,GACHrU,EAAI,EAAGyM,EAAQ0H,EAAoBxT,WAAYX,EAAIyM,EAAOzM,IAClEmU,EAAoBpC,WAAW/R,EAAGqU,GAClCL,WAAaK,EAAKA,EAAKpB,GACvBkB,EAAoBnC,WAAWhS,EAAGqU,GAEnC,OAAOH,EAAKI,uBAAuBH,GAWpC,SAASjC,EACP/P,EACAiP,EACAD,GAaD,IAVA,IAAMoD,EAAW,IAAInD,EAAKjP,EAAU/B,WAAYH,QAE1CuU,EAAW7E,EAAW1Q,SAASmS,GAAQ,EAAI,EAC3CqD,EAAYtD,EAAOqD,EACnBE,EAAuC,EAAzBtD,EAAKuD,kBAAwBH,EAE3ChD,EAAQ7G,KAAKiK,IAAI,EAAGH,GAAa,EACjCI,EAAKH,EAAcD,EACnBK,EAAK,EAAIL,EAAYC,EAElB1U,EAAI,EAAG+U,EAAK,EAAGlD,EAAe,GAAI7R,EAAImC,EAAUxB,WAAYX,IAAK,CACzEmC,EAAU4P,WAAW/R,EAAG6R,GACxB,IAAK,IAAItR,EAAI,EAAGA,EAAIsR,EAAG5R,OAAQM,IAAK,CAEnC,IAAI8M,EAAQ1C,KAAKU,MAAMV,KAAKqK,IAAInD,EAAGtR,IAAMiR,GAMzC+C,EAASQ,MAHT1H,EAASA,GAASwH,EAAOxH,GAASyH,GAGTnK,KAAKsK,KAAKpD,EAAGtR,KAIxC4B,EAAU2K,SAASyH,GAAUW,eAAc,GAG5C,SAAShE,EACPlO,EACAb,EACA/C,EACAN,GAED,IAGIqS,EACAC,EAJEjK,EAAMhF,EAAUgT,iBAAiB,IACjC9N,EAAMlF,EAAUiT,iBAAiB,IAKvC,GAAiB,aAAbpS,EAEHoO,GADAD,EAAOrS,EAAQ0R,mBACA,EAAIZ,UAAYC,mBACR,WAAb7M,GAAsC,YAAbA,EAEnCoO,GADAD,EAAOrS,EAAQ2R,iBACA,EAAIb,UAAYC,mBACrB7M,EAASqS,WAAW,UAE9BjE,GADAD,EAAOrS,EAAQ6R,gBACA,EAAI7L,WAAa8N,oBACtB5P,EAASqS,WAAW,aAAc,CAC5C,GAAIlO,EAAIiM,KAAK,SAAAhN,UAAKA,EAAI,KAAMiB,EAAI+L,KAAK,SAAAhN,UAAKA,EAAI,IAE7C,OADAhH,EAAOkW,KAAQnX,gBAAkB6E,2BAC1B,CAACmO,MAAO,GAGhBC,GADAD,EAAOrS,EAAQ4R,mBACA,EAAI5L,WAAa8N,oBACtB5P,EAASqS,WAAW,WAM9B,OAJAjE,GADAD,EAAOxG,KAAKtD,UAALsD,KAAYxI,EAAU0I,OAAO,MAAQ,IAAM,EAAI,KACvC,EAAI/F,WAAa8N,YAC5BzQ,EAAUkP,mBAAqBF,EAAO,GACzChP,EAAU2K,SAAS,IAAIsE,EAAKjP,EAAU/B,aAEhC,CAAC+Q,MAAO,MACLnO,EAASqS,WAAW,YAAa,CAC3C,GAAIlO,EAAIiM,KAAK,SAAAhN,UAAKA,EAAI,KAAMiB,EAAI+L,KAAK,SAAAhN,UAAKA,EAAI,IAE7C,OADAhH,EAAOkW,KAAQnX,gBAAkB6E,2BAC1B,CAACmO,MAAO,GAGhBC,GADAD,EAAOrS,EAAQ8R,iBACA,EAAI9L,WAAa8N,qBACtB5P,EAASqS,WAAW,KAU9B,UAAUnW,MAASf,6BAA+B6E,QATlD,GAAImE,EAAIiM,KAAK,SAAAhN,UAAKA,GAAK,KAAMiB,EAAI+L,KAAK,SAAAhN,UAAKA,EAAI,IAE9C,OADAhH,EAAOkW,KAAQnX,gBAAkB6E,4BAC1B,CAACmO,MAAO,GAEhBA,EAAOrS,EAAQ+R,gBACfO,EACIA,EADGjK,EAAIiM,KAAK,SAAAhN,UAAKA,EAAI,IACd+K,GAAQ,EAAIvB,UAAYC,WACxBsB,GAAQ,EAAIrM,WAAa8N,aAKrC,MAAO,CAACzB,KAAAA,EAAMC,KAAAA,GAGf,SAASmE,EAA8BtU,GAGtC,IAFA,MAAMuU,EAAwB,GACxBC,EAAgC,OACnBxU,EAAKC,iCAAkB,KAA/B2B,UACJV,EAAYU,EAAKI,aAAa,YAChCd,GAAWqT,EAAUtS,KAAKf,GAC9B,cAAqBU,EAAKkF,8BAAe,KAClC5F,UAAmBc,aAAa,YAClCd,GAAWsT,EAAkBvS,KAAKf,IAIxC,GAAyB,IAArBqT,EAAUvV,OACb,UAAUf,MAASf,qCAGpB,IAAMuX,EAAOC,GAAiBH,EAAW,GAMzC,GAAIC,EAAkBxV,OAAS,EAAG,OACE0V,GAAiBF,EAAmB,GAA3DG,IAALzO,IAAkB0O,IAALxO,IACpBF,MAAIuO,EAAKvO,IAAKuO,EAAKvO,IAAKA,MAAIyO,EAAQpE,QAAMoE,EAAQA,EAAQ,GAAI,CAAC,EAAG,EAAG,KACrEvO,MAAIqO,EAAKrO,IAAKqO,EAAKrO,IAAKA,MAAIwO,EAAQrE,QAAMqE,EAAQA,EAAQ,GAAI,CAAC,EAAG,EAAG,KAGtE,OAAOH,EAIR,SAASC,GAA0B9V,EAAuBiW,GAOzD,IANA,MAAM3O,EAAgB,IAAIzF,MAAMoU,GAAaC,KAAK1L,UAC5ChD,EAAgB,IAAI3F,MAAMoU,GAAaC,MAAM1L,UAE7C2L,EAAmB,GACnBC,EAAmB,OAEFpW,kBAAW,KAAvBwB,UACVA,EAAS8T,iBAAiBa,GAC1B3U,EAAS+T,iBAAiBa,GAC1B,IAAK,IAAIjW,EAAI,EAAGA,EAAI8V,EAAa9V,IAChCmH,EAAInH,GAAK2K,KAAKxD,IAAIA,EAAInH,GAAIgW,EAAOhW,IACjCqH,EAAIrH,GAAK2K,KAAKtD,IAAIA,EAAIrH,GAAIiW,EAAOjW,IAInC,MAAO,CAACmH,IAAAA,EAAKE,IAAAA,GAiBd,SAASsK,GAAcF,GACtB,OAAOyE,+BACN,GACA,CAAC,EAAG,EAAG,EAAG,GACVzE,EAAUsB,OACV,CAACtB,EAAUD,MAAOC,EAAUD,MAAOC,EAAUD,QChZ/C,IAIM2E,GAAgD,CAACC,UAAW,MAgElE,SAASC,GAAU7L,EAA2B1L,GAW7C,IAVA,IAuEsCmQ,EAvEhCxE,EAAQD,EAAQE,WAAY6G,QAC5BxG,EAASP,EAAQQ,YAAauG,QAE9B6E,EAAYtX,EAAQsX,UAEpBE,EAAY7L,EAAM9J,WAAa,EAC/B4V,EAAgB,GAElBC,EAAa,EAERxW,EAAI,EAAGA,EAAIsW,IAActW,EAAG,CACpC,IAAMyW,EAAOhM,EAAMiM,UAAU1W,GACvB2W,EAAWlM,EAAMiM,UAAU1W,EAAI,GAC/B4W,EAAWnM,EAAMiM,UAAU1W,EAAI,GAC/B6W,GAAWJ,EAAOE,IAAaC,EAAWD,GAE5CG,GAAO,EAGX,GAAIL,IAASG,IAAmB,IAAN5W,GAAWyW,IAAShM,EAAMiM,UAAU,IAC7D,IAAK,IAAInW,EAAI,EAAGA,EAAIwK,EAAOgM,iBAAkBxW,IAAK,CACjD,IAAM8M,EAAQtC,EAAOgH,WAAW/R,EAAGuW,GAAKhW,GAClCyW,EAAYjM,EAAOgH,WAAW/R,EAAI,EAAGuW,GAAKhW,GAC1C0W,EAAYlM,EAAOgH,WAAW/R,EAAI,EAAGuW,GAAKhW,GAEhD,GAAmC,WAA/BiK,EAAQ0M,oBAEX,GAAIvM,KAAKqK,IAAI3H,GAAa2J,GA6Cd,GADsB/H,EA5Cc4H,IAAXI,EA6CXhI,IA7CkCmH,EAAW,CACtEU,GAAO,EACP,eAEwC,SAA/BtM,EAAQ0M,qBAEd7J,IAAU2J,GAAa3J,IAAU4J,GAAW,CAC/CH,GAAO,EACP,OAOAA,IACC9W,IAAMwW,IACT/L,EAAM0M,UAAUX,EAAY/L,EAAMiM,UAAU1W,IAC5C+K,EAAOiH,WAAWwE,EAAYzL,EAAOgH,WAAW/R,EAAGuW,KAEpDC,KAMEF,EAAY,IACf7L,EAAM0M,UAAUX,EAAY/L,EAAMiM,UAAUJ,IAC5CvL,EAAOiH,WAAWwE,EAAYzL,EAAOgH,WAAWuE,EAAWC,IAC3DC,KAIGA,IAAe/L,EAAM9J,YACxB8J,EAAMqC,SAASrC,EAAMrK,WAAYC,MAAM,EAAGmW,IAC1CzL,EAAO+B,SAAS/B,EAAO3K,WAAYC,MAAM,EAAGmW,EAAazL,EAAOgM,mBAChEvM,EAAQ4M,SAAS3M,GACjBD,EAAQ6M,UAAUtM,KAElBN,EAAMvI,UACN6I,EAAO7I,WCrIT,IAaMoV,GAA8D,CACnE5S,OAAQ,QAiFT,SAAS6S,GAAepV,EAAqBqV,EAAoBC,GAMhE,IALA,IAAM3B,EAAc3T,EAAU4U,iBACxBW,EAAWvV,EAAUxB,WACrBgX,EAAWxV,EAAU/B,WACrBmU,EAAWoD,EAAStX,MAAM,EAAGoX,EAAW3B,GAErC9V,EAAI,EAAGA,EAAI0X,EAAU1X,IAC7B,IAAK,IAAIO,EAAI,EAAGA,EAAIuV,EAAavV,IAChCgU,EAASiD,EAAMxX,GAAK8V,EAAcvV,GAAKoX,EAAS3X,EAAI8V,EAAcvV,GAIpE4B,EAAU2K,SAASyH,GA+BpB,SAASnT,GAAeyB,GAGvB,IAFA,MAAMhD,EAAwB,OAENgD,EAAKzB,iCAC5BvB,EAAUqD,cAEX,cAAqBL,EAAKkF,8BACzB,sBAA+B3G,iCAC9BvB,EAAUqD,cAIZ,OAAOxB,MAAMC,KAAK,IAAI5C,IAAIc,ICzJ3B,IAaM+X,GAA+C,CACpD9Q,KAAM,GACN+Q,IAAK,GACLvH,QAAS,KACThI,MAAM,GCjBDnK,GAAO,WAeP2Z,GAAyE,CAC9EC,WAAW,GAwGZ,SAASC,GAAkBnV,GAC1B,IAAM4F,EAAW5F,EAAKoV,cACtB,IAAKxP,EAAU,MAAO,aAEtB,IAAMyP,EAAoBzP,EAAS0P,uBACnC,IAAKD,EAAmB,MAAO,aAE/B,IACMlV,cADWkV,EAAkBE,cAEnC,OAAIvV,EAAKI,aAAaD,GAAkBA,EAEjC,aAGR,SAASqV,GACPxV,EACAzD,EACAkZ,EACAtY,EACA+X,GAED,OAAIlV,EAAK0C,YAAcC,YAAUC,KAAKK,WAChCjD,EAAKI,aAAa,aAClBJ,EAAKI,aAAa,WAClBJ,EAAKI,aAAa,cAQpBJ,EAAKI,aAAa,aAAe8U,GACpC3Y,EAAOwC,MACHzD,2BAA4B6B,eAAcsY,4BAK3CzV,EAAKrB,eAERpC,EAAOkW,KACHnX,2BAA4B6B,eAAcsY,EAA1Cna,wCAjBJiB,EAAOwC,MACHzD,2BAA4B6B,eAAcsY,EAA1Cna,kNCtFCoa,GAAQC,0CAGXC,qCAEG,gEAaiBD,aAA2B,+BAWvCE,kBA1FuB,8GAwBlC,kCAIYpL,OAEZ,+CAOE,yBAIyB,iBAIrBA,eAEK,EAAGD,6BA/CoB,oDAqBvBsL,GAjBNxa,GAAO,iBAiBDwa,GAAAA,8BAAAA,qDAIXA,uBAGYC,IAAAA,GAAgD,CAC5D/W,KAAM,CAAC,KAAM,MACb0F,OAAQoR,4BAAoBE,SAC5BvI,QAAS,MCxBJwI,GAAiC,GAyDvC,SAASC,GACP9H,EACA1P,EACAnC,EACA4Z,GACD,GAAIA,EAAQ1Z,IAAI2R,IAAiB+H,EAAQhX,IAAIiP,GAAe3R,IAAIiC,GAE/D,OADAnC,EAAOwC,MAASzD,4CAA0C8S,EAAalK,gBAChEiS,EAAQhX,IAAIiP,GAAejP,IAAIT,GAGvC,IAAM+P,EAAeL,EAAaM,QAC5B0H,EAAYhI,EAAa7Q,WAAYqL,YAE3C6F,EAAaxE,SACZ,IAAImM,EAAU1X,EAAQZ,WAAasQ,EAAa8F,mBAIjD,IADA,IAAMlF,EAAe,GACZ7R,EAAI,EAAGA,EAAIuB,EAAQZ,WAAYX,IACvCsR,EAAaU,WAAWhS,EAAGiR,EAAac,WAAWxQ,EAAQmV,UAAU1W,GAAI6R,IAM1E,OAHKmH,EAAQ1Z,IAAI2R,IAAe+H,EAAQjY,IAAIkQ,EAAc,IAAIlR,KAC9DiZ,EAAQhX,IAAIiP,GAAelQ,IAAIQ,EAAS+P,GAEjCA,ECvFR,IAQM4H,GAAuC,CAAC9C,UAAW,MA0BzD,SAAS+C,GAAUha,EAAe0D,GACjC,IAAIA,EAAKrB,aAAT,CAWA,IAVA,IAAMqG,EAAOhF,EAAKzB,iBAAiB,GAC7BgY,EAAcvR,EAAKlH,WACnBL,EAASuH,EAAK6E,YACd2M,EAAeD,GAAe,MACjC,IAAIxG,YAAwC,EAA5BvN,EAAoBxC,IACpC,IAAIyW,YAAwC,EAA5BjU,EAAoBxC,IACjCtB,EAAUpC,EAAIyN,iBAClBI,UAAU1M,GACVuM,QAAQ0M,WAASC,KAAKC,QACtB3M,SAASuM,GACFrZ,EAAI,EAAGA,EAAIuB,EAAQZ,WAAYX,IAAKuB,EAAQ4V,UAAUnX,EAAGA,GAClE6C,EAAK6W,WAAWnY,IAOjB,SAASoY,GAAcxa,EAAe0D,EAAiB/D,GACtD,IAAMsX,EAAYzL,KAAKtD,IAAIvI,EAAQsX,UAAW7K,OAAOqO,SAC/CC,EAAelP,KAAKmP,MAAM,EAAI1D,GAC9B2D,EAAcpP,KAAKiK,IAAI,GAAIiF,GAE3BG,EAAuC,GACvCC,EAAapX,EAAKrB,aAClB2Q,EAAc8H,EACjBA,EAAWtZ,WACXkC,EAAKzB,iBAAiB,GAAGT,WAGtBuZ,EAAgB,IAAIna,IAC1B8C,EAAKzB,iBAAiBJ,QAAQ,SAAC6G,UAASqS,EAAcnZ,IAAI8G,EAAM,MAChEhF,EAAKkF,cAAc/G,QAAQ,SAAC0D,GAC3BA,EAAOtD,iBAAiBJ,QAAQ,SAAC6G,UAASqS,EAAcnZ,IAAI8G,EAAM,QAQnE,IALA,IAAMsS,EAAkB,GACpBC,EAAY,EAIPpa,EAAI,EAAGA,EAAImS,EAAanS,IAAK,CAKrC,IAJA,MAAMwC,EAAQyX,EAAaA,EAAWvD,UAAU1W,GAAKA,EAE/Cqa,EAAyB,GACzBxI,EAAe,OACGhP,EAAKzB,iCAC5B,QADUe,UACD5B,EAAI,EAAGA,EAAI4B,EAAU4U,iBAAkBxW,IAC/C8Z,EAAanX,QAAUf,EAAU4P,WAAWvP,EAAOqP,GAAItR,GAAKwZ,IAI9D,IAAMO,EAAOD,EAAalX,KAAK,KAC/B,GAAImX,KAAQN,EACXG,EAAgBjX,KAAK8W,EAAYM,QAC3B,CACN,cAAmBzX,EAAKzB,iCAAkB,KAA/ByG,UACVqS,EAAclY,IAAI6F,GAAO3E,KAAK2E,EAAKkK,WAAWvP,EAAO,KAEtD,cAAqBK,EAAKkF,8BACzB,sBAA0B3G,iCAAkB,KAAjCyG,UACVqS,EAAclY,IAAI6F,GAAO3E,KAAK2E,EAAKkK,WAAWvP,EAAO,KAIvDwX,EAAYM,GAAQF,EACpBD,EAAgBjX,KAAKkX,GACrBA,KAIF,IAAMG,EAAiB1X,EAAKzB,iBAAiB,GAAGT,WAC1C6Z,EAAiBN,EAAclY,IAAIa,EAAKI,aAAa,aAAehD,OAC1Ed,EAAIE,YAAYuC,MAASzD,SAASoc,QAAoBC,gBAGtD,cAAsB3X,EAAKzB,iCAAkB,KAAlCqZ,UACVC,GAAe7X,EAAM4X,EAASP,EAAclY,IAAIyY,IAGX,IAAjCA,EAAQnX,cAAcrD,QAAcwa,EAAQvY,UAEjD,cAAqBW,EAAKkF,8BACzB,UADUrD,cACYA,EAAOtD,iCAAkB,KAApCqZ,UACVC,GAAehW,EAAQ+V,EAASP,EAAclY,IAAIyY,IAGb,IAAjCA,EAAQnX,cAAcrD,QAAcwa,EAAQvY,UAGlD,GAAI+X,EAAY,CACf,IAAMU,EACHC,GAAkBX,EAAW7Z,WAAa+Z,EAAgBla,QAC7D0a,EAAqB5Z,IAAIoZ,GACzBtX,EAAK6W,WAAWO,EAAW1I,QAAQzE,SAAS6N,IAGJ,IAApCV,EAAW3W,cAAcrD,QAAcga,EAAW/X,cAChD,CACN,IAAMmX,EAAekB,GAAkB,MACpC,IAAI3H,YAAYuH,GAChB,IAAIb,YAAYa,GACnBtX,EAAK6W,WAAWva,EAAIyN,iBAAiBE,SAASuM,KAKhD,SAASuB,GAAwCpP,EAAUvL,GAE1D,WAAWgZ,EADOzN,EAAMC,aACHxL,GAItB,SAASya,GACPnX,EACAkX,EACAI,GAKD,IAJA,IAAMC,EAAqBD,EAAgB5a,OAASwa,EAAQ1D,iBACtDgE,EAAeH,GAAkBH,EAAQra,WAAa0a,GACtDE,EAAUP,EAAQlJ,QAAQzE,SAASiO,GAEhC/a,EAAI,EAAGA,EAAI6a,EAAgB5a,OAAQD,IAC3Cgb,EAAQhJ,WAAWhS,EAAG6a,EAAgB7a,IAGvCuD,EAAOxB,KAAK0Y,EAASO,kLf7IEnc,YAAAA,IAAAA,EAA0BT,GACjD,IAAMU,OAAcV,EAAoBS,GAExC,gBAAQM,GACP,IAAMC,EAASD,EAAIE,YACbgD,EAAOlD,EAAIO,UACXyT,EAAa9Q,EAAK6H,iBAAiBjK,OAAS,GAAKoC,EAAKmM,YAAYvO,OAAS,EAEjFd,EAAIO,UAAU6G,aAAavF,QAAQ,SAAC0F,EAAOlE,GAG1C,IAAInE,EACJ,GAHAe,EAAOwC,MAASzD,cAAeqE,EAAQ,SAAOH,EAAKkE,aAAatG,YAGnC,iBAAlBnB,EAAQT,MAAoB,CACtC,IAAMqX,EAAO7O,SAAOH,GACpBrI,EAAQ,EACNqX,EAAKrO,IAAI,GAAKqO,EAAKvO,IAAI,IAAM,EAAIuO,EAAKvO,IAAI,IAC1CuO,EAAKrO,IAAI,GAAKqO,EAAKvO,IAAI,IAAM,EAAIuO,EAAKvO,IAAI,IAC1CuO,EAAKrO,IAAI,GAAKqO,EAAKvO,IAAI,IAAM,EAAIuO,EAAKvO,IAAI,IAEtB,UAAlBrI,EAAQT,QAAmBA,EAAM,GAAKqX,EAAKrO,IAAI,IAC7B,UAAlBvI,EAAQT,QAAmBA,EAAM,GAAKqX,EAAKvO,IAAI,SAEnD9I,EAAQS,EAAQT,MAGjBe,EAAOwC,MAASzD,cAAgBE,EAAM8E,KAAK,YAE3C,IAAM4P,EAAe,EAAE,EAAI1U,EAAM,IAAK,EAAIA,EAAM,IAAK,EAAIA,EAAM,IAE/D,GAAI8U,EAAY,CACf/T,EAAOwC,MAASzD,gEAChB,IAAM8c,EAAa9b,EAAIuU,WAAW,SAASwH,eAAenI,GAC1DrM,EAAMC,eAAe3F,QAAQ,SAACgI,UAAUiS,EAAWrH,SAAS5K,KAC5DtC,EAAMkN,SAASqH,QAEf7b,EAAOwC,MAASzD,oDAChBuI,EAAMC,eAAe3F,QAAQ,SAACgI,GAC7B,IAAMiG,EAAIjG,EAAMmS,iBAChBnS,EAAMkS,eAAe,CACpBjM,EAAE,GAAK8D,EAAO,GACd9D,EAAE,GAAK8D,EAAO,GACd9D,EAAE,GAAK8D,EAAO,SAMlB3T,EAAOwC,MAASzD,+CgBvDUW,GAE3B,gBAAQK,GAEP,IAAMC,EAASD,EAAIE,YAEnB,GAA8B,WAA1BP,EAAQsc,cAKZ,GAA8B,SAA1Btc,EAAQsc,cAAZ,CAQA,IAAMC,EAAY,IAAItc,IA6BtBI,EAAIO,UACFC,aACAqB,QAAQ,SAACC,UAASA,EAAKC,iBAAiBF,QAAQsa,KAElDlc,EAAOwC,MAASzD,8BAxCfiB,EAAOmc,MACHpd,uCAAiCW,EAAQsc,cAAzCjd,+DANJiB,EAAO8P,KAAQ/Q,kEAehB,SAASqd,EAAcC,GAEtB,OAASA,EAAI,OACN,YAAJA,EACA9Q,KAAKiK,IAAS,YAAJ6G,EAAmB,YAAc,KAI/C,SAASH,EAAgBna,GAGxB,IAFA,IACIgB,EADEuZ,EAAQ,CAAC,EAAG,EAAG,GAEZ1b,EAAI,EAAImC,EAAYhB,EAAU8B,sBAAsBjD,GAAOA,IACnE,IAAIqb,EAAU/b,IAAI6C,GAAlB,CAEA,IAAK,IAAI5B,EAAI,EAAGA,EAAI4B,EAAUxB,WAAYJ,IACzC4B,EAAU4P,WAAWxR,EAAGmb,GACxBA,EAAM,GAAKF,EAAaE,EAAM,IAC9BA,EAAM,GAAKF,EAAaE,EAAM,IAC9BA,EAAM,GAAKF,EAAaE,EAAM,IAC9BvZ,EAAU6P,WAAWzR,EAAGmb,GAGzBL,EAAU/Z,IAAIa,gDbvDOhD,GACxB,MAAO,CACNwc,OAAQpV,EAAWpH,GACnBM,OAAQE,EAAWR,GACnByc,UAAWpT,EAAcrJ,GACzBuE,SAAUC,EAAaxE,GACvBoQ,WAAYrF,EAAe/K,+BCIHN,GAIzB,gBAJyBA,IAAAA,EAA4B+M,QAEjCA,EAAsB/M,YAElCM,GACP,IAAMC,EAASD,EAAIE,YACbgD,EAAOlD,EAAIO,UACX8M,EAAiBrN,EAAI0c,gBAAgBC,qBAE3C,GAAIzZ,EAAK6H,iBAAiBjK,OACzB,UAAUf,MAASf,kEAMpB,IAHA,MAAI4d,EAAa,EACbC,EAAe,mBAERtV,UAEJuV,EAAgB,IAAIlc,IAC1B2G,EAAMwV,SAAS,SAACnQ,GACf,IAAM9K,EAAO8K,EAAKI,UACblL,GACLgb,EAAclb,IAAIE,GAAOgb,EAAcja,IAAIf,IAAS,IAAIlC,KAAauC,IAAIyK,MAK1E,IADA,IAAMoQ,EAAgB,SACHza,MAAMC,KAAKsa,EAAcha,uBAAS,CAAhD,IAAMhB,OACJ6K,EAAQpK,MAAMC,KAAKsa,EAAcja,IAAIf,IAC3C,KAAI6K,EAAM7L,OAAS,GACf6L,EAAMsH,KAAK,SAACrH,UAASA,EAAKK,aAA9B,CAEA,IAAMgQ,EAAQ7P,EAAYpN,EAAKqN,EAAgBvL,EAAM6K,EAAM7L,QACrD0M,EAAmByP,EAAMnZ,aAAa,eACtCgK,EAAgBmP,EAAMnZ,aAAa,YACnCiK,EAAakP,EAAMnZ,aAAa,SAEhCoZ,EAAYld,EAAIuU,aACpBC,QAAQ1S,GACRqb,aAAa,0BAA2BF,GAC1C1V,EAAMkN,SAASyI,GAOf,IALA,IAAIE,GAAmB,EACnBC,GAAgB,EAChBC,GAAa,EAGRzc,EAAI,EAAGA,EAAI8L,EAAM7L,OAAQD,IAAK,CACtC,IAAIiP,EAASyN,EAASjE,EAChB1M,EAAOD,EAAM9L,GAEnB2M,EAAiBqF,WAAWhS,EAAGiP,EAAIlD,EAAK4Q,uBACxC1P,EAAc+E,WAAWhS,EAAG0c,EAAI3Q,EAAK6Q,oBACrC1P,EAAW8E,WAAWhS,EAAGyY,EAAI1M,EAAK8Q,iBAE7BC,YAAUC,GAAG9N,EAAG,CAAC,EAAG,EAAG,MAAKsN,GAAmB,GAC/CO,YAAUC,GAAGL,EAAG,CAAC,EAAG,EAAG,EAAG,MAAKF,GAAgB,GAC/CM,YAAUC,GAAGtE,EAAG,CAAC,EAAG,EAAG,MAAKgE,GAAa,GAG9C1Q,EAAK4H,QAAQ,MACbwI,EAAcjZ,KAAK6I,GAGfwQ,GAAkB5P,EAAiBzK,UACnCsa,GAAevP,EAAc/K,UAC7Bua,GAAYvP,EAAWhL,UAE5B2J,EAAiBsQ,EAAe/c,GAEhC2c,IACAC,GAAgBlQ,EAAM7L,cAvDJoC,EAAKkE,iCA2DrBwV,EAAa,EAChB3c,EAAO8P,KACH/Q,eAAiB4d,oBAA4BC,wBAGjD5c,EAAO8P,KAAQ/Q,wDACfqO,EAAetK,WAGhB9C,EAAOwC,MAASzD,+CC/EUU,GAI3B,gBAJ2BA,IAAAA,EAA8B4O,QAErCA,EAAwB5O,YAE9BM,wBAyFb6d,EAAmB9a,UAGnB,cAAkB+a,kBAAe,KAAtBC,UACNA,GAAoC,IAA7BA,EAAI5Z,cAAcrD,QAAcid,EAAIhb,UAGhD9C,EAAOwC,MAASzD,0BA9FViB,EAASD,EAAIE,YAEb8d,EAAgBC,iCAA+BC,eAErD,IADuBle,EAAIO,UAAU4d,qBAAqB7W,IAAI,SAAC8W,UAAQA,EAAIJ,gBACvDle,SAASke,GAE5B,OADA/d,EAAOkW,KAAQnX,yBAAmBgf,qDAInC,IAAMK,EAAere,EAAI0c,gBAAgB4B,gBACnCC,EAAgBve,EAAI0c,gBAAgB8B,qBACpCX,EAAqB7d,EAAI0c,gBAAgBuB,kCAGzCH,EAAgB,IAAIle,ovBAEHI,EAAIO,UAAU8I,yBAA1BC,gBAmEVA,EAAS6T,aAAa,sCAAuC,MAlE7D,IAAMsB,EAAYnV,EAASoV,aAAa,uCAExC,GAAKD,EAAL,CAGA,IAAME,EAAWJ,EAAcK,iBAC7BC,kBAAkB,GAClBC,uBAAuBL,EAAUM,qBAGnCjB,EAAc3b,IAAIsc,EAAUO,gCAC5BlB,EAAc3b,IAAImH,EAAS2V,uBAC3BnB,EAAc3b,IAAImH,EAAS4V,+BAO3B5V,EACE6V,mBAAmBV,EAAUW,oBAC7BC,kBAAkB,GAClBC,mBAAmB,GACnBnC,aAAa,oBAAqBkB,EAAakB,YAAYC,OAAO,MAClErC,aAAa,yBAA0BwB,GAGzC,IAAMc,EAAiBhB,EAAUiB,oBAC7BD,IACHnW,EAASqW,oBAAoBF,GAC7BnW,EAASsW,0BAA2BC,KAAKpB,EAAUqB,0BAIpD,IAAMC,EAAYtB,EAAUO,+CACxBe,GAEH,IAAMC,EAAgBvB,EAAUwB,mCAC1BC,EAAkBlgB,EAAImgB,gBAvCwB,uBAwC9C9a,EAAe0a,EAAWG,EAAiB,SAACta,EAAQ/E,EAAGO,GAC5DwE,EAAOhE,IAAIf,EAAGO,EAAG,EAAG,wBAErBud,EAASyB,mBAAmBF,GAC5BvB,EAAS0B,wBAAwBH,GACjCvB,EAAS2B,yBAA0BT,KAAKG,GACxCrB,EAAS4B,8BAA+BV,KAAKG,GAG7C,IAAMQ,EAAmB/B,EAAUgC,sBAC7BC,EAAoB1gB,EAAImgB,gBAlDsB,uBAmD9C9a,EAAe0a,EAAWW,EAAmB,SAAC9a,EAAQ/E,EAAGO,GAE9D,IAAMuf,EAAY,IAAMnV,KAAKU,MAAMtG,EAAO/C,IAAIhC,EAAGO,EAAG,GAAKof,GACzD5a,EAAOhE,IAAIf,EAAGO,EAAG,EAAG,GACpBwE,EAAOhE,IAAIf,EAAGO,EAAG,EAAGuf,GACpB/a,EAAOhE,IAAIf,EAAGO,EAAG,EAAG,GACpBwE,EAAOhE,IAAIf,EAAGO,EAAG,EAAG,wBAErBkI,EAASsX,4BAA4BF,GACrCpX,EAASuX,kCAAmChB,KAAKG,OAEjDrB,EAASG,uBAAuBL,EAAUM,qBAC1CzV,EAASgW,mBAAmB,EAAIb,EAAUgC,4GAjF7C,uDEOiB,SAAC/gB,YAAAA,IAAAA,EAA6ByQ,GAE/C,IAAMxQ,OAAcwQ,EAAuBzQ,GAE3C,gBAAcM,OACb,IAAMC,EAASD,EAAIE,mBAEI,IAAnBP,EAAQW,QAcd,SAA0BN,EAAeC,EAAgBN,GACxD,IAAMmhB,EAAe,IAAIlhB,IAAYI,EAAIO,UAAUoP,cAAcrI,IAAI,SAACjG,UAAMA,EAAEsJ,YAE9E3K,EAAIO,UAAUC,aACZqB,QAAQ,SAACC,EAAMif,GACf,IAAIxe,MAAMye,QAAQrhB,EAAQW,SAAYX,EAAQW,OAAOR,SAASgC,EAAK8F,WAAnE,CAOA3H,EAAOwC,MAASzD,iCAAmC8C,EAAK8F,gBAExD,IAAMzG,EAASnB,EAAIihB,aAAanf,EAAK8F,WACnCsZ,OAAO7Q,EAAgBvO,EAAK8F,WAAa,OAAQkZ,IAEnDhf,EAAKC,iBACHF,QAAQ,SAACG,GACT,IAAMI,EAAUJ,EAAUK,aACtBD,GAASA,EAAQyL,UAAU1M,GAC/Ba,EAAUC,iBACRJ,QAAQ,SAACmB,UAAcA,EAAU6K,UAAU1M,KAC7Ca,EAAU4G,cACR/G,QAAQ,SAACsf,GACTA,EAAWlf,iBACTJ,QAAQ,SAACmB,UAAcA,EAAU6K,UAAU1M,cApBhDlB,EAAOwC,MACHzD,sBAAwB+hB,iBAAwBjf,EAAK8F,kBArB7BwZ,CAAgBphB,EAAKC,EAAQN,IAChC,IAAvBA,EAAQyQ,YA6Cd,SAA8BpQ,EAAeC,EAAgBN,GAC5D,IAAMmhB,EAAe,IAAIlhB,IAAYI,EAAIO,UAAUoP,cAAcrI,IAAI,SAACjG,UAAMA,EAAEsJ,YAE9E3K,EAAIO,UAAUwK,iBACZlJ,QAAQ,SAACmJ,EAAMqW,GACf,IAAI9e,MAAMye,QAAQrhB,EAAQyQ,aAAgBzQ,EAAQyQ,WAAWtQ,SAASkL,EAAKpD,WAA3E,CAOA3H,EAAOwC,MAASzD,sCAAwCgM,EAAKpD,gBAE7D,IAAMzG,EAASnB,EAAIihB,aAAajW,EAAKpD,WACnCsZ,OAAO7Q,EAAgBrF,EAAKpD,WAAa,YAAakZ,IAExD9V,EAAKI,eACHvJ,QAAQ,SAACwJ,GACT,IAAMC,EAAQD,EAAQE,WAChBK,EAASP,EAAQQ,YACnBP,GAAOA,EAAMuC,UAAU1M,GACvByK,GAAQA,EAAOiC,UAAU1M,UAhB9BlB,EAAOwC,MACHzD,2BAA6BqiB,iBAAwBrW,EAAKpD,kBApD9B0Z,CAAoBthB,EAAKC,EAAQN,GAE9DA,EAAQW,QAAWX,EAAQyQ,YAC/BnQ,EAAOkW,KAAQnX,0EAGVgB,EAAIsS,UAAUtD,EAAM,CAAC5P,cAAe,CAACC,eAAa0P,4BAExD9O,EAAOwC,MAASzD,mBAZjB,sEC2BgB,SAACU,YAAAA,IAAAA,EAA4BwR,GAE7C,IAAMvR,OAAcuR,EAAsBxR,GAE1C,gBAAcM,OACb,IAAMC,EAASD,EAAIE,YACbgD,EAAOlD,EAAIO,UAEjBP,EAAI0c,gBAAgB6E,oBAAkBC,aAAY,GAGlD,IAAI5P,OAAmD6P,EACpB,UAA/B9hB,EAAQyR,qBACXQ,EAAgB8B,EAqTnB,SAAsBgO,GAErB,IADA,MAAMvT,EAASuT,EAAO,OACHA,kBAAQ,KAAhBnL,UACVvO,MAAImG,EAAOnG,IAAKmG,EAAOnG,IAAKuO,EAAKvO,KACjCE,MAAIiG,EAAOjG,IAAKiG,EAAOjG,IAAKqO,EAAKrO,KAElC,OAAOiG,EA1TJwT,CAAaze,EAAK1C,aAAa8G,IAAI8O,MAKrC,cAAmBpW,EAAIO,UAAUC,6BAAc,KAApCsB,UACyB,SAA/BnC,EAAQyR,qBACXQ,EAAgB8B,EAAiB0C,EAA8BtU,KAG5D8P,GAAiBjS,EAAQwR,QAAQU,KAAK,aACzCgC,EAAqB7T,EAAK8B,EAAM8P,GAGjC,cAAmB9P,EAAKC,iCAAkB,KAA/B2B,UACViO,EAAkB3R,EAAK0D,EAAMkO,EAAgBjS,GAC7C,cAAqB+D,EAAKkF,8BACzB+I,EAAkB3R,UAAa4R,EAAgBjS,2BAK5CK,EAAIsS,UACTtD,EAAM,CAAC5P,cAAe,CAACC,eAAaC,SAAUD,eAAaoP,QAC3DhP,EAAM,CAACL,cAAe,CAACC,eAAaC,8BAGrCW,EAAOwC,MAASzD,mBArCjB,8DErBwBU,YAAAA,IAAAA,EAA2ByY,IACnD,IAAMxY,OAAcwY,GAAqBzY,GACnCkiB,EAAUjiB,EAAQiiB,QAExB,gBAAc5hB,OACb,IAAMC,EAASD,EAAIE,mCAEb0hB,EAAQC,uBAId,IAFA,MAAMC,EAoER,SAA8B9hB,GAK7B,IAJA,MAAM+hB,EAAsB,IAAIjb,EAC1Bkb,EAAgB,IAAIphB,IACpBqhB,EAAyB,IAAInb,MAEhB9G,EAAIO,UAAUC,6BAChC,sBAAwBuB,iCAAkB,KAA/B2B,UACJtB,EAAUsB,EAAKrB,aACrB,GAAKD,EAAL,CAEA4f,EAAcpgB,IAAIQ,EAASsB,EAAK0C,WAEhC,cAAwBnE,GAAeyB,mBAAO,KAAnCV,UACV+e,EAAoB5f,IAAIC,EAASY,GACjCif,EAAuB9f,IAAIa,EAAWU,KAKzC,MAAO,CAACqe,oBAAAA,EAAqBC,cAAAA,EAAeC,uBAAAA,GAvF9BC,CAAqBliB,OAET8hB,EAAKC,oBAAoBjf,uBAAQ,KAA/CgY,UACJqH,EAAarH,EAAW1I,QAC1B8H,EAAeiI,EAAWlhB,WAAYC,QACpCgZ,aAAwBC,cAC7BD,EAAe,IAAIC,YAAYD,IAJyB,MAQjC0H,EAAQQ,YAC/BlI,EACA4H,EAAKE,cAAcnf,IAAIiY,KAAgBzU,YAAUC,KAAKK,UACnC,SAAnBhH,EAAQ4F,QAHF8S,OAAOgK,OAMdF,EAAWxU,SAAS0U,GAAU,MAAQ,IAAI5O,YAAYyG,GAAgBA,GAGtE,cAA2B4H,EAAKC,oBAAoBlf,IAAIiY,mBAAa,KAA1DhJ,UACJK,EAAeL,EAAaM,QAClCgG,GAAejG,EAAckG,EAAOgK,GACpC,cAAmBP,EAAKG,uBAAuBpf,IAAIiP,mBAAe,KAAvDpO,UAIV,GAHIA,EAAKrB,eAAiByY,GACzBpX,EAAKd,KAAKkY,EAAYqH,GAEnBze,EAAKrB,eAAiB8f,EAAY,CACrCze,EAAKd,KAAKkP,EAAcK,GACxB,cAAqBzO,EAAKkF,sCAClBhG,KAAKkP,EAAcK,6BAQzBnS,EAAIsS,UAAUtD,EAAM,CAAC5P,cAAe,CAACC,eAAaC,8BAEnDwiB,EAAKC,oBAAoBrf,KAG7BzC,EAAOwC,MAASzD,sBAFhBiB,EAAOkW,KAAQnX,wEA7CjB,sDDjCuB,SAACU,YAAAA,IAAAA,EAA4BsX,IAEpD,IAAMrX,OAAcqX,GAAsBtX,GAE1C,gBAAQM,GAOP,IANA,MAAMsiB,EAAmB,IAAI1iB,IACvB2iB,EAAqBviB,EAAIO,UAAU6C,gBAAgBtC,OACnDb,EAASD,EAAIE,YAEfsiB,GAAsB,MAEFxiB,EAAIO,UAAUwK,iCAAkB,CAGvD,UAHU0X,UAEJC,EAAsB,IAAI9iB,QACV6iB,EAAU1W,+BAAgB,KAArCyD,UACNA,EAAQmT,cAA4C,YAA5BnT,EAAQ0E,iBACnCwO,EAAoBvgB,IAAIqN,EAAQmT,cAIlC,cAAsBF,EAAUrX,+BAAgB,KAArCC,UACNqX,EAAoBviB,IAAIkL,GAC3BmX,GAAsB,EAGY,SAA/BnX,EAAQ0M,oBACuB,WAA/B1M,EAAQ0M,qBACXuK,EAAiBngB,IAAIkJ,EAAQE,YAC7B+W,EAAiBngB,IAAIkJ,EAAQQ,aAC7BqL,GAAS7L,EAAS1L,KAKrB,cAAuB4C,MAAMC,KAAK8f,EAAiBM,yBAAW,CAAzD,IAAM1gB,OACGA,EAASiC,cAAc8P,KAAK,SAAChE,WAAQA,aAAa9K,WACpDjD,EAASa,UAGjB/C,EAAIO,UAAU6C,gBAAgBtC,OAASyhB,GAC1CtiB,EAAOkW,KACHnX,2IAKDwjB,GACHviB,EAAOkW,KAAQnX,2EAGhBiB,EAAOwC,MAASzD,mDExCQU,YAAAA,IAAAA,EAA4B+Y,IACrD,IAAM9Y,OAAc8Y,GAAsB/Y,GAE1C,gBAAQM,GAEP,IAAMC,EAASD,EAAIE,YACbgD,EAAOlD,EAAIO,UACXmY,EAAM/Y,EAAQ+Y,IAGdmK,EAAgB3f,EAAKiM,YACzB/G,OAAO,SAACwE,UAASA,EAAKhF,UAAUkb,MAAMnjB,EAAQwR,WAG5CxR,EAAQwJ,MACX0Z,EAAc1Z,KAAK,SAACpI,EAAGM,UAAMN,EAAE6G,UAAYvG,EAAEuG,UAAY,GAAK,IAI/D,IAAMoD,EAAOhL,EAAI+iB,gBAAgBpjB,EAAQgI,MACnCqb,EAAa9f,EAAKyM,cAAc,GACtCkT,EAAchhB,QAAQ,SAAC+K,EAAM/L,GAE5B,IAAIoiB,EACAC,EACM,IAANriB,GACHoiB,EAAa,CAACpiB,EAAI6X,GAAM7X,EAAI,GAAK6X,GACjCwK,EAAc,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,IACpBriB,IAAMgiB,EAAc/hB,OAAS,GACvCmiB,EAAa,EAAEpiB,EAAI,GAAK6X,EAAK7X,EAAI6X,GACjCwK,EAAc,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,KAE9BD,EAAa,EAAEpiB,EAAI,GAAK6X,EAAK7X,EAAI6X,GAAM7X,EAAI,GAAK6X,GAChDwK,EAAc,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAIxC,IAAM5X,EAAQtL,EAAIyN,iBAChBE,SAAS,IAAIC,aAAaqV,IAC1BpV,UAAUmV,GACNpX,EAAS5L,EAAIyN,iBACjBE,SAAS,IAAIC,aAAasV,IAC1BrV,UAAUmV,GACVtV,QAAQ0M,WAASC,KAAK8I,MAClB9X,EAAUrL,EAAIojB,yBAClBC,iBAAiBC,mBAAiBC,cAAcC,MAChDvL,SAAS3M,GACT4M,UAAUtM,GACN4D,EAAUxP,EAAIyjB,yBAClB/O,cAAc9H,GACd8W,cAAcxT,mBAAiBU,WAAWK,OAC1C0S,WAAWtY,GACbL,EAAK4Y,WAAWvY,GAASwY,WAAWrU,KAGrCvP,EAAOwC,MAASzD,mDC3CQU,GACzB,YADyBA,IAAAA,EAA4BiZ,KAChDjZ,EAASokB,iBACb,UAAU/jB,MAASf,mEAGpB,IAAMW,OAAcgZ,GAAsBjZ,GAE1C,gBAAQM,GAMP,IALA,MAAMC,EAASD,EAAIE,YACb6jB,EAAe,IAAInjB,IACnBojB,EAAe,IAAIpjB,IACrBqjB,EAAW,MAEIjkB,EAAIO,UAAUC,6BAIhC,QAJUsB,UACJqX,EAAWrX,EAAK8F,UAChBsc,EAAiBpiB,EAAKC,iBAEnBlB,EAAI,EAAGA,EAAIqjB,EAAepjB,OAAQD,IAAK,CAC/C,IAAM6C,EAAOwgB,EAAerjB,GAG5B,GAAKqY,GAAgBxV,EAAMzD,EAAQkZ,EAAUtY,EAAGlB,EAAQiZ,WAAxD,CAEA,IAAMuL,EAAmBtL,GAAkBnV,GAGrCyC,EAAWzC,EAAKI,aAAa,YAAa7C,WAC1CmjB,EAAS1gB,EAAKI,aAAa,UAAW7C,WACtCojB,EAAW3gB,EAAKI,aAAaqgB,GAAmBljB,WAGhDqjB,EAAaP,EAAalhB,IAAIsD,IAAaoe,SACjDR,EAAaniB,IAAIuE,EAAUme,GAE3B,IAAME,EAAWT,EAAalhB,IAAIuhB,IAAWG,SAC7CR,EAAaniB,IAAIwiB,EAAQI,GAEzB,IAAMC,EAAaV,EAAalhB,IAAIwhB,IAAaE,SACjDR,EAAaniB,IAAIyiB,EAAUI,GAG3B,IAAMC,EAAchhB,EAAKI,aAAa,WAClC4gB,GAAoD,IAArCA,EAAYvgB,cAAcrD,QAAc4jB,EAAY3hB,UAGvE,IAAM4hB,EAAmBL,MAAcE,MAAYC,EAC/CG,EAAUZ,EAAanhB,IAAI8hB,GAC/B,GAAIC,EACH3kB,EAAOwC,MAASzD,kCAAmC6B,eAAcsY,QACjEzV,EAAKuK,aAAa,UAAW2W,GAC7BX,QAHD,CAQAhkB,EAAOwC,MAASzD,iCAAkC6B,eAAcsY,QAShE,IARA,IAAM0L,EAAgBnhB,EAAKI,aAAa,YAAayJ,YAC/CuX,EAAenlB,EAAQmkB,iBAC5B3d,aAAoByH,aAAezH,EAAW,IAAIyH,aAAazH,GAC/Die,aAAkBxW,aAAewW,EAAS,IAAIxW,aAAawW,GAC3DC,aAAoBzW,aAAeyW,EAAW,IAAIzW,aAAayW,IAIvDxjB,EAAI,EAAGA,EAAIikB,EAAahkB,OAAQD,GAAK,EAAGikB,EAAajkB,KAAO,EAErE+jB,EAAU5kB,EAAIyN,iBACZI,UAAUgX,GACVlX,SAASmX,GACTpX,QAAQ,QACVhK,EAAKuK,aAAa,UAAW2W,GAE7BZ,EAAapiB,IAAI+iB,EAAeC,GAChCX,MAIGA,EAGJhkB,EAAOwC,MAASzD,kBAFhBiB,EAAOkW,KAAQnX,2FC5EYU,YAAAA,IAAAA,EAAiC+Z,IAC9D,IAAM9Z,OAAc8Z,GAA4B/Z,GAEhD,gBAAcM,yBA+DbC,EAAOwC,MAASzD,mBA7DViB,EAASD,EAAIE,0wBAEGF,EAAIO,UAAUiE,wBAAzB8F,GACV,IAAM3C,EAAO2C,EAAQ1C,UACf8C,EAAMJ,EAAQK,SAIpB,IAHehL,EAAQwR,SACnBxR,EAAQwR,QAAQU,KAAKlK,IACrBhI,EAAQwR,QAAQU,KAAKnH,GAGzB,GAA8B,cAA1BJ,EAAQ1F,eAA2D,eAA1B0F,EAAQ1F,cAArD,CARmD,MAarBjF,EAAQ+C,KAA/BqiB,OAAUC,SACa1a,EAAQxF,UAA/BmgB,OAAUC,OAEjB,KAAID,GAAYF,GAAYG,GAAaF,GAAzC,CAKA,IAAIG,EAAWF,EACXG,EAAYF,EAEZC,EAAWJ,IACdK,EAAY5Z,KAAK6Z,MAAMD,GAAaL,EAAWI,IAC/CA,EAAWJ,GAGRK,EAAYJ,IACfG,EAAW3Z,KAAK6Z,MAAMF,GAAYH,EAAYI,IAC9CA,EAAYJ,GAGb,IAAMvf,EAAW,IAAIE,WAAW2E,EAAQ5F,YAlCW,uBAmC3BgB,YAAUD,EAAU6E,EAAQ1F,8BAA9C0gB,GACN,IAAMC,EAAYC,UACjB,IAAI7f,WAAWwf,EAAWC,EAAY,GAAI,CAACD,EAAUC,EAAW,IAGjEnlB,EAAOwC,MACHzD,mBAAmB0L,GAAO/C,SAAU2d,EAAUzf,YAAW0f,EAAU1f,aAGvE,IACClG,EAAQyI,SAAWoR,4BAAoBE,SACpC+L,WAASH,EAAWC,GACpBG,WAASJ,EAAWC,GACtB,MAAOnX,GACR,GAAIA,aAAarO,MAAO,YACvBE,EAAOkW,KAAQnX,2BAA2B0L,GAAO/C,UAAWyG,EAAEuX,cAG/D,MAAMvX,EArD4C,MAwDnD9D,EAAQvE,gCAAgBD,aAAWyf,EAAWjb,EAAQ1F,iCAAtDghB,OAAAtb,EAAiBtE,EAAqD7E,YAvCrElB,EAAOwC,MAASzD,mBAAmB0L,GAAO/C,iCAR1C1H,EAAOkW,4CAA4C7L,EAAQ1F,sEAb9D,6DCzBuBlF,GAIvB,gBAJuBA,IAAAA,EAA0Bia,SAE7BA,GAAoBja,YAEhCM,GAKP,IAHA,MAAMC,EAASD,EAAIE,YACb2Z,EAAU,IAAIjZ,QAEDZ,EAAIO,UAAUC,6BAChC,sBAAwBuB,iCAAkB,KAA/B2B,UACJtB,EAAUsB,EAAKrB,aACrB,GAAKD,EAAL,CAGA,cAA2BsB,EAAKzB,iCAAkB,KAAvC6P,UACVpO,EAAKd,KACJkP,EACA8H,GAAgB9H,EAAc1P,EAASnC,EAAQ4Z,IAIN,IAAtC/H,EAAa3N,cAAcrD,QAAcgR,EAAa/O,UAI3D,cAAqBW,EAAKkF,8BACzB,UADUrD,cACiBA,EAAOtD,iCAAkB,KAAzC6P,UACVvM,EAAO3C,KACNkP,EACA8H,GAAgB9H,EAAc1P,EAASnC,EAAQ4Z,IAIN,IAAtC/H,EAAa3N,cAAcrD,QAAcgR,EAAa/O,UAK5DW,EAAK6W,WAAW,MACqB,IAAjCnY,EAAQ+B,cAAcrD,QAAcsB,EAAQW,WAIlD9C,EAAOwC,MAASzD,6CC7CIU,YAAAA,IAAAA,EAAwBqa,IAC7C,IAAMpa,OAAcoa,GAAkBra,GAEtC,gBAAQM,GAGP,IAFA,MAAMC,EAASD,EAAIE,gBAEAF,EAAIO,UAAUC,6BAChC,sBAAwBuB,iCAAkB,KAA/B2B,UACgB,IAAtB/D,EAAQsX,UACX+C,GAASha,EAAK0D,GAEd8W,GAAaxa,EAAK0D,EAAM/D,GAK3BM,EAAOwC,MAASzD"}