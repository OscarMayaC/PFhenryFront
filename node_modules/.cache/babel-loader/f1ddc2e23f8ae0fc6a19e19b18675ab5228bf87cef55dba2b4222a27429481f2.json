{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.canMatchCharCode = exports.firstCharOptimizedIndices = exports.getOptimizedStartCodesIndices = exports.failedOptimizationPrefixMsg = void 0;\nvar regexp_to_ast_1 = require(\"regexp-to-ast\");\nvar isArray_1 = __importDefault(require(\"lodash/isArray\"));\nvar every_1 = __importDefault(require(\"lodash/every\"));\nvar forEach_1 = __importDefault(require(\"lodash/forEach\"));\nvar find_1 = __importDefault(require(\"lodash/find\"));\nvar values_1 = __importDefault(require(\"lodash/values\"));\nvar includes_1 = __importDefault(require(\"lodash/includes\"));\nvar utils_1 = require(\"@chevrotain/utils\");\nvar reg_exp_parser_1 = require(\"./reg_exp_parser\");\nvar lexer_1 = require(\"./lexer\");\nvar complementErrorMessage = \"Complement Sets are not supported for first char optimization\";\nexports.failedOptimizationPrefixMsg = 'Unable to use \"first char\" lexer optimizations:\\n';\nfunction getOptimizedStartCodesIndices(regExp, ensureOptimizations) {\n  if (ensureOptimizations === void 0) {\n    ensureOptimizations = false;\n  }\n  try {\n    var ast = (0, reg_exp_parser_1.getRegExpAst)(regExp);\n    var firstChars = firstCharOptimizedIndices(ast.value, {}, ast.flags.ignoreCase);\n    return firstChars;\n  } catch (e) {\n    /* istanbul ignore next */\n    // Testing this relies on the regexp-to-ast library having a bug... */\n    // TODO: only the else branch needs to be ignored, try to fix with newer prettier / tsc\n    if (e.message === complementErrorMessage) {\n      if (ensureOptimizations) {\n        (0, utils_1.PRINT_WARNING)(\"\".concat(exports.failedOptimizationPrefixMsg) + \"\\tUnable to optimize: < \".concat(regExp.toString(), \" >\\n\") + \"\\tComplement Sets cannot be automatically optimized.\\n\" + \"\\tThis will disable the lexer's first char optimizations.\\n\" + \"\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.\");\n      }\n    } else {\n      var msgSuffix = \"\";\n      if (ensureOptimizations) {\n        msgSuffix = \"\\n\\tThis will disable the lexer's first char optimizations.\\n\" + \"\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.\";\n      }\n      (0, utils_1.PRINT_ERROR)(\"\".concat(exports.failedOptimizationPrefixMsg, \"\\n\") + \"\\tFailed parsing: < \".concat(regExp.toString(), \" >\\n\") + \"\\tUsing the regexp-to-ast library version: \".concat(regexp_to_ast_1.VERSION, \"\\n\") + \"\\tPlease open an issue at: https://github.com/bd82/regexp-to-ast/issues\" + msgSuffix);\n    }\n  }\n  return [];\n}\nexports.getOptimizedStartCodesIndices = getOptimizedStartCodesIndices;\nfunction firstCharOptimizedIndices(ast, result, ignoreCase) {\n  switch (ast.type) {\n    case \"Disjunction\":\n      for (var i = 0; i < ast.value.length; i++) {\n        firstCharOptimizedIndices(ast.value[i], result, ignoreCase);\n      }\n      break;\n    case \"Alternative\":\n      var terms = ast.value;\n      for (var i = 0; i < terms.length; i++) {\n        var term = terms[i];\n        // skip terms that cannot effect the first char results\n        switch (term.type) {\n          case \"EndAnchor\":\n          // A group back reference cannot affect potential starting char.\n          // because if a back reference is the first production than automatically\n          // the group being referenced has had to come BEFORE so its codes have already been added\n          case \"GroupBackReference\":\n          // assertions do not affect potential starting codes\n          case \"Lookahead\":\n          case \"NegativeLookahead\":\n          case \"StartAnchor\":\n          case \"WordBoundary\":\n          case \"NonWordBoundary\":\n            continue;\n        }\n        var atom = term;\n        switch (atom.type) {\n          case \"Character\":\n            addOptimizedIdxToResult(atom.value, result, ignoreCase);\n            break;\n          case \"Set\":\n            if (atom.complement === true) {\n              throw Error(complementErrorMessage);\n            }\n            (0, forEach_1.default)(atom.value, function (code) {\n              if (typeof code === \"number\") {\n                addOptimizedIdxToResult(code, result, ignoreCase);\n              } else {\n                // range\n                var range = code;\n                // cannot optimize when ignoreCase is\n                if (ignoreCase === true) {\n                  for (var rangeCode = range.from; rangeCode <= range.to; rangeCode++) {\n                    addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                  }\n                }\n                // Optimization (2 orders of magnitude less work for very large ranges)\n                else {\n                  // handle unoptimized values\n                  for (var rangeCode = range.from; rangeCode <= range.to && rangeCode < lexer_1.minOptimizationVal; rangeCode++) {\n                    addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                  }\n                  // Less common charCode where we optimize for faster init time, by using larger \"buckets\"\n                  if (range.to >= lexer_1.minOptimizationVal) {\n                    var minUnOptVal = range.from >= lexer_1.minOptimizationVal ? range.from : lexer_1.minOptimizationVal;\n                    var maxUnOptVal = range.to;\n                    var minOptIdx = (0, lexer_1.charCodeToOptimizedIndex)(minUnOptVal);\n                    var maxOptIdx = (0, lexer_1.charCodeToOptimizedIndex)(maxUnOptVal);\n                    for (var currOptIdx = minOptIdx; currOptIdx <= maxOptIdx; currOptIdx++) {\n                      result[currOptIdx] = currOptIdx;\n                    }\n                  }\n                }\n              }\n            });\n            break;\n          case \"Group\":\n            firstCharOptimizedIndices(atom.value, result, ignoreCase);\n            break;\n          /* istanbul ignore next */\n          default:\n            throw Error(\"Non Exhaustive Match\");\n        }\n        // reached a mandatory production, no more **start** codes can be found on this alternative\n        var isOptionalQuantifier = atom.quantifier !== undefined && atom.quantifier.atLeast === 0;\n        if (\n        // A group may be optional due to empty contents /(?:)/\n        // or if everything inside it is optional /((a)?)/\n        atom.type === \"Group\" && isWholeOptional(atom) === false ||\n        // If this term is not a group it may only be optional if it has an optional quantifier\n        atom.type !== \"Group\" && isOptionalQuantifier === false) {\n          break;\n        }\n      }\n      break;\n    /* istanbul ignore next */\n    default:\n      throw Error(\"non exhaustive match!\");\n  }\n  // console.log(Object.keys(result).length)\n  return (0, values_1.default)(result);\n}\nexports.firstCharOptimizedIndices = firstCharOptimizedIndices;\nfunction addOptimizedIdxToResult(code, result, ignoreCase) {\n  var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(code);\n  result[optimizedCharIdx] = optimizedCharIdx;\n  if (ignoreCase === true) {\n    handleIgnoreCase(code, result);\n  }\n}\nfunction handleIgnoreCase(code, result) {\n  var char = String.fromCharCode(code);\n  var upperChar = char.toUpperCase();\n  /* istanbul ignore else */\n  if (upperChar !== char) {\n    var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(upperChar.charCodeAt(0));\n    result[optimizedCharIdx] = optimizedCharIdx;\n  } else {\n    var lowerChar = char.toLowerCase();\n    if (lowerChar !== char) {\n      var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(lowerChar.charCodeAt(0));\n      result[optimizedCharIdx] = optimizedCharIdx;\n    }\n  }\n}\nfunction findCode(setNode, targetCharCodes) {\n  return (0, find_1.default)(setNode.value, function (codeOrRange) {\n    if (typeof codeOrRange === \"number\") {\n      return (0, includes_1.default)(targetCharCodes, codeOrRange);\n    } else {\n      // range\n      var range_1 = codeOrRange;\n      return (0, find_1.default)(targetCharCodes, function (targetCode) {\n        return range_1.from <= targetCode && targetCode <= range_1.to;\n      }) !== undefined;\n    }\n  });\n}\nfunction isWholeOptional(ast) {\n  var quantifier = ast.quantifier;\n  if (quantifier && quantifier.atLeast === 0) {\n    return true;\n  }\n  if (!ast.value) {\n    return false;\n  }\n  return (0, isArray_1.default)(ast.value) ? (0, every_1.default)(ast.value, isWholeOptional) : isWholeOptional(ast.value);\n}\nvar CharCodeFinder = /** @class */function (_super) {\n  __extends(CharCodeFinder, _super);\n  function CharCodeFinder(targetCharCodes) {\n    var _this = _super.call(this) || this;\n    _this.targetCharCodes = targetCharCodes;\n    _this.found = false;\n    return _this;\n  }\n  CharCodeFinder.prototype.visitChildren = function (node) {\n    // No need to keep looking...\n    if (this.found === true) {\n      return;\n    }\n    // switch lookaheads as they do not actually consume any characters thus\n    // finding a charCode at lookahead context does not mean that regexp can actually contain it in a match.\n    switch (node.type) {\n      case \"Lookahead\":\n        this.visitLookahead(node);\n        return;\n      case \"NegativeLookahead\":\n        this.visitNegativeLookahead(node);\n        return;\n    }\n    _super.prototype.visitChildren.call(this, node);\n  };\n  CharCodeFinder.prototype.visitCharacter = function (node) {\n    if ((0, includes_1.default)(this.targetCharCodes, node.value)) {\n      this.found = true;\n    }\n  };\n  CharCodeFinder.prototype.visitSet = function (node) {\n    if (node.complement) {\n      if (findCode(node, this.targetCharCodes) === undefined) {\n        this.found = true;\n      }\n    } else {\n      if (findCode(node, this.targetCharCodes) !== undefined) {\n        this.found = true;\n      }\n    }\n  };\n  return CharCodeFinder;\n}(regexp_to_ast_1.BaseRegExpVisitor);\nfunction canMatchCharCode(charCodes, pattern) {\n  if (pattern instanceof RegExp) {\n    var ast = (0, reg_exp_parser_1.getRegExpAst)(pattern);\n    var charCodeFinder = new CharCodeFinder(charCodes);\n    charCodeFinder.visit(ast);\n    return charCodeFinder.found;\n  } else {\n    return (0, find_1.default)(pattern, function (char) {\n      return (0, includes_1.default)(charCodes, char.charCodeAt(0));\n    }) !== undefined;\n  }\n}\nexports.canMatchCharCode = canMatchCharCode;","map":{"version":3,"names":["regexp_to_ast_1","require","isArray_1","__importDefault","every_1","forEach_1","find_1","values_1","includes_1","utils_1","reg_exp_parser_1","lexer_1","complementErrorMessage","exports","failedOptimizationPrefixMsg","getOptimizedStartCodesIndices","regExp","ensureOptimizations","ast","getRegExpAst","firstChars","firstCharOptimizedIndices","value","flags","ignoreCase","e","message","PRINT_WARNING","concat","toString","msgSuffix","PRINT_ERROR","VERSION","result","type","i","length","terms","term","atom","addOptimizedIdxToResult","complement","Error","default","code","range","rangeCode","from","to","minOptimizationVal","minUnOptVal","maxUnOptVal","minOptIdx","charCodeToOptimizedIndex","maxOptIdx","currOptIdx","isOptionalQuantifier","quantifier","undefined","atLeast","isWholeOptional","optimizedCharIdx","handleIgnoreCase","char","String","fromCharCode","upperChar","toUpperCase","charCodeAt","lowerChar","toLowerCase","findCode","setNode","targetCharCodes","codeOrRange","range_1","targetCode","CharCodeFinder","_super","__extends","_this","call","found","prototype","visitChildren","node","visitLookahead","visitNegativeLookahead","visitCharacter","visitSet","BaseRegExpVisitor","canMatchCharCode","charCodes","pattern","RegExp","charCodeFinder","visit"],"sources":["/Users/rociopichardo/Desktop/PFhenryFront/restaurante-pf-front/node_modules/chevrotain/src/scan/reg_exp.ts"],"sourcesContent":["import {\n  Alternative,\n  Atom,\n  BaseRegExpVisitor,\n  Character,\n  Disjunction,\n  Group,\n  Set,\n  Term,\n  VERSION\n} from \"regexp-to-ast\"\nimport isArray from \"lodash/isArray\"\nimport every from \"lodash/every\"\nimport forEach from \"lodash/forEach\"\nimport find from \"lodash/find\"\nimport values from \"lodash/values\"\nimport includes from \"lodash/includes\"\nimport { PRINT_ERROR, PRINT_WARNING } from \"@chevrotain/utils\"\nimport { ASTNode, getRegExpAst } from \"./reg_exp_parser\"\nimport { charCodeToOptimizedIndex, minOptimizationVal } from \"./lexer\"\n\nconst complementErrorMessage =\n  \"Complement Sets are not supported for first char optimization\"\nexport const failedOptimizationPrefixMsg =\n  'Unable to use \"first char\" lexer optimizations:\\n'\n\nexport function getOptimizedStartCodesIndices(\n  regExp: RegExp,\n  ensureOptimizations = false\n): number[] {\n  try {\n    const ast = getRegExpAst(regExp)\n    const firstChars = firstCharOptimizedIndices(\n      ast.value,\n      {},\n      ast.flags.ignoreCase\n    )\n    return firstChars\n  } catch (e) {\n    /* istanbul ignore next */\n    // Testing this relies on the regexp-to-ast library having a bug... */\n    // TODO: only the else branch needs to be ignored, try to fix with newer prettier / tsc\n    if (e.message === complementErrorMessage) {\n      if (ensureOptimizations) {\n        PRINT_WARNING(\n          `${failedOptimizationPrefixMsg}` +\n            `\\tUnable to optimize: < ${regExp.toString()} >\\n` +\n            \"\\tComplement Sets cannot be automatically optimized.\\n\" +\n            \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n            \"\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.\"\n        )\n      }\n    } else {\n      let msgSuffix = \"\"\n      if (ensureOptimizations) {\n        msgSuffix =\n          \"\\n\\tThis will disable the lexer's first char optimizations.\\n\" +\n          \"\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.\"\n      }\n      PRINT_ERROR(\n        `${failedOptimizationPrefixMsg}\\n` +\n          `\\tFailed parsing: < ${regExp.toString()} >\\n` +\n          `\\tUsing the regexp-to-ast library version: ${VERSION}\\n` +\n          \"\\tPlease open an issue at: https://github.com/bd82/regexp-to-ast/issues\" +\n          msgSuffix\n      )\n    }\n  }\n\n  return []\n}\n\nexport function firstCharOptimizedIndices(\n  ast: ASTNode,\n  result: { [charCode: number]: number },\n  ignoreCase: boolean\n): number[] {\n  switch (ast.type) {\n    case \"Disjunction\":\n      for (let i = 0; i < ast.value.length; i++) {\n        firstCharOptimizedIndices(ast.value[i], result, ignoreCase)\n      }\n      break\n    case \"Alternative\":\n      const terms = ast.value\n      for (let i = 0; i < terms.length; i++) {\n        const term = terms[i]\n\n        // skip terms that cannot effect the first char results\n        switch (term.type) {\n          case \"EndAnchor\":\n          // A group back reference cannot affect potential starting char.\n          // because if a back reference is the first production than automatically\n          // the group being referenced has had to come BEFORE so its codes have already been added\n          case \"GroupBackReference\":\n          // assertions do not affect potential starting codes\n          case \"Lookahead\":\n          case \"NegativeLookahead\":\n          case \"StartAnchor\":\n          case \"WordBoundary\":\n          case \"NonWordBoundary\":\n            continue\n        }\n\n        const atom = term\n        switch (atom.type) {\n          case \"Character\":\n            addOptimizedIdxToResult(atom.value, result, ignoreCase)\n            break\n          case \"Set\":\n            if (atom.complement === true) {\n              throw Error(complementErrorMessage)\n            }\n            forEach(atom.value, (code) => {\n              if (typeof code === \"number\") {\n                addOptimizedIdxToResult(code, result, ignoreCase)\n              } else {\n                // range\n                const range = code as any\n                // cannot optimize when ignoreCase is\n                if (ignoreCase === true) {\n                  for (\n                    let rangeCode = range.from;\n                    rangeCode <= range.to;\n                    rangeCode++\n                  ) {\n                    addOptimizedIdxToResult(rangeCode, result, ignoreCase)\n                  }\n                }\n                // Optimization (2 orders of magnitude less work for very large ranges)\n                else {\n                  // handle unoptimized values\n                  for (\n                    let rangeCode = range.from;\n                    rangeCode <= range.to && rangeCode < minOptimizationVal;\n                    rangeCode++\n                  ) {\n                    addOptimizedIdxToResult(rangeCode, result, ignoreCase)\n                  }\n\n                  // Less common charCode where we optimize for faster init time, by using larger \"buckets\"\n                  if (range.to >= minOptimizationVal) {\n                    const minUnOptVal =\n                      range.from >= minOptimizationVal\n                        ? range.from\n                        : minOptimizationVal\n                    const maxUnOptVal = range.to\n                    const minOptIdx = charCodeToOptimizedIndex(minUnOptVal)\n                    const maxOptIdx = charCodeToOptimizedIndex(maxUnOptVal)\n\n                    for (\n                      let currOptIdx = minOptIdx;\n                      currOptIdx <= maxOptIdx;\n                      currOptIdx++\n                    ) {\n                      result[currOptIdx] = currOptIdx\n                    }\n                  }\n                }\n              }\n            })\n            break\n          case \"Group\":\n            firstCharOptimizedIndices(atom.value, result, ignoreCase)\n            break\n          /* istanbul ignore next */\n          default:\n            throw Error(\"Non Exhaustive Match\")\n        }\n\n        // reached a mandatory production, no more **start** codes can be found on this alternative\n        const isOptionalQuantifier =\n          atom.quantifier !== undefined && atom.quantifier.atLeast === 0\n        if (\n          // A group may be optional due to empty contents /(?:)/\n          // or if everything inside it is optional /((a)?)/\n          (atom.type === \"Group\" && isWholeOptional(atom) === false) ||\n          // If this term is not a group it may only be optional if it has an optional quantifier\n          (atom.type !== \"Group\" && isOptionalQuantifier === false)\n        ) {\n          break\n        }\n      }\n      break\n    /* istanbul ignore next */\n    default:\n      throw Error(\"non exhaustive match!\")\n  }\n\n  // console.log(Object.keys(result).length)\n  return values(result)\n}\n\nfunction addOptimizedIdxToResult(\n  code: number,\n  result: { [charCode: number]: number },\n  ignoreCase: boolean\n) {\n  const optimizedCharIdx = charCodeToOptimizedIndex(code)\n  result[optimizedCharIdx] = optimizedCharIdx\n\n  if (ignoreCase === true) {\n    handleIgnoreCase(code, result)\n  }\n}\n\nfunction handleIgnoreCase(\n  code: number,\n  result: { [charCode: number]: number }\n) {\n  const char = String.fromCharCode(code)\n  const upperChar = char.toUpperCase()\n  /* istanbul ignore else */\n  if (upperChar !== char) {\n    const optimizedCharIdx = charCodeToOptimizedIndex(upperChar.charCodeAt(0))\n    result[optimizedCharIdx] = optimizedCharIdx\n  } else {\n    const lowerChar = char.toLowerCase()\n    if (lowerChar !== char) {\n      const optimizedCharIdx = charCodeToOptimizedIndex(lowerChar.charCodeAt(0))\n      result[optimizedCharIdx] = optimizedCharIdx\n    }\n  }\n}\n\nfunction findCode(setNode: Set, targetCharCodes: number[]) {\n  return find(setNode.value, (codeOrRange) => {\n    if (typeof codeOrRange === \"number\") {\n      return includes(targetCharCodes, codeOrRange)\n    } else {\n      // range\n      const range = <any>codeOrRange\n      return (\n        find(\n          targetCharCodes,\n          (targetCode) => range.from <= targetCode && targetCode <= range.to\n        ) !== undefined\n      )\n    }\n  })\n}\n\nfunction isWholeOptional(ast: any): boolean {\n  const quantifier = (ast as Atom).quantifier\n  if (quantifier && quantifier.atLeast === 0) {\n    return true\n  }\n\n  if (!ast.value) {\n    return false\n  }\n\n  return isArray(ast.value)\n    ? every(ast.value, isWholeOptional)\n    : isWholeOptional(ast.value)\n}\n\nclass CharCodeFinder extends BaseRegExpVisitor {\n  found: boolean = false\n\n  constructor(private targetCharCodes: number[]) {\n    super()\n  }\n\n  visitChildren(node: ASTNode) {\n    // No need to keep looking...\n    if (this.found === true) {\n      return\n    }\n\n    // switch lookaheads as they do not actually consume any characters thus\n    // finding a charCode at lookahead context does not mean that regexp can actually contain it in a match.\n    switch (node.type) {\n      case \"Lookahead\":\n        this.visitLookahead(node)\n        return\n      case \"NegativeLookahead\":\n        this.visitNegativeLookahead(node)\n        return\n    }\n\n    super.visitChildren(node)\n  }\n\n  visitCharacter(node: Character) {\n    if (includes(this.targetCharCodes, node.value)) {\n      this.found = true\n    }\n  }\n\n  visitSet(node: Set) {\n    if (node.complement) {\n      if (findCode(node, this.targetCharCodes) === undefined) {\n        this.found = true\n      }\n    } else {\n      if (findCode(node, this.targetCharCodes) !== undefined) {\n        this.found = true\n      }\n    }\n  }\n}\n\nexport function canMatchCharCode(\n  charCodes: number[],\n  pattern: RegExp | string\n) {\n  if (pattern instanceof RegExp) {\n    const ast = getRegExpAst(pattern)\n    const charCodeFinder = new CharCodeFinder(charCodes)\n    charCodeFinder.visit(ast)\n    return charCodeFinder.found\n  } else {\n    return (\n      find(<any>pattern, (char) => {\n        return includes(charCodes, (<string>char).charCodeAt(0))\n      }) !== undefined\n    )\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}