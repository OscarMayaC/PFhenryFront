{"ast":null,"code":"import { NodeUpdateType } from './constants.js';\nimport { getNodesKeys } from './NodeUtils.js';\nimport { MathUtils } from 'three';\nlet _nodeId = 0;\nclass Node {\n  constructor() {\n    let nodeType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    this.nodeType = nodeType;\n    this.updateType = NodeUpdateType.None;\n    this.uuid = MathUtils.generateUUID();\n    Object.defineProperty(this, 'id', {\n      value: _nodeId++\n    });\n  }\n  get type() {\n    return this.constructor.name;\n  }\n  getHash() {\n    return this.uuid;\n  }\n  getUpdateType() {\n    return this.updateType;\n  }\n  getNodeType() {\n    return this.nodeType;\n  }\n  update() {\n    console.warn('Abstract function.');\n  }\n  generate() {\n    console.warn('Abstract function.');\n  }\n  analyze(builder) {\n    const hash = this.getHash(builder);\n    const sharedNode = builder.getNodeFromHash(hash);\n    if (sharedNode !== undefined && this !== sharedNode) {\n      return sharedNode.analyze(builder);\n    }\n    const nodeData = builder.getDataFromNode(this);\n    nodeData.dependenciesCount = nodeData.dependenciesCount === undefined ? 1 : nodeData.dependenciesCount + 1;\n    const nodeKeys = getNodesKeys(this);\n    for (const property of nodeKeys) {\n      this[property].analyze(builder);\n    }\n  }\n  build(builder) {\n    let output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const hash = this.getHash(builder);\n    const sharedNode = builder.getNodeFromHash(hash);\n    if (sharedNode !== undefined && this !== sharedNode) {\n      return sharedNode.build(builder, output);\n    }\n    builder.addNode(this);\n    builder.addStack(this);\n    const nodeData = builder.getDataFromNode(this);\n    const isGenerateOnce = this.generate.length === 1;\n    let snippet = null;\n    if (isGenerateOnce) {\n      const type = this.getNodeType(builder);\n      snippet = nodeData.snippet;\n      if (snippet === undefined) {\n        snippet = this.generate(builder) || '';\n        nodeData.snippet = snippet;\n      }\n      snippet = builder.format(snippet, type, output);\n    } else {\n      snippet = this.generate(builder, output) || '';\n    }\n    builder.removeStack(this);\n    return snippet;\n  }\n  serialize(json) {\n    const nodeKeys = getNodesKeys(this);\n    if (nodeKeys.length > 0) {\n      const inputNodes = {};\n      for (const property of nodeKeys) {\n        inputNodes[property] = this[property].toJSON(json.meta).uuid;\n      }\n      json.inputNodes = inputNodes;\n    }\n  }\n  deserialize(json) {\n    if (json.inputNodes !== undefined) {\n      const nodes = json.meta.nodes;\n      for (const property in json.inputNodes) {\n        const uuid = json.inputNodes[property];\n        this[property] = nodes[uuid];\n      }\n    }\n  }\n  toJSON(meta) {\n    const {\n      uuid,\n      type\n    } = this;\n    const isRoot = meta === undefined || typeof meta === 'string';\n    if (isRoot) {\n      meta = {\n        textures: {},\n        images: {},\n        nodes: {}\n      };\n    } // serialize\n\n    let data = meta.nodes[uuid];\n    if (data === undefined) {\n      data = {\n        uuid,\n        type,\n        meta,\n        metadata: {\n          version: 4.5,\n          type: 'Node',\n          generator: 'Node.toJSON'\n        }\n      };\n      meta.nodes[data.uuid] = data;\n      this.serialize(data);\n      delete data.meta;\n    } // TODO: Copied from Object3D.toJSON\n\n    function extractFromCache(cache) {\n      const values = [];\n      for (const key in cache) {\n        const data = cache[key];\n        delete data.metadata;\n        values.push(data);\n      }\n      return values;\n    }\n    if (isRoot) {\n      const textures = extractFromCache(meta.textures);\n      const images = extractFromCache(meta.images);\n      const nodes = extractFromCache(meta.nodes);\n      if (textures.length > 0) data.textures = textures;\n      if (images.length > 0) data.images = images;\n      if (nodes.length > 0) data.nodes = nodes;\n    }\n    return data;\n  }\n}\nNode.prototype.isNode = true;\nexport default Node;","map":{"version":3,"names":["NodeUpdateType","getNodesKeys","MathUtils","_nodeId","Node","constructor","nodeType","arguments","length","undefined","updateType","None","uuid","generateUUID","Object","defineProperty","value","type","name","getHash","getUpdateType","getNodeType","update","console","warn","generate","analyze","builder","hash","sharedNode","getNodeFromHash","nodeData","getDataFromNode","dependenciesCount","nodeKeys","property","build","output","addNode","addStack","isGenerateOnce","snippet","format","removeStack","serialize","json","inputNodes","toJSON","meta","deserialize","nodes","isRoot","textures","images","data","metadata","version","generator","extractFromCache","cache","values","key","push","prototype","isNode"],"sources":["/Users/rociopichardo/Desktop/PFhenryFront/restaurante-pf-front/node_modules/three-stdlib/nodes/core/Node.js"],"sourcesContent":["import { NodeUpdateType } from './constants.js';\nimport { getNodesKeys } from './NodeUtils.js';\nimport { MathUtils } from 'three';\n\nlet _nodeId = 0;\n\nclass Node {\n  constructor(nodeType = null) {\n    this.nodeType = nodeType;\n    this.updateType = NodeUpdateType.None;\n    this.uuid = MathUtils.generateUUID();\n    Object.defineProperty(this, 'id', {\n      value: _nodeId++\n    });\n  }\n\n  get type() {\n    return this.constructor.name;\n  }\n\n  getHash() {\n    return this.uuid;\n  }\n\n  getUpdateType() {\n    return this.updateType;\n  }\n\n  getNodeType() {\n    return this.nodeType;\n  }\n\n  update() {\n    console.warn('Abstract function.');\n  }\n\n  generate() {\n    console.warn('Abstract function.');\n  }\n\n  analyze(builder) {\n    const hash = this.getHash(builder);\n    const sharedNode = builder.getNodeFromHash(hash);\n\n    if (sharedNode !== undefined && this !== sharedNode) {\n      return sharedNode.analyze(builder);\n    }\n\n    const nodeData = builder.getDataFromNode(this);\n    nodeData.dependenciesCount = nodeData.dependenciesCount === undefined ? 1 : nodeData.dependenciesCount + 1;\n    const nodeKeys = getNodesKeys(this);\n\n    for (const property of nodeKeys) {\n      this[property].analyze(builder);\n    }\n  }\n\n  build(builder, output = null) {\n    const hash = this.getHash(builder);\n    const sharedNode = builder.getNodeFromHash(hash);\n\n    if (sharedNode !== undefined && this !== sharedNode) {\n      return sharedNode.build(builder, output);\n    }\n\n    builder.addNode(this);\n    builder.addStack(this);\n    const nodeData = builder.getDataFromNode(this);\n    const isGenerateOnce = this.generate.length === 1;\n    let snippet = null;\n\n    if (isGenerateOnce) {\n      const type = this.getNodeType(builder);\n      snippet = nodeData.snippet;\n\n      if (snippet === undefined) {\n        snippet = this.generate(builder) || '';\n        nodeData.snippet = snippet;\n      }\n\n      snippet = builder.format(snippet, type, output);\n    } else {\n      snippet = this.generate(builder, output) || '';\n    }\n\n    builder.removeStack(this);\n    return snippet;\n  }\n\n  serialize(json) {\n    const nodeKeys = getNodesKeys(this);\n\n    if (nodeKeys.length > 0) {\n      const inputNodes = {};\n\n      for (const property of nodeKeys) {\n        inputNodes[property] = this[property].toJSON(json.meta).uuid;\n      }\n\n      json.inputNodes = inputNodes;\n    }\n  }\n\n  deserialize(json) {\n    if (json.inputNodes !== undefined) {\n      const nodes = json.meta.nodes;\n\n      for (const property in json.inputNodes) {\n        const uuid = json.inputNodes[property];\n        this[property] = nodes[uuid];\n      }\n    }\n  }\n\n  toJSON(meta) {\n    const {\n      uuid,\n      type\n    } = this;\n    const isRoot = meta === undefined || typeof meta === 'string';\n\n    if (isRoot) {\n      meta = {\n        textures: {},\n        images: {},\n        nodes: {}\n      };\n    } // serialize\n\n\n    let data = meta.nodes[uuid];\n\n    if (data === undefined) {\n      data = {\n        uuid,\n        type,\n        meta,\n        metadata: {\n          version: 4.5,\n          type: 'Node',\n          generator: 'Node.toJSON'\n        }\n      };\n      meta.nodes[data.uuid] = data;\n      this.serialize(data);\n      delete data.meta;\n    } // TODO: Copied from Object3D.toJSON\n\n\n    function extractFromCache(cache) {\n      const values = [];\n\n      for (const key in cache) {\n        const data = cache[key];\n        delete data.metadata;\n        values.push(data);\n      }\n\n      return values;\n    }\n\n    if (isRoot) {\n      const textures = extractFromCache(meta.textures);\n      const images = extractFromCache(meta.images);\n      const nodes = extractFromCache(meta.nodes);\n      if (textures.length > 0) data.textures = textures;\n      if (images.length > 0) data.images = images;\n      if (nodes.length > 0) data.nodes = nodes;\n    }\n\n    return data;\n  }\n\n}\n\nNode.prototype.isNode = true;\n\nexport default Node;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}