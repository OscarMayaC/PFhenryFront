{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getProductionDslName = exports.isBranchingProd = exports.isOptionalProd = exports.isSequenceProd = void 0;\nvar some_1 = __importDefault(require(\"lodash/some\"));\nvar every_1 = __importDefault(require(\"lodash/every\"));\nvar includes_1 = __importDefault(require(\"lodash/includes\"));\nvar model_1 = require(\"./model\");\nfunction isSequenceProd(prod) {\n  return prod instanceof model_1.Alternative || prod instanceof model_1.Option || prod instanceof model_1.Repetition || prod instanceof model_1.RepetitionMandatory || prod instanceof model_1.RepetitionMandatoryWithSeparator || prod instanceof model_1.RepetitionWithSeparator || prod instanceof model_1.Terminal || prod instanceof model_1.Rule;\n}\nexports.isSequenceProd = isSequenceProd;\nfunction isOptionalProd(prod, alreadyVisited) {\n  if (alreadyVisited === void 0) {\n    alreadyVisited = [];\n  }\n  var isDirectlyOptional = prod instanceof model_1.Option || prod instanceof model_1.Repetition || prod instanceof model_1.RepetitionWithSeparator;\n  if (isDirectlyOptional) {\n    return true;\n  }\n  // note that this can cause infinite loop if one optional empty TOP production has a cyclic dependency with another\n  // empty optional top rule\n  // may be indirectly optional ((A?B?C?) | (D?E?F?))\n  if (prod instanceof model_1.Alternation) {\n    // for OR its enough for just one of the alternatives to be optional\n    return (0, some_1.default)(prod.definition, function (subProd) {\n      return isOptionalProd(subProd, alreadyVisited);\n    });\n  } else if (prod instanceof model_1.NonTerminal && (0, includes_1.default)(alreadyVisited, prod)) {\n    // avoiding stack overflow due to infinite recursion\n    return false;\n  } else if (prod instanceof model_1.AbstractProduction) {\n    if (prod instanceof model_1.NonTerminal) {\n      alreadyVisited.push(prod);\n    }\n    return (0, every_1.default)(prod.definition, function (subProd) {\n      return isOptionalProd(subProd, alreadyVisited);\n    });\n  } else {\n    return false;\n  }\n}\nexports.isOptionalProd = isOptionalProd;\nfunction isBranchingProd(prod) {\n  return prod instanceof model_1.Alternation;\n}\nexports.isBranchingProd = isBranchingProd;\nfunction getProductionDslName(prod) {\n  /* istanbul ignore else */\n  if (prod instanceof model_1.NonTerminal) {\n    return \"SUBRULE\";\n  } else if (prod instanceof model_1.Option) {\n    return \"OPTION\";\n  } else if (prod instanceof model_1.Alternation) {\n    return \"OR\";\n  } else if (prod instanceof model_1.RepetitionMandatory) {\n    return \"AT_LEAST_ONE\";\n  } else if (prod instanceof model_1.RepetitionMandatoryWithSeparator) {\n    return \"AT_LEAST_ONE_SEP\";\n  } else if (prod instanceof model_1.RepetitionWithSeparator) {\n    return \"MANY_SEP\";\n  } else if (prod instanceof model_1.Repetition) {\n    return \"MANY\";\n  } else if (prod instanceof model_1.Terminal) {\n    return \"CONSUME\";\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\nexports.getProductionDslName = getProductionDslName;","map":{"version":3,"names":["some_1","__importDefault","require","every_1","includes_1","model_1","isSequenceProd","prod","Alternative","Option","Repetition","RepetitionMandatory","RepetitionMandatoryWithSeparator","RepetitionWithSeparator","Terminal","Rule","exports","isOptionalProd","alreadyVisited","isDirectlyOptional","Alternation","default","definition","subProd","NonTerminal","AbstractProduction","push","isBranchingProd","getProductionDslName","Error"],"sources":["/Users/rociopichardo/Desktop/PFhenryFront/node_modules/@chevrotain/gast/src/helpers.ts"],"sourcesContent":["import some from \"lodash/some\"\nimport every from \"lodash/every\"\nimport has from \"lodash/has\"\nimport includes from \"lodash/includes\"\nimport {\n  AbstractProduction,\n  Alternation,\n  Alternative,\n  NonTerminal,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Rule,\n  Terminal\n} from \"./model\"\nimport { GAstVisitor } from \"./visitor\"\nimport { IProduction, IProductionWithOccurrence } from \"@chevrotain/types\"\n\nexport function isSequenceProd(\n  prod: IProduction\n): prod is { definition: IProduction[] } & IProduction {\n  return (\n    prod instanceof Alternative ||\n    prod instanceof Option ||\n    prod instanceof Repetition ||\n    prod instanceof RepetitionMandatory ||\n    prod instanceof RepetitionMandatoryWithSeparator ||\n    prod instanceof RepetitionWithSeparator ||\n    prod instanceof Terminal ||\n    prod instanceof Rule\n  )\n}\n\nexport function isOptionalProd(\n  prod: IProduction,\n  alreadyVisited: NonTerminal[] = []\n): boolean {\n  const isDirectlyOptional =\n    prod instanceof Option ||\n    prod instanceof Repetition ||\n    prod instanceof RepetitionWithSeparator\n  if (isDirectlyOptional) {\n    return true\n  }\n\n  // note that this can cause infinite loop if one optional empty TOP production has a cyclic dependency with another\n  // empty optional top rule\n  // may be indirectly optional ((A?B?C?) | (D?E?F?))\n  if (prod instanceof Alternation) {\n    // for OR its enough for just one of the alternatives to be optional\n    return some((<Alternation>prod).definition, (subProd: IProduction) => {\n      return isOptionalProd(subProd, alreadyVisited)\n    })\n  } else if (prod instanceof NonTerminal && includes(alreadyVisited, prod)) {\n    // avoiding stack overflow due to infinite recursion\n    return false\n  } else if (prod instanceof AbstractProduction) {\n    if (prod instanceof NonTerminal) {\n      alreadyVisited.push(prod)\n    }\n    return every(\n      (<AbstractProduction>prod).definition,\n      (subProd: IProduction) => {\n        return isOptionalProd(subProd, alreadyVisited)\n      }\n    )\n  } else {\n    return false\n  }\n}\n\nexport function isBranchingProd(\n  prod: IProduction\n): prod is { definition: IProduction[] } & IProduction {\n  return prod instanceof Alternation\n}\n\nexport function getProductionDslName(prod: IProductionWithOccurrence): string {\n  /* istanbul ignore else */\n  if (prod instanceof NonTerminal) {\n    return \"SUBRULE\"\n  } else if (prod instanceof Option) {\n    return \"OPTION\"\n  } else if (prod instanceof Alternation) {\n    return \"OR\"\n  } else if (prod instanceof RepetitionMandatory) {\n    return \"AT_LEAST_ONE\"\n  } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n    return \"AT_LEAST_ONE_SEP\"\n  } else if (prod instanceof RepetitionWithSeparator) {\n    return \"MANY_SEP\"\n  } else if (prod instanceof Repetition) {\n    return \"MANY\"\n  } else if (prod instanceof Terminal) {\n    return \"CONSUME\"\n  } else {\n    throw Error(\"non exhaustive match\")\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}