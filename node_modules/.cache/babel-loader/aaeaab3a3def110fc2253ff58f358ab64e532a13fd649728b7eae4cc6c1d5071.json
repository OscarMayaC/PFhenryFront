{"ast":null,"code":"import { Mesh, MathUtils } from 'three';\nvar MorphBlendMesh = function (geometry, material) {\n  Mesh.call(this, geometry, material);\n  this.animationsMap = {};\n  this.animationsList = []; // prepare default animation\n  // (all frames played together in 1 second)\n\n  var numFrames = Object.keys(this.morphTargetDictionary).length;\n  var name = '__default';\n  var startFrame = 0;\n  var endFrame = numFrames - 1;\n  var fps = numFrames / 1;\n  this.createAnimation(name, startFrame, endFrame, fps);\n  this.setAnimationWeight(name, 1);\n};\nMorphBlendMesh.prototype = Object.assign(Object.create(Mesh.prototype), {\n  constructor: MorphBlendMesh,\n  createAnimation: function (name, start, end, fps) {\n    var animation = {\n      start: start,\n      end: end,\n      length: end - start + 1,\n      fps: fps,\n      duration: (end - start) / fps,\n      lastFrame: 0,\n      currentFrame: 0,\n      active: false,\n      time: 0,\n      direction: 1,\n      weight: 1,\n      directionBackwards: false,\n      mirroredLoop: false\n    };\n    this.animationsMap[name] = animation;\n    this.animationsList.push(animation);\n  },\n  autoCreateAnimations: function (fps) {\n    var pattern = /([a-z]+)_?(\\d+)/i;\n    var firstAnimation,\n      frameRanges = {};\n    var i = 0;\n    for (let key in this.morphTargetDictionary) {\n      var chunks = key.match(pattern);\n      if (chunks && chunks.length > 1) {\n        var name = chunks[1];\n        if (!frameRanges[name]) frameRanges[name] = {\n          start: Infinity,\n          end: -Infinity\n        };\n        var range = frameRanges[name];\n        if (i < range.start) range.start = i;\n        if (i > range.end) range.end = i;\n        if (!firstAnimation) firstAnimation = name;\n      }\n      i++;\n    }\n    for (let name in frameRanges) {\n      var range = frameRanges[name];\n      this.createAnimation(name, range.start, range.end, fps);\n    }\n    this.firstAnimation = firstAnimation;\n  },\n  setAnimationDirectionForward: function (name) {\n    var animation = this.animationsMap[name];\n    if (animation) {\n      animation.direction = 1;\n      animation.directionBackwards = false;\n    }\n  },\n  setAnimationDirectionBackward: function (name) {\n    var animation = this.animationsMap[name];\n    if (animation) {\n      animation.direction = -1;\n      animation.directionBackwards = true;\n    }\n  },\n  setAnimationFPS: function (name, fps) {\n    var animation = this.animationsMap[name];\n    if (animation) {\n      animation.fps = fps;\n      animation.duration = (animation.end - animation.start) / animation.fps;\n    }\n  },\n  setAnimationDuration: function (name, duration) {\n    var animation = this.animationsMap[name];\n    if (animation) {\n      animation.duration = duration;\n      animation.fps = (animation.end - animation.start) / animation.duration;\n    }\n  },\n  setAnimationWeight: function (name, weight) {\n    var animation = this.animationsMap[name];\n    if (animation) {\n      animation.weight = weight;\n    }\n  },\n  setAnimationTime: function (name, time) {\n    var animation = this.animationsMap[name];\n    if (animation) {\n      animation.time = time;\n    }\n  },\n  getAnimationTime: function (name) {\n    var time = 0;\n    var animation = this.animationsMap[name];\n    if (animation) {\n      time = animation.time;\n    }\n    return time;\n  },\n  getAnimationDuration: function (name) {\n    var duration = -1;\n    var animation = this.animationsMap[name];\n    if (animation) {\n      duration = animation.duration;\n    }\n    return duration;\n  },\n  playAnimation: function (name) {\n    var animation = this.animationsMap[name];\n    if (animation) {\n      animation.time = 0;\n      animation.active = true;\n    } else {\n      console.warn('THREE.MorphBlendMesh: animation[' + name + '] undefined in .playAnimation()');\n    }\n  },\n  stopAnimation: function (name) {\n    var animation = this.animationsMap[name];\n    if (animation) {\n      animation.active = false;\n    }\n  },\n  update: function (delta) {\n    for (let i = 0, il = this.animationsList.length; i < il; i++) {\n      var animation = this.animationsList[i];\n      if (!animation.active) continue;\n      var frameTime = animation.duration / animation.length;\n      animation.time += animation.direction * delta;\n      if (animation.mirroredLoop) {\n        if (animation.time > animation.duration || animation.time < 0) {\n          animation.direction *= -1;\n          if (animation.time > animation.duration) {\n            animation.time = animation.duration;\n            animation.directionBackwards = true;\n          }\n          if (animation.time < 0) {\n            animation.time = 0;\n            animation.directionBackwards = false;\n          }\n        }\n      } else {\n        animation.time = animation.time % animation.duration;\n        if (animation.time < 0) animation.time += animation.duration;\n      }\n      var keyframe = animation.start + MathUtils.clamp(Math.floor(animation.time / frameTime), 0, animation.length - 1);\n      var weight = animation.weight;\n      if (keyframe !== animation.currentFrame) {\n        this.morphTargetInfluences[animation.lastFrame] = 0;\n        this.morphTargetInfluences[animation.currentFrame] = 1 * weight;\n        this.morphTargetInfluences[keyframe] = 0;\n        animation.lastFrame = animation.currentFrame;\n        animation.currentFrame = keyframe;\n      }\n      var mix = animation.time % frameTime / frameTime;\n      if (animation.directionBackwards) mix = 1 - mix;\n      if (animation.currentFrame !== animation.lastFrame) {\n        this.morphTargetInfluences[animation.currentFrame] = mix * weight;\n        this.morphTargetInfluences[animation.lastFrame] = (1 - mix) * weight;\n      } else {\n        this.morphTargetInfluences[animation.currentFrame] = weight;\n      }\n    }\n  }\n});\nexport { MorphBlendMesh };","map":{"version":3,"names":["Mesh","MathUtils","MorphBlendMesh","geometry","material","call","animationsMap","animationsList","numFrames","Object","keys","morphTargetDictionary","length","name","startFrame","endFrame","fps","createAnimation","setAnimationWeight","prototype","assign","create","constructor","start","end","animation","duration","lastFrame","currentFrame","active","time","direction","weight","directionBackwards","mirroredLoop","push","autoCreateAnimations","pattern","firstAnimation","frameRanges","i","key","chunks","match","Infinity","range","setAnimationDirectionForward","setAnimationDirectionBackward","setAnimationFPS","setAnimationDuration","setAnimationTime","getAnimationTime","getAnimationDuration","playAnimation","console","warn","stopAnimation","update","delta","il","frameTime","keyframe","clamp","Math","floor","morphTargetInfluences","mix"],"sources":["/Users/rociopichardo/Desktop/PFhenryFront/node_modules/three-stdlib/misc/MorphBlendMesh.js"],"sourcesContent":["import { Mesh, MathUtils } from 'three';\n\nvar MorphBlendMesh = function (geometry, material) {\n  Mesh.call(this, geometry, material);\n  this.animationsMap = {};\n  this.animationsList = []; // prepare default animation\n  // (all frames played together in 1 second)\n\n  var numFrames = Object.keys(this.morphTargetDictionary).length;\n  var name = '__default';\n  var startFrame = 0;\n  var endFrame = numFrames - 1;\n  var fps = numFrames / 1;\n  this.createAnimation(name, startFrame, endFrame, fps);\n  this.setAnimationWeight(name, 1);\n};\n\nMorphBlendMesh.prototype = Object.assign(Object.create(Mesh.prototype), {\n  constructor: MorphBlendMesh,\n  createAnimation: function (name, start, end, fps) {\n    var animation = {\n      start: start,\n      end: end,\n      length: end - start + 1,\n      fps: fps,\n      duration: (end - start) / fps,\n      lastFrame: 0,\n      currentFrame: 0,\n      active: false,\n      time: 0,\n      direction: 1,\n      weight: 1,\n      directionBackwards: false,\n      mirroredLoop: false\n    };\n    this.animationsMap[name] = animation;\n    this.animationsList.push(animation);\n  },\n  autoCreateAnimations: function (fps) {\n    var pattern = /([a-z]+)_?(\\d+)/i;\n    var firstAnimation,\n        frameRanges = {};\n    var i = 0;\n\n    for (let key in this.morphTargetDictionary) {\n      var chunks = key.match(pattern);\n\n      if (chunks && chunks.length > 1) {\n        var name = chunks[1];\n        if (!frameRanges[name]) frameRanges[name] = {\n          start: Infinity,\n          end: -Infinity\n        };\n        var range = frameRanges[name];\n        if (i < range.start) range.start = i;\n        if (i > range.end) range.end = i;\n        if (!firstAnimation) firstAnimation = name;\n      }\n\n      i++;\n    }\n\n    for (let name in frameRanges) {\n      var range = frameRanges[name];\n      this.createAnimation(name, range.start, range.end, fps);\n    }\n\n    this.firstAnimation = firstAnimation;\n  },\n  setAnimationDirectionForward: function (name) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.direction = 1;\n      animation.directionBackwards = false;\n    }\n  },\n  setAnimationDirectionBackward: function (name) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.direction = -1;\n      animation.directionBackwards = true;\n    }\n  },\n  setAnimationFPS: function (name, fps) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.fps = fps;\n      animation.duration = (animation.end - animation.start) / animation.fps;\n    }\n  },\n  setAnimationDuration: function (name, duration) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.duration = duration;\n      animation.fps = (animation.end - animation.start) / animation.duration;\n    }\n  },\n  setAnimationWeight: function (name, weight) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.weight = weight;\n    }\n  },\n  setAnimationTime: function (name, time) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.time = time;\n    }\n  },\n  getAnimationTime: function (name) {\n    var time = 0;\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      time = animation.time;\n    }\n\n    return time;\n  },\n  getAnimationDuration: function (name) {\n    var duration = -1;\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      duration = animation.duration;\n    }\n\n    return duration;\n  },\n  playAnimation: function (name) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.time = 0;\n      animation.active = true;\n    } else {\n      console.warn('THREE.MorphBlendMesh: animation[' + name + '] undefined in .playAnimation()');\n    }\n  },\n  stopAnimation: function (name) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.active = false;\n    }\n  },\n  update: function (delta) {\n    for (let i = 0, il = this.animationsList.length; i < il; i++) {\n      var animation = this.animationsList[i];\n      if (!animation.active) continue;\n      var frameTime = animation.duration / animation.length;\n      animation.time += animation.direction * delta;\n\n      if (animation.mirroredLoop) {\n        if (animation.time > animation.duration || animation.time < 0) {\n          animation.direction *= -1;\n\n          if (animation.time > animation.duration) {\n            animation.time = animation.duration;\n            animation.directionBackwards = true;\n          }\n\n          if (animation.time < 0) {\n            animation.time = 0;\n            animation.directionBackwards = false;\n          }\n        }\n      } else {\n        animation.time = animation.time % animation.duration;\n        if (animation.time < 0) animation.time += animation.duration;\n      }\n\n      var keyframe = animation.start + MathUtils.clamp(Math.floor(animation.time / frameTime), 0, animation.length - 1);\n      var weight = animation.weight;\n\n      if (keyframe !== animation.currentFrame) {\n        this.morphTargetInfluences[animation.lastFrame] = 0;\n        this.morphTargetInfluences[animation.currentFrame] = 1 * weight;\n        this.morphTargetInfluences[keyframe] = 0;\n        animation.lastFrame = animation.currentFrame;\n        animation.currentFrame = keyframe;\n      }\n\n      var mix = animation.time % frameTime / frameTime;\n      if (animation.directionBackwards) mix = 1 - mix;\n\n      if (animation.currentFrame !== animation.lastFrame) {\n        this.morphTargetInfluences[animation.currentFrame] = mix * weight;\n        this.morphTargetInfluences[animation.lastFrame] = (1 - mix) * weight;\n      } else {\n        this.morphTargetInfluences[animation.currentFrame] = weight;\n      }\n    }\n  }\n});\n\nexport { MorphBlendMesh };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}