import _createClass from "@babel/runtime/helpers/esm/createClass";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/* eslint-disable class-methods-use-this */
import BaseAdapterMomentJalaali from '@date-io/jalaali';
// From https://momentjs.com/docs/#/displaying/format/
var formatTokenMap = {
  // Year
  jYY: 'year',
  jYYYY: 'year',
  // Month
  jM: 'month',
  jMM: 'month',
  jMMM: {
    sectionType: 'month',
    contentType: 'letter'
  },
  jMMMM: {
    sectionType: 'month',
    contentType: 'letter'
  },
  // Day of the month
  jD: 'day',
  jDD: 'day',
  // Meridiem
  A: 'meridiem',
  a: 'meridiem',
  // Hours
  H: 'hours',
  HH: 'hours',
  h: 'hours',
  hh: 'hours',
  k: 'hours',
  kk: 'hours',
  // Minutes
  m: 'minutes',
  mm: 'minutes',
  // Seconds
  s: 'seconds',
  ss: 'seconds'
};
export var AdapterMomentJalaali = /*#__PURE__*/function (_BaseAdapterMomentJal) {
  _inherits(AdapterMomentJalaali, _BaseAdapterMomentJal);
  var _super = _createSuper(AdapterMomentJalaali);
  function AdapterMomentJalaali() {
    var _this;
    _classCallCheck(this, AdapterMomentJalaali);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _this.isMUIAdapter = true;
    _this.formatTokenMap = formatTokenMap;
    _this.escapedCharacters = {
      start: '[',
      end: ']'
    };
    /**
     * The current getFormatHelperText method uses an outdated format parsing logic.
     * We should use this one in the future to support all localized formats.
     */
    _this.expandFormat = function (format) {
      // @see https://github.com/moment/moment/blob/develop/src/lib/format/format.js#L6
      var localFormattingTokens = /(\[[^[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})|./g;
      return format.match(localFormattingTokens).map(function (token) {
        var firstCharacter = token[0];
        if (firstCharacter === 'L' || firstCharacter === ';') {
          return _this.moment.localeData(_this.getCurrentLocaleCode()).longDateFormat(token);
        }
        return token;
      }).join('').replace('dd', 'jDD'); // Fix for https://github.com/dmtrKovalenko/date-io/pull/632;
    };
    // Redefined here just to show how it can be written using expandFormat
    _this.getFormatHelperText = function (format) {
      return _this.expandFormat(format).replace(/a/gi, '(a|p)m').replace('jY', 'Y').replace('jM', 'M').replace('jD', 'D').toLocaleLowerCase();
    };
    _this.getWeekNumber = function (date) {
      return date.jWeek();
    };
    _this.addYears = function (date, count) {
      return count < 0 ? date.clone().subtract(Math.abs(count), 'jYear') : date.clone().add(count, 'jYear');
    };
    _this.addMonths = function (date, count) {
      return count < 0 ? date.clone().subtract(Math.abs(count), 'jMonth') : date.clone().add(count, 'jMonth');
    };
    _this.setMonth = function (date, month) {
      return date.clone().jMonth(month);
    };
    _this.isValid = function (value) {
      // We can't to `this.moment(value)` because moment-jalaali looses the invalidity information when creating a new moment object from an existing one
      if (!_this.moment.isMoment(value)) {
        return false;
      }
      return value.isValid(value);
    };
    return _this;
  }
  return _createClass(AdapterMomentJalaali);
}(BaseAdapterMomentJalaali);