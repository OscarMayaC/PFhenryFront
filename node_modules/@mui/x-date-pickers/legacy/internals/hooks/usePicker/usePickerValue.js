import _extends from "@babel/runtime/helpers/esm/extends";
import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import * as React from 'react';
import { unstable_useControlled as useControlled } from '@mui/utils';
import useEventCallback from '@mui/utils/useEventCallback';
import { useOpenState } from '../useOpenState';
import { useLocalizationContext, useUtils } from '../useUtils';
import { useValidation } from '../validation/useValidation';
/**
 * Manage the value lifecycle of all the pickers.
 */
export var usePickerValue = function usePickerValue(_ref) {
  var props = _ref.props,
    valueManager = _ref.valueManager,
    wrapperVariant = _ref.wrapperVariant,
    validator = _ref.validator;
  var onAcceptProp = props.onAccept,
    onChange = props.onChange,
    inValue = props.value,
    defaultValue = props.defaultValue,
    _props$closeOnSelect = props.closeOnSelect,
    closeOnSelect = _props$closeOnSelect === void 0 ? wrapperVariant === 'desktop' : _props$closeOnSelect,
    selectedSectionsProp = props.selectedSections,
    onSelectedSectionsChange = props.onSelectedSectionsChange;
  var utils = useUtils();
  var adapter = useLocalizationContext();
  var _useControlled = useControlled({
      controlled: inValue,
      default: defaultValue != null ? defaultValue : valueManager.emptyValue,
      name: 'usePickerValue',
      state: 'value'
    }),
    _useControlled2 = _slicedToArray(_useControlled, 2),
    value = _useControlled2[0],
    setValue = _useControlled2[1];
  var _useControlled3 = useControlled({
      controlled: selectedSectionsProp,
      default: null,
      name: 'usePickerValue',
      state: 'selectedSections'
    }),
    _useControlled4 = _slicedToArray(_useControlled3, 2),
    selectedSections = _useControlled4[0],
    setSelectedSections = _useControlled4[1];
  var _useOpenState = useOpenState(props),
    isOpen = _useOpenState.isOpen,
    setIsOpen = _useOpenState.setIsOpen;
  var _React$useState = React.useState(function () {
      return {
        committed: value,
        draft: value,
        resetFallback: value
      };
    }),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    dateState = _React$useState2[0],
    setDateState = _React$useState2[1];
  useValidation(_extends({}, props, {
    value: value
  }), validator, valueManager.isSameError, valueManager.defaultErrorState);
  var setDate = useEventCallback(function (params) {
    setDateState(function (prev) {
      switch (params.action) {
        case 'setAll':
        case 'acceptAndClose':
          {
            return {
              draft: params.value,
              committed: params.value,
              resetFallback: params.value
            };
          }
        case 'setCommitted':
          {
            return _extends({}, prev, {
              draft: params.value,
              committed: params.value
            });
          }
        case 'setDraft':
          {
            return _extends({}, prev, {
              draft: params.value
            });
          }
        default:
          {
            return prev;
          }
      }
    });
    if (!params.skipOnChangeCall && !valueManager.areValuesEqual(utils, dateState.committed, params.value)) {
      setValue(params.value);
      if (onChange) {
        var _context = {
          validationError: params.contextFromField == null ? validator({
            adapter: adapter,
            value: params.value,
            props: _extends({}, props, {
              value: params.value
            })
          }) : params.contextFromField.validationError
        };
        onChange(params.value, _context);
      }
    }
    if (params.action === 'acceptAndClose') {
      setIsOpen(false);
      if (onAcceptProp && !valueManager.areValuesEqual(utils, dateState.resetFallback, params.value)) {
        onAcceptProp(params.value);
      }
    }
  });
  React.useEffect(function () {
    if (isOpen) {
      // Update all dates in state to equal the current prop value
      setDate({
        action: 'setAll',
        value: value,
        skipOnChangeCall: true
      });
    }
  }, [isOpen]); // eslint-disable-line react-hooks/exhaustive-deps

  // Set the draft and committed date to equal the new prop value.
  if (!valueManager.areValuesEqual(utils, dateState.committed, value)) {
    setDate({
      action: 'setCommitted',
      value: value,
      skipOnChangeCall: true
    });
  }
  var handleClear = useEventCallback(function () {
    // Reset all date in state to the empty value and close picker.
    setDate({
      value: valueManager.emptyValue,
      action: 'acceptAndClose'
    });
  });
  var handleAccept = useEventCallback(function () {
    // Set all date in state to equal the current draft value and close picker.
    setDate({
      value: dateState.draft,
      action: 'acceptAndClose'
    });
  });
  var handleDismiss = useEventCallback(function () {
    // Set all dates in state to equal the last committed date.
    // e.g. Reset the state to the last committed value.
    setDate({
      value: dateState.committed,
      action: 'acceptAndClose'
    });
  });
  var handleCancel = useEventCallback(function () {
    // Set all dates in state to equal the last accepted date and close picker.
    // e.g. Reset the state to the last accepted value
    setDate({
      value: dateState.resetFallback,
      action: 'acceptAndClose'
    });
  });
  var handleSetToday = useEventCallback(function () {
    // Set all dates in state to equal today and close picker.
    setDate({
      value: valueManager.getTodayValue(utils),
      action: 'acceptAndClose'
    });
  });
  var handleOpen = useEventCallback(function () {
    return setIsOpen(true);
  });
  var handleClose = useEventCallback(function () {
    return setIsOpen(false);
  });
  var handleChange = useEventCallback(function (newDate) {
    var selectionState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'partial';
    switch (selectionState) {
      case 'shallow':
        {
          // Update the `draft` state but do not fire `onChange`
          return setDate({
            action: 'setDraft',
            value: newDate,
            skipOnChangeCall: true
          });
        }
      case 'partial':
        {
          // Update the `draft` state and fire `onChange`
          return setDate({
            action: 'setDraft',
            value: newDate
          });
        }
      case 'finish':
        {
          if (closeOnSelect) {
            // Set all dates in state to equal the new date and close picker.
            return setDate({
              value: newDate,
              action: 'acceptAndClose'
            });
          }

          // Updates the `committed` state and fire `onChange`
          return setDate({
            value: newDate,
            action: 'setCommitted'
          });
        }
      default:
        {
          throw new Error('MUI: Invalid selectionState passed to `onDateChange`');
        }
    }
  });
  var handleChangeAndCommit = useEventCallback(function (newValue, contextFromField) {
    return setDate({
      action: 'setCommitted',
      value: newValue,
      contextFromField: contextFromField
    });
  });
  var handleFieldSelectedSectionsChange = useEventCallback(function (newSelectedSections) {
    setSelectedSections(newSelectedSections);
    onSelectedSectionsChange == null ? void 0 : onSelectedSectionsChange(newSelectedSections);
  });
  var actions = {
    onClear: handleClear,
    onAccept: handleAccept,
    onDismiss: handleDismiss,
    onCancel: handleCancel,
    onSetToday: handleSetToday,
    onOpen: handleOpen,
    onClose: handleClose
  };
  var fieldResponse = {
    value: dateState.draft,
    onChange: handleChangeAndCommit,
    selectedSections: selectedSections,
    onSelectedSectionsChange: handleFieldSelectedSectionsChange
  };
  var viewValue = React.useMemo(function () {
    return valueManager.cleanValue(utils, dateState.draft);
  }, [utils, valueManager, dateState.draft]);
  var viewResponse = {
    value: viewValue,
    onChange: handleChange,
    onClose: handleClose,
    open: isOpen,
    onSelectedSectionsChange: handleFieldSelectedSectionsChange
  };
  var isValid = function isValid(testedValue) {
    var validationResponse = validator({
      adapter: adapter,
      value: testedValue,
      props: _extends({}, props, {
        value: testedValue
      })
    });
    return Array.isArray(testedValue) ? validationResponse.every(function (v) {
      return v === null;
    }) : validationResponse === null;
  };
  var layoutResponse = _extends({}, actions, {
    value: viewValue,
    onChange: handleChangeAndCommit,
    isValid: isValid
  });
  return {
    open: isOpen,
    fieldProps: fieldResponse,
    viewProps: viewResponse,
    layoutProps: layoutResponse,
    actions: actions
  };
};