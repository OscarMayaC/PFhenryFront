{"version":3,"file":"ndarray-lanczos.modern.js","sources":["../vendor/filters.ts","../src/convolve.ts","../src/index.ts"],"sourcesContent":["const fixedFracBits = 14\n\nconst filterValue = ( x: number, a: 2 | 3 ) => {\n\tif ( x <= -a || x >= a ) return 0\n\n\t// appears to do nothing?\n\t// if ( x > -1.19209290e-07 && x < 1.19209290e-07 ) return 1\n\n\tconst xPi = x * Math.PI\n\n\treturn ( Math.sin( xPi ) / xPi ) * Math.sin( xPi / a ) / ( xPi / a )\n}\n\nconst toFixedPoint = ( value: number ) =>\nMath.round( value * ( ( 1 << fixedFracBits ) - 1 ) )\n\nexport const filters = ( srcSize: number, destSize: number, scale: number, offset: number, use2: boolean ) => {\n\tconst a = use2 ? 2 : 3\n\tconst scaleInverted = 1 / scale\n\tconst scaleClamped = Math.min( 1, scale ) // For upscale\n\n\t// Filter window (averaging interval), scaled to src image\n\tconst srcWindow = a / scaleClamped\n\n\tconst maxFilterElementSize = Math.floor( ( srcWindow + 1 ) * 2 )\n\tconst packedFilter = new Int16Array( ( maxFilterElementSize + 2 ) * destSize )\n\tlet packedFilterPtr = 0\n\n\t// For each destination pixel calculate source range and built filter values\n\tfor ( let destPixel = 0; destPixel < destSize; destPixel++ ) {\n\n\t\t// Scaling should be done relative to central pixel point\n\t\tconst sourcePixel = ( destPixel + 0.5 ) * scaleInverted + offset\n\t\tconst sourceFirst = Math.max( 0, Math.floor( sourcePixel - srcWindow ) )\n\t\tconst sourceLast = Math.min( srcSize - 1, Math.ceil( sourcePixel + srcWindow ) )\n\n\t\tconst filterElementSize = sourceLast - sourceFirst + 1\n\t\tconst floatFilter = new Float32Array( filterElementSize )\n\t\tconst fxpFilter = new Int16Array( filterElementSize )\n\n\t\tlet total = 0\n\n\t\t// Fill filter values for calculated range\n\t\tlet index = 0\n\t\tfor ( let pixel = sourceFirst; pixel <= sourceLast; pixel++ ) {\n\t\t\tconst floatValue = filterValue( ( ( pixel + 0.5 ) - sourcePixel ) * scaleClamped, a )\n\n\t\t\ttotal += floatValue\n\t\t\tfloatFilter[ index ] = floatValue\n\n\t\t\tindex++\n\t\t}\n\n\t\t// Normalize filter, convert to fixed point and accumulate conversion error\n\t\tlet filterTotal = 0\n\n\t\tfor ( let index = 0; index < floatFilter.length; index++ ) {\n\t\t\tconst filterValue = floatFilter[ index ] / total\n\n\t\t\tfilterTotal += filterValue\n\t\t\tfxpFilter[ index ] = toFixedPoint( filterValue )\n\t\t}\n\n\t\t// Compensate normalization error, to minimize brightness drift\n\t\tfxpFilter[ destSize >> 1 ] += toFixedPoint( 1 - filterTotal )\n\n\t\t//\n\t\t// Now pack filter to useable form\n\t\t//\n\t\t// 1. Trim heading and tailing zero values, and compensate shitf/length\n\t\t// 2. Put all to single array in this format:\n\t\t//\n\t\t//    [ pos shift, data length, value1, value2, value3, ... ]\n\t\t//\n\t\tlet leftNotEmpty = 0\n\t\twhile ( leftNotEmpty < fxpFilter.length && fxpFilter[ leftNotEmpty ] === 0 ) {\n\t\t\tleftNotEmpty++\n\t\t}\n\n\t\tlet rightNotEmpty = fxpFilter.length - 1\n\t\twhile ( rightNotEmpty > 0 && fxpFilter[ rightNotEmpty ] === 0 ) {\n\t\t\trightNotEmpty--\n\t\t}\n\n\t\tconst filterShift = sourceFirst + leftNotEmpty\n\t\tconst filterSize = rightNotEmpty - leftNotEmpty + 1\n\n\t\tpackedFilter[ packedFilterPtr++ ] = filterShift // shift\n\t\tpackedFilter[ packedFilterPtr++ ] = filterSize // size\n\n\t\tpackedFilter.set( fxpFilter.subarray( leftNotEmpty, rightNotEmpty + 1 ), packedFilterPtr )\n\t\tpackedFilterPtr += filterSize\n\t}\n\n\treturn packedFilter\n}\n","import type { NdArray } from 'ndarray';\n\nconst fixedFracBits = 14;\n\nconst clamp = (v: number): number => v < 0 ? 0 : (v > 255 ? 255 : v);\n\nexport const convolve = (src: NdArray, dst: NdArray, filters: Int16Array) => {\n\tconst [_, srcHeight] = src.shape;\n\tconst [dstWidth] = dst.shape;\n\n\t// For each row\n\tfor (let srcY = 0; srcY < srcHeight; srcY++) {\n\t\tconst dstY = srcY;\n\n\t\t// Apply precomputed filters to each destination row point\n\t\tlet filterPtr = 0;\n\t\tfor (let dstX = 0; dstX < dstWidth; dstX++) {\n\t\t\t// Get the filter that determines the current output pixel.\n\t\t\tlet srcX = filters[filterPtr++];\n\n\t\t\tlet r = 0;\n\t\t\tlet g = 0;\n\t\t\tlet b = 0;\n\t\t\tlet a = 0;\n\n\t\t\t// Apply the filter to the row to get the destination pixel r, g, b, a\n\t\t\tfor (let filterSize = filters[filterPtr++]; filterSize > 0; filterSize--) {\n\t\t\t\tconst filterValue = filters[filterPtr++];\n\n\t\t\t\tr = ( r + filterValue * src.get(srcX, srcY, 0) );\n\t\t\t\tg = ( g + filterValue * src.get(srcX, srcY, 1) );\n\t\t\t\tb = ( b + filterValue * src.get(srcX, srcY, 2) );\n\t\t\t\ta = ( a + filterValue * src.get(srcX, srcY, 3) );\n\n\t\t\t\tsrcX++;\n\t\t\t}\n\n\t\t\t// Bring this value back in range. All of the filter scaling factors\n\t\t\t// are in fixed point with fixedFracBits bits of fractional part.\n\t\t\t//\n\t\t\t// (!) Add 1/2 of value before clamping to get proper rounding. In other\n\t\t\t// case brightness loss will be noticeable if you resize image with white\n\t\t\t// border and place it on white background.\n\t\t\tdst.set(dstX, dstY, 0, clamp( ( r + ( 1 << 13 ) ) >> fixedFracBits ) );\n\t\t\tdst.set(dstX, dstY, 1, clamp( ( g + ( 1 << 13 ) ) >> fixedFracBits ) );\n\t\t\tdst.set(dstX, dstY, 2, clamp( ( b + ( 1 << 13 ) ) >> fixedFracBits ) );\n\t\t\tdst.set(dstX, dstY, 3, clamp( ( a + ( 1 << 13 ) ) >> fixedFracBits ) );\n\t\t}\n\t}\n}\n","import ndarray, { NdArray } from 'ndarray';\nimport { filters } from '../vendor/filters';\nimport { convolve } from './convolve';\n\nenum Method {\n\tLANCZOS_3 = 3,\n\tLANCZOS_2 = 2,\n}\n\nfunction resize(src: NdArray, dst: NdArray, method: Method): void {\n\tconst [srcWidth, srcHeight] = src.shape;\n\tconst [dstWidth, dstHeight] = dst.shape;\n\n\tconst ratioX = dstWidth / srcWidth;\n\tconst ratioY = dstHeight / srcHeight;\n\n\tconst filtersX = filters(srcWidth, dstWidth, ratioX, 0, method === Method.LANCZOS_2);\n\tconst filtersY = filters(srcHeight, dstHeight, ratioY, 0, method === Method.LANCZOS_2);\n\n\tconst tmp = ndarray(new Uint8Array(dstWidth * srcHeight * 4), [srcHeight, dstWidth, 4]);\n\tconst tmpTranspose = tmp.transpose(1, 0);\n\tconst dstTranspose = dst.transpose(1, 0);\n\n\tconvolve(src, tmpTranspose, filtersX);\n\tconvolve(tmp, dstTranspose, filtersY);\n}\n\nexport function lanczos3(src: NdArray, dst: NdArray): void {\n\tresize(src, dst, Method.LANCZOS_3);\n}\n\nexport function lanczos2(src: NdArray, dst: NdArray): void {\n\tresize(src, dst, Method.LANCZOS_2);\n}\n"],"names":["filterValue","x","a","xPi","Math","PI","sin","toFixedPoint","value","round","filters","srcSize","destSize","scale","offset","use2","scaleInverted","scaleClamped","min","srcWindow","maxFilterElementSize","floor","packedFilter","Int16Array","packedFilterPtr","destPixel","sourcePixel","sourceFirst","max","sourceLast","ceil","filterElementSize","floatFilter","Float32Array","fxpFilter","total","index","pixel","floatValue","filterTotal","length","leftNotEmpty","rightNotEmpty","filterSize","set","subarray","clamp","v","convolve","src","dst","_","srcHeight","shape","dstWidth","srcY","dstY","filterPtr","dstX","srcX","r","g","b","get","Method","resize","method","srcWidth","dstHeight","ratioY","filtersX","LANCZOS_2","filtersY","tmp","ndarray","Uint8Array","tmpTranspose","transpose","dstTranspose","lanczos3","LANCZOS_3","lanczos2"],"mappings":"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"}