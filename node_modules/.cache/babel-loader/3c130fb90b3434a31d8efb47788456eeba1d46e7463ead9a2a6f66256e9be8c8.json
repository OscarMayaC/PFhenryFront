{"ast":null,"code":"import { BufferGeometry, BufferAttribute, InterleavedBuffer, InterleavedBufferAttribute, TrianglesDrawMode, TriangleFanDrawMode, TriangleStripDrawMode, Vector3, Float32BufferAttribute } from 'three';\nimport { getWithKey } from '../types/helpers.js';\n\n/**\n * @param  {Array<BufferGeometry>} geometries\n * @param  {Boolean} useGroups\n * @return {BufferGeometry}\n */\nconst mergeBufferGeometries = (geometries, useGroups) => {\n  const isIndexed = geometries[0].index !== null;\n  const attributesUsed = new Set(Object.keys(geometries[0].attributes));\n  const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\n  const attributes = {};\n  const morphAttributes = {};\n  const morphTargetsRelative = geometries[0].morphTargetsRelative;\n  const mergedGeometry = new BufferGeometry();\n  let offset = 0;\n  geometries.forEach((geom, i) => {\n    let attributesCount = 0; // ensure that all geometries are indexed, or none\n\n    if (isIndexed !== (geom.index !== null)) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.');\n      return null;\n    } // gather attributes, exit early if they're different\n\n    for (let name in geom.attributes) {\n      if (!attributesUsed.has(name)) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.');\n        return null;\n      }\n      if (attributes[name] === undefined) {\n        attributes[name] = [];\n      }\n      attributes[name].push(geom.attributes[name]);\n      attributesCount++;\n    } // ensure geometries have the same number of attributes\n\n    if (attributesCount !== attributesUsed.size) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.');\n      return null;\n    } // gather morph attributes, exit early if they're different\n\n    if (morphTargetsRelative !== geom.morphTargetsRelative) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.');\n      return null;\n    }\n    for (let name in geom.morphAttributes) {\n      if (!morphAttributesUsed.has(name)) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.');\n        return null;\n      }\n      if (morphAttributes[name] === undefined) morphAttributes[name] = [];\n      morphAttributes[name].push(geom.morphAttributes[name]);\n    } // gather .userData\n\n    mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n    mergedGeometry.userData.mergedUserData.push(geom.userData);\n    if (useGroups) {\n      let count;\n      if (geom.index) {\n        count = geom.index.count;\n      } else if (geom.attributes.position !== undefined) {\n        count = geom.attributes.position.count;\n      } else {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute');\n        return null;\n      }\n      mergedGeometry.addGroup(offset, count, i);\n      offset += count;\n    }\n  }); // merge indices\n\n  if (isIndexed) {\n    let indexOffset = 0;\n    const mergedIndex = [];\n    geometries.forEach(geom => {\n      const index = geom.index;\n      for (let j = 0; j < index.count; ++j) {\n        mergedIndex.push(index.getX(j) + indexOffset);\n      }\n      indexOffset += geom.attributes.position.count;\n    });\n    mergedGeometry.setIndex(mergedIndex);\n  } // merge attributes\n\n  for (let name in attributes) {\n    const mergedAttribute = mergeBufferAttributes(attributes[name]);\n    if (!mergedAttribute) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' attribute.');\n      return null;\n    }\n    mergedGeometry.setAttribute(name, mergedAttribute);\n  } // merge morph attributes\n\n  for (let name in morphAttributes) {\n    const numMorphTargets = morphAttributes[name][0].length;\n    if (numMorphTargets === 0) break;\n    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n    mergedGeometry.morphAttributes[name] = [];\n    for (let i = 0; i < numMorphTargets; ++i) {\n      const morphAttributesToMerge = [];\n      for (let j = 0; j < morphAttributes[name].length; ++j) {\n        morphAttributesToMerge.push(morphAttributes[name][j][i]);\n      }\n      const mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge);\n      if (!mergedMorphAttribute) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' morphAttribute.');\n        return null;\n      }\n      mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);\n    }\n  }\n  return mergedGeometry;\n};\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {BufferAttribute}\n */\n\nconst mergeBufferAttributes = attributes => {\n  let TypedArray = undefined;\n  let itemSize = undefined;\n  let normalized = undefined;\n  let arrayLength = 0;\n  attributes.forEach(attr => {\n    if (TypedArray === undefined) {\n      TypedArray = attr.array.constructor;\n    }\n    if (TypedArray !== attr.array.constructor) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.');\n      return null;\n    }\n    if (itemSize === undefined) itemSize = attr.itemSize;\n    if (itemSize !== attr.itemSize) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.');\n      return null;\n    }\n    if (normalized === undefined) normalized = attr.normalized;\n    if (normalized !== attr.normalized) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.');\n      return null;\n    }\n    arrayLength += attr.array.length;\n  });\n  if (TypedArray && itemSize) {\n    // @ts-expect-error this works in JS and TS is complaining but it's such a tiny thing I can live with the guilt\n    const array = new TypedArray(arrayLength);\n    let offset = 0;\n    attributes.forEach(attr => {\n      array.set(attr.array, offset);\n      offset += attr.array.length;\n    });\n    return new BufferAttribute(array, itemSize, normalized);\n  }\n};\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {Array<InterleavedBufferAttribute>}\n */\n\nconst interleaveAttributes = attributes => {\n  // Interleaves the provided attributes into an InterleavedBuffer and returns\n  // a set of InterleavedBufferAttributes for each attribute\n  let TypedArray = undefined;\n  let arrayLength = 0;\n  let stride = 0; // calculate the the length and type of the interleavedBuffer\n\n  for (let i = 0, l = attributes.length; i < l; ++i) {\n    const attribute = attributes[i];\n    if (TypedArray === undefined) TypedArray = attribute.array.constructor;\n    if (TypedArray !== attribute.array.constructor) {\n      console.error('AttributeBuffers of different types cannot be interleaved');\n      return null;\n    }\n    arrayLength += attribute.array.length;\n    stride += attribute.itemSize;\n  } // Create the set of buffer attributes\n  // @ts-expect-error this works in JS and TS is complaining but it's such a tiny thing I can live with the guilt\n\n  const interleavedBuffer = new InterleavedBuffer(new TypedArray(arrayLength), stride);\n  let offset = 0;\n  const res = [];\n  const getters = ['getX', 'getY', 'getZ', 'getW'];\n  const setters = ['setX', 'setY', 'setZ', 'setW'];\n  for (let j = 0, l = attributes.length; j < l; j++) {\n    const attribute = attributes[j];\n    const itemSize = attribute.itemSize;\n    const count = attribute.count;\n    const iba = new InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized);\n    res.push(iba);\n    offset += itemSize; // Move the data for each attribute into the new interleavedBuffer\n    // at the appropriate offset\n\n    for (let c = 0; c < count; c++) {\n      for (let k = 0; k < itemSize; k++) {\n        const set = getWithKey(iba, setters[k]);\n        const get = getWithKey(attribute, getters[k]);\n        set(c, get(c));\n      }\n    }\n  }\n  return res;\n};\n/**\n * @param {Array<BufferGeometry>} geometry\n * @return {number}\n */\n\nfunction estimateBytesUsed(geometry) {\n  // Return the estimated memory used by this geometry in bytes\n  // Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n  // for InterleavedBufferAttributes.\n  let mem = 0;\n  for (let name in geometry.attributes) {\n    const attr = geometry.getAttribute(name);\n    mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n  }\n  const indices = geometry.getIndex();\n  mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n  return mem;\n}\n/**\n * @param {BufferGeometry} geometry\n * @param {number} tolerance\n * @return {BufferGeometry>}\n */\n\nfunction mergeVertices(geometry) {\n  let tolerance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1e-4;\n  tolerance = Math.max(tolerance, Number.EPSILON); // Generate an index buffer if the geometry doesn't have one, or optimize it\n  // if it's already available.\n\n  const hashToIndex = {};\n  const indices = geometry.getIndex();\n  const positions = geometry.getAttribute('position');\n  const vertexCount = indices ? indices.count : positions.count; // next value for triangle indices\n\n  let nextIndex = 0; // attributes and new attribute arrays\n\n  const attributeNames = Object.keys(geometry.attributes);\n  const attrArrays = {};\n  const morphAttrsArrays = {};\n  const newIndices = [];\n  const getters = ['getX', 'getY', 'getZ', 'getW']; // initialize the arrays\n\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    attrArrays[name] = [];\n    const morphAttr = geometry.morphAttributes[name];\n    if (morphAttr) {\n      morphAttrsArrays[name] = new Array(morphAttr.length).fill(0).map(() => []);\n    }\n  } // convert the error tolerance to an amount of decimal places to truncate to\n\n  const decimalShift = Math.log10(1 / tolerance);\n  const shiftMultiplier = Math.pow(10, decimalShift);\n  for (let i = 0; i < vertexCount; i++) {\n    const index = indices ? indices.getX(i) : i; // Generate a hash for the vertex attributes at the current index 'i'\n\n    let hash = '';\n    for (let j = 0, l = attributeNames.length; j < l; j++) {\n      const name = attributeNames[j];\n      const attribute = geometry.getAttribute(name);\n      const itemSize = attribute.itemSize;\n      for (let k = 0; k < itemSize; k++) {\n        // double tilde truncates the decimal value\n        // @ts-ignore no\n        hash += `${~~(attribute[getters[k]](index) * shiftMultiplier)},`;\n      }\n    } // Add another reference to the vertex if it's already\n    // used by another index\n\n    if (hash in hashToIndex) {\n      newIndices.push(hashToIndex[hash]);\n    } else {\n      // copy data to the new index in the attribute arrays\n      for (let j = 0, l = attributeNames.length; j < l; j++) {\n        const name = attributeNames[j];\n        const attribute = geometry.getAttribute(name);\n        const morphAttr = geometry.morphAttributes[name];\n        const itemSize = attribute.itemSize;\n        const newarray = attrArrays[name];\n        const newMorphArrays = morphAttrsArrays[name];\n        for (let k = 0; k < itemSize; k++) {\n          const getterFunc = getters[k]; // @ts-ignore\n\n          newarray.push(attribute[getterFunc](index));\n          if (morphAttr) {\n            for (let m = 0, ml = morphAttr.length; m < ml; m++) {\n              // @ts-ignore\n              newMorphArrays[m].push(morphAttr[m][getterFunc](index));\n            }\n          }\n        }\n      }\n      hashToIndex[hash] = nextIndex;\n      newIndices.push(nextIndex);\n      nextIndex++;\n    }\n  } // Generate typed arrays from new attribute arrays and update\n  // the attributeBuffers\n\n  const result = geometry.clone();\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    const oldAttribute = geometry.getAttribute(name); //@ts-expect-error  something to do with functions and constructors and new\n\n    const buffer = new oldAttribute.array.constructor(attrArrays[name]);\n    const attribute = new BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized);\n    result.setAttribute(name, attribute); // Update the attribute arrays\n\n    if (name in morphAttrsArrays) {\n      for (let j = 0; j < morphAttrsArrays[name].length; j++) {\n        const oldMorphAttribute = geometry.morphAttributes[name][j]; //@ts-expect-error something to do with functions and constructors and new\n\n        const buffer = new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j]);\n        const morphAttribute = new BufferAttribute(buffer, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);\n        result.morphAttributes[name][j] = morphAttribute;\n      }\n    }\n  } // indices\n\n  result.setIndex(newIndices);\n  return result;\n}\n/**\n * @param {BufferGeometry} geometry\n * @param {number} drawMode\n * @return {BufferGeometry}\n */\n\nfunction toTrianglesDrawMode(geometry, drawMode) {\n  if (drawMode === TrianglesDrawMode) {\n    console.warn('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.');\n    return geometry;\n  }\n  if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {\n    let index = geometry.getIndex(); // generate index if not present\n\n    if (index === null) {\n      const indices = [];\n      const position = geometry.getAttribute('position');\n      if (position !== undefined) {\n        for (let i = 0; i < position.count; i++) {\n          indices.push(i);\n        }\n        geometry.setIndex(indices);\n        index = geometry.getIndex();\n      } else {\n        console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.');\n        return geometry;\n      }\n    } //\n\n    const numberOfTriangles = index.count - 2;\n    const newIndices = [];\n    if (index) {\n      if (drawMode === TriangleFanDrawMode) {\n        // gl.TRIANGLE_FAN\n        for (let i = 1; i <= numberOfTriangles; i++) {\n          newIndices.push(index.getX(0));\n          newIndices.push(index.getX(i));\n          newIndices.push(index.getX(i + 1));\n        }\n      } else {\n        // gl.TRIANGLE_STRIP\n        for (let i = 0; i < numberOfTriangles; i++) {\n          if (i % 2 === 0) {\n            newIndices.push(index.getX(i));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i + 2));\n          } else {\n            newIndices.push(index.getX(i + 2));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i));\n          }\n        }\n      }\n    }\n    if (newIndices.length / 3 !== numberOfTriangles) {\n      console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.');\n    } // build final geometry\n\n    const newGeometry = geometry.clone();\n    newGeometry.setIndex(newIndices);\n    newGeometry.clearGroups();\n    return newGeometry;\n  } else {\n    console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode);\n    return geometry;\n  }\n}\n/**\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n * Helpful for Raytracing or Decals.\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n * @return {Object} An Object with original position/normal attributes and morphed ones.\n */\n\nfunction computeMorphedAttributes(object) {\n  if (object.geometry.isBufferGeometry !== true) {\n    console.error('THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.');\n    return null;\n  }\n  const _vA = new Vector3();\n  const _vB = new Vector3();\n  const _vC = new Vector3();\n  const _tempA = new Vector3();\n  const _tempB = new Vector3();\n  const _tempC = new Vector3();\n  const _morphA = new Vector3();\n  const _morphB = new Vector3();\n  const _morphC = new Vector3();\n  function _calculateMorphedAttributeData(object, material, attribute, morphAttribute, morphTargetsRelative, a, b, c, modifiedAttributeArray) {\n    _vA.fromBufferAttribute(attribute, a);\n    _vB.fromBufferAttribute(attribute, b);\n    _vC.fromBufferAttribute(attribute, c);\n    const morphInfluences = object.morphTargetInfluences;\n    if (\n    // @ts-expect-error\n    material.morphTargets && morphAttribute && morphInfluences) {\n      _morphA.set(0, 0, 0);\n      _morphB.set(0, 0, 0);\n      _morphC.set(0, 0, 0);\n      for (let i = 0, il = morphAttribute.length; i < il; i++) {\n        const influence = morphInfluences[i];\n        const morph = morphAttribute[i];\n        if (influence === 0) continue;\n        _tempA.fromBufferAttribute(morph, a);\n        _tempB.fromBufferAttribute(morph, b);\n        _tempC.fromBufferAttribute(morph, c);\n        if (morphTargetsRelative) {\n          _morphA.addScaledVector(_tempA, influence);\n          _morphB.addScaledVector(_tempB, influence);\n          _morphC.addScaledVector(_tempC, influence);\n        } else {\n          _morphA.addScaledVector(_tempA.sub(_vA), influence);\n          _morphB.addScaledVector(_tempB.sub(_vB), influence);\n          _morphC.addScaledVector(_tempC.sub(_vC), influence);\n        }\n      }\n      _vA.add(_morphA);\n      _vB.add(_morphB);\n      _vC.add(_morphC);\n    }\n    if (object.isSkinnedMesh) {\n      // @ts-expect-error – https://github.com/three-types/three-ts-types/issues/37\n      object.boneTransform(a, _vA); // @ts-expect-error – https://github.com/three-types/three-ts-types/issues/37\n\n      object.boneTransform(b, _vB); // @ts-expect-error – https://github.com/three-types/three-ts-types/issues/37\n\n      object.boneTransform(c, _vC);\n    }\n    modifiedAttributeArray[a * 3 + 0] = _vA.x;\n    modifiedAttributeArray[a * 3 + 1] = _vA.y;\n    modifiedAttributeArray[a * 3 + 2] = _vA.z;\n    modifiedAttributeArray[b * 3 + 0] = _vB.x;\n    modifiedAttributeArray[b * 3 + 1] = _vB.y;\n    modifiedAttributeArray[b * 3 + 2] = _vB.z;\n    modifiedAttributeArray[c * 3 + 0] = _vC.x;\n    modifiedAttributeArray[c * 3 + 1] = _vC.y;\n    modifiedAttributeArray[c * 3 + 2] = _vC.z;\n  }\n  const geometry = object.geometry;\n  const material = object.material;\n  let a, b, c;\n  const index = geometry.index;\n  const positionAttribute = geometry.attributes.position;\n  const morphPosition = geometry.morphAttributes.position;\n  const morphTargetsRelative = geometry.morphTargetsRelative;\n  const normalAttribute = geometry.attributes.normal;\n  const morphNormal = geometry.morphAttributes.position;\n  const groups = geometry.groups;\n  const drawRange = geometry.drawRange;\n  let i, j, il, jl;\n  let group, groupMaterial;\n  let start, end;\n  const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);\n  const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);\n  if (index !== null) {\n    // indexed buffer geometry\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = index.getX(j);\n          b = index.getX(j + 1);\n          c = index.getX(j + 2);\n          _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n          _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(index.count, drawRange.start + drawRange.count);\n      for (i = start, il = end; i < il; i += 3) {\n        a = index.getX(i);\n        b = index.getX(i + 1);\n        c = index.getX(i + 2);\n        _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n        _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n      }\n    }\n  } else if (positionAttribute !== undefined) {\n    // non-indexed buffer geometry\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = j;\n          b = j + 1;\n          c = j + 2;\n          _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n          _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n      for (i = start, il = end; i < il; i += 3) {\n        a = i;\n        b = i + 1;\n        c = i + 2;\n        _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n        _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n      }\n    }\n  }\n  const morphedPositionAttribute = new Float32BufferAttribute(modifiedPosition, 3);\n  const morphedNormalAttribute = new Float32BufferAttribute(modifiedNormal, 3);\n  return {\n    positionAttribute: positionAttribute,\n    normalAttribute: normalAttribute,\n    morphedPositionAttribute: morphedPositionAttribute,\n    morphedNormalAttribute: morphedNormalAttribute\n  };\n} // Creates a new, non-indexed geometry with smooth normals everywhere except faces that meet at\n// an angle greater than the crease angle.\n\nfunction toCreasedNormals(geometry) {\n  let creaseAngle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Math.PI / 3;\n  const creaseDot = Math.cos(creaseAngle);\n  const hashMultiplier = (1 + 1e-10) * 1e2; // reusable vertors\n\n  const verts = [new Vector3(), new Vector3(), new Vector3()];\n  const tempVec1 = new Vector3();\n  const tempVec2 = new Vector3();\n  const tempNorm = new Vector3();\n  const tempNorm2 = new Vector3(); // hashes a vector\n\n  function hashVertex(v) {\n    const x = ~~(v.x * hashMultiplier);\n    const y = ~~(v.y * hashMultiplier);\n    const z = ~~(v.z * hashMultiplier);\n    return `${x},${y},${z}`;\n  }\n  const resultGeometry = geometry.toNonIndexed();\n  const posAttr = resultGeometry.attributes.position;\n  const vertexMap = {}; // find all the normals shared by commonly located vertices\n\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i;\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n    tempVec1.subVectors(c, b);\n    tempVec2.subVectors(a, b); // add the normal to the map for all vertices\n\n    const normal = new Vector3().crossVectors(tempVec1, tempVec2).normalize();\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n];\n      const hash = hashVertex(vert);\n      if (!(hash in vertexMap)) {\n        vertexMap[hash] = [];\n      }\n      vertexMap[hash].push(normal);\n    }\n  } // average normals from all vertices that share a common location if they are within the\n  // provided crease threshold\n\n  const normalArray = new Float32Array(posAttr.count * 3);\n  const normAttr = new BufferAttribute(normalArray, 3, false);\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    // get the face normal for this vertex\n    const i3 = 3 * i;\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n    tempVec1.subVectors(c, b);\n    tempVec2.subVectors(a, b);\n    tempNorm.crossVectors(tempVec1, tempVec2).normalize(); // average all normals that meet the threshold and set the normal value\n\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n];\n      const hash = hashVertex(vert);\n      const otherNormals = vertexMap[hash];\n      tempNorm2.set(0, 0, 0);\n      for (let k = 0, lk = otherNormals.length; k < lk; k++) {\n        const otherNorm = otherNormals[k];\n        if (tempNorm.dot(otherNorm) > creaseDot) {\n          tempNorm2.add(otherNorm);\n        }\n      }\n      tempNorm2.normalize();\n      normAttr.setXYZ(i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z);\n    }\n  }\n  resultGeometry.setAttribute('normal', normAttr);\n  return resultGeometry;\n}\nexport { computeMorphedAttributes, estimateBytesUsed, interleaveAttributes, mergeBufferAttributes, mergeBufferGeometries, mergeVertices, toCreasedNormals, toTrianglesDrawMode };","map":{"version":3,"names":["BufferGeometry","BufferAttribute","InterleavedBuffer","InterleavedBufferAttribute","TrianglesDrawMode","TriangleFanDrawMode","TriangleStripDrawMode","Vector3","Float32BufferAttribute","getWithKey","mergeBufferGeometries","geometries","useGroups","isIndexed","index","attributesUsed","Set","Object","keys","attributes","morphAttributesUsed","morphAttributes","morphTargetsRelative","mergedGeometry","offset","forEach","geom","i","attributesCount","console","error","name","has","undefined","push","size","userData","mergedUserData","count","position","addGroup","indexOffset","mergedIndex","j","getX","setIndex","mergedAttribute","mergeBufferAttributes","setAttribute","numMorphTargets","length","morphAttributesToMerge","mergedMorphAttribute","TypedArray","itemSize","normalized","arrayLength","attr","array","constructor","set","interleaveAttributes","stride","l","attribute","interleavedBuffer","res","getters","setters","iba","c","k","get","estimateBytesUsed","geometry","mem","getAttribute","BYTES_PER_ELEMENT","indices","getIndex","mergeVertices","tolerance","arguments","Math","max","Number","EPSILON","hashToIndex","positions","vertexCount","nextIndex","attributeNames","attrArrays","morphAttrsArrays","newIndices","morphAttr","Array","fill","map","decimalShift","log10","shiftMultiplier","pow","hash","newarray","newMorphArrays","getterFunc","m","ml","result","clone","oldAttribute","buffer","oldMorphAttribute","morphAttribute","toTrianglesDrawMode","drawMode","warn","numberOfTriangles","newGeometry","clearGroups","computeMorphedAttributes","object","isBufferGeometry","_vA","_vB","_vC","_tempA","_tempB","_tempC","_morphA","_morphB","_morphC","_calculateMorphedAttributeData","material","a","b","modifiedAttributeArray","fromBufferAttribute","morphInfluences","morphTargetInfluences","morphTargets","il","influence","morph","addScaledVector","sub","add","isSkinnedMesh","boneTransform","x","y","z","positionAttribute","morphPosition","normalAttribute","normal","morphNormal","groups","drawRange","jl","group","groupMaterial","start","end","modifiedPosition","Float32Array","modifiedNormal","isArray","materialIndex","min","morphedPositionAttribute","morphedNormalAttribute","toCreasedNormals","creaseAngle","PI","creaseDot","cos","hashMultiplier","verts","tempVec1","tempVec2","tempNorm","tempNorm2","hashVertex","v","resultGeometry","toNonIndexed","posAttr","vertexMap","i3","subVectors","crossVectors","normalize","n","vert","normalArray","normAttr","otherNormals","lk","otherNorm","dot","setXYZ"],"sources":["/Users/rociopichardo/Desktop/PFhenryFront/node_modules/three-stdlib/utils/BufferGeometryUtils.js"],"sourcesContent":["import { BufferGeometry, BufferAttribute, InterleavedBuffer, InterleavedBufferAttribute, TrianglesDrawMode, TriangleFanDrawMode, TriangleStripDrawMode, Vector3, Float32BufferAttribute } from 'three';\nimport { getWithKey } from '../types/helpers.js';\n\n/**\n * @param  {Array<BufferGeometry>} geometries\n * @param  {Boolean} useGroups\n * @return {BufferGeometry}\n */\nconst mergeBufferGeometries = (geometries, useGroups) => {\n  const isIndexed = geometries[0].index !== null;\n  const attributesUsed = new Set(Object.keys(geometries[0].attributes));\n  const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\n  const attributes = {};\n  const morphAttributes = {};\n  const morphTargetsRelative = geometries[0].morphTargetsRelative;\n  const mergedGeometry = new BufferGeometry();\n  let offset = 0;\n  geometries.forEach((geom, i) => {\n    let attributesCount = 0; // ensure that all geometries are indexed, or none\n\n    if (isIndexed !== (geom.index !== null)) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.');\n      return null;\n    } // gather attributes, exit early if they're different\n\n\n    for (let name in geom.attributes) {\n      if (!attributesUsed.has(name)) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.');\n        return null;\n      }\n\n      if (attributes[name] === undefined) {\n        attributes[name] = [];\n      }\n\n      attributes[name].push(geom.attributes[name]);\n      attributesCount++;\n    } // ensure geometries have the same number of attributes\n\n\n    if (attributesCount !== attributesUsed.size) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.');\n      return null;\n    } // gather morph attributes, exit early if they're different\n\n\n    if (morphTargetsRelative !== geom.morphTargetsRelative) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.');\n      return null;\n    }\n\n    for (let name in geom.morphAttributes) {\n      if (!morphAttributesUsed.has(name)) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.');\n        return null;\n      }\n\n      if (morphAttributes[name] === undefined) morphAttributes[name] = [];\n      morphAttributes[name].push(geom.morphAttributes[name]);\n    } // gather .userData\n\n\n    mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n    mergedGeometry.userData.mergedUserData.push(geom.userData);\n\n    if (useGroups) {\n      let count;\n\n      if (geom.index) {\n        count = geom.index.count;\n      } else if (geom.attributes.position !== undefined) {\n        count = geom.attributes.position.count;\n      } else {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute');\n        return null;\n      }\n\n      mergedGeometry.addGroup(offset, count, i);\n      offset += count;\n    }\n  }); // merge indices\n\n  if (isIndexed) {\n    let indexOffset = 0;\n    const mergedIndex = [];\n    geometries.forEach(geom => {\n      const index = geom.index;\n\n      for (let j = 0; j < index.count; ++j) {\n        mergedIndex.push(index.getX(j) + indexOffset);\n      }\n\n      indexOffset += geom.attributes.position.count;\n    });\n    mergedGeometry.setIndex(mergedIndex);\n  } // merge attributes\n\n\n  for (let name in attributes) {\n    const mergedAttribute = mergeBufferAttributes(attributes[name]);\n\n    if (!mergedAttribute) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' attribute.');\n      return null;\n    }\n\n    mergedGeometry.setAttribute(name, mergedAttribute);\n  } // merge morph attributes\n\n\n  for (let name in morphAttributes) {\n    const numMorphTargets = morphAttributes[name][0].length;\n    if (numMorphTargets === 0) break;\n    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n    mergedGeometry.morphAttributes[name] = [];\n\n    for (let i = 0; i < numMorphTargets; ++i) {\n      const morphAttributesToMerge = [];\n\n      for (let j = 0; j < morphAttributes[name].length; ++j) {\n        morphAttributesToMerge.push(morphAttributes[name][j][i]);\n      }\n\n      const mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge);\n\n      if (!mergedMorphAttribute) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' morphAttribute.');\n        return null;\n      }\n\n      mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);\n    }\n  }\n\n  return mergedGeometry;\n};\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {BufferAttribute}\n */\n\nconst mergeBufferAttributes = attributes => {\n  let TypedArray = undefined;\n  let itemSize = undefined;\n  let normalized = undefined;\n  let arrayLength = 0;\n  attributes.forEach(attr => {\n    if (TypedArray === undefined) {\n      TypedArray = attr.array.constructor;\n    }\n\n    if (TypedArray !== attr.array.constructor) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.');\n      return null;\n    }\n\n    if (itemSize === undefined) itemSize = attr.itemSize;\n\n    if (itemSize !== attr.itemSize) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.');\n      return null;\n    }\n\n    if (normalized === undefined) normalized = attr.normalized;\n\n    if (normalized !== attr.normalized) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.');\n      return null;\n    }\n\n    arrayLength += attr.array.length;\n  });\n\n  if (TypedArray && itemSize) {\n    // @ts-expect-error this works in JS and TS is complaining but it's such a tiny thing I can live with the guilt\n    const array = new TypedArray(arrayLength);\n    let offset = 0;\n    attributes.forEach(attr => {\n      array.set(attr.array, offset);\n      offset += attr.array.length;\n    });\n    return new BufferAttribute(array, itemSize, normalized);\n  }\n};\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {Array<InterleavedBufferAttribute>}\n */\n\nconst interleaveAttributes = attributes => {\n  // Interleaves the provided attributes into an InterleavedBuffer and returns\n  // a set of InterleavedBufferAttributes for each attribute\n  let TypedArray = undefined;\n  let arrayLength = 0;\n  let stride = 0; // calculate the the length and type of the interleavedBuffer\n\n  for (let i = 0, l = attributes.length; i < l; ++i) {\n    const attribute = attributes[i];\n    if (TypedArray === undefined) TypedArray = attribute.array.constructor;\n\n    if (TypedArray !== attribute.array.constructor) {\n      console.error('AttributeBuffers of different types cannot be interleaved');\n      return null;\n    }\n\n    arrayLength += attribute.array.length;\n    stride += attribute.itemSize;\n  } // Create the set of buffer attributes\n  // @ts-expect-error this works in JS and TS is complaining but it's such a tiny thing I can live with the guilt\n\n\n  const interleavedBuffer = new InterleavedBuffer(new TypedArray(arrayLength), stride);\n  let offset = 0;\n  const res = [];\n  const getters = ['getX', 'getY', 'getZ', 'getW'];\n  const setters = ['setX', 'setY', 'setZ', 'setW'];\n\n  for (let j = 0, l = attributes.length; j < l; j++) {\n    const attribute = attributes[j];\n    const itemSize = attribute.itemSize;\n    const count = attribute.count;\n    const iba = new InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized);\n    res.push(iba);\n    offset += itemSize; // Move the data for each attribute into the new interleavedBuffer\n    // at the appropriate offset\n\n    for (let c = 0; c < count; c++) {\n      for (let k = 0; k < itemSize; k++) {\n        const set = getWithKey(iba, setters[k]);\n        const get = getWithKey(attribute, getters[k]);\n        set(c, get(c));\n      }\n    }\n  }\n\n  return res;\n};\n/**\n * @param {Array<BufferGeometry>} geometry\n * @return {number}\n */\n\nfunction estimateBytesUsed(geometry) {\n  // Return the estimated memory used by this geometry in bytes\n  // Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n  // for InterleavedBufferAttributes.\n  let mem = 0;\n\n  for (let name in geometry.attributes) {\n    const attr = geometry.getAttribute(name);\n    mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n  }\n\n  const indices = geometry.getIndex();\n  mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n  return mem;\n}\n/**\n * @param {BufferGeometry} geometry\n * @param {number} tolerance\n * @return {BufferGeometry>}\n */\n\nfunction mergeVertices(geometry, tolerance = 1e-4) {\n  tolerance = Math.max(tolerance, Number.EPSILON); // Generate an index buffer if the geometry doesn't have one, or optimize it\n  // if it's already available.\n\n  const hashToIndex = {};\n  const indices = geometry.getIndex();\n  const positions = geometry.getAttribute('position');\n  const vertexCount = indices ? indices.count : positions.count; // next value for triangle indices\n\n  let nextIndex = 0; // attributes and new attribute arrays\n\n  const attributeNames = Object.keys(geometry.attributes);\n  const attrArrays = {};\n  const morphAttrsArrays = {};\n  const newIndices = [];\n  const getters = ['getX', 'getY', 'getZ', 'getW']; // initialize the arrays\n\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    attrArrays[name] = [];\n    const morphAttr = geometry.morphAttributes[name];\n\n    if (morphAttr) {\n      morphAttrsArrays[name] = new Array(morphAttr.length).fill(0).map(() => []);\n    }\n  } // convert the error tolerance to an amount of decimal places to truncate to\n\n\n  const decimalShift = Math.log10(1 / tolerance);\n  const shiftMultiplier = Math.pow(10, decimalShift);\n\n  for (let i = 0; i < vertexCount; i++) {\n    const index = indices ? indices.getX(i) : i; // Generate a hash for the vertex attributes at the current index 'i'\n\n    let hash = '';\n\n    for (let j = 0, l = attributeNames.length; j < l; j++) {\n      const name = attributeNames[j];\n      const attribute = geometry.getAttribute(name);\n      const itemSize = attribute.itemSize;\n\n      for (let k = 0; k < itemSize; k++) {\n        // double tilde truncates the decimal value\n        // @ts-ignore no\n        hash += `${~~(attribute[getters[k]](index) * shiftMultiplier)},`;\n      }\n    } // Add another reference to the vertex if it's already\n    // used by another index\n\n\n    if (hash in hashToIndex) {\n      newIndices.push(hashToIndex[hash]);\n    } else {\n      // copy data to the new index in the attribute arrays\n      for (let j = 0, l = attributeNames.length; j < l; j++) {\n        const name = attributeNames[j];\n        const attribute = geometry.getAttribute(name);\n        const morphAttr = geometry.morphAttributes[name];\n        const itemSize = attribute.itemSize;\n        const newarray = attrArrays[name];\n        const newMorphArrays = morphAttrsArrays[name];\n\n        for (let k = 0; k < itemSize; k++) {\n          const getterFunc = getters[k]; // @ts-ignore\n\n          newarray.push(attribute[getterFunc](index));\n\n          if (morphAttr) {\n            for (let m = 0, ml = morphAttr.length; m < ml; m++) {\n              // @ts-ignore\n              newMorphArrays[m].push(morphAttr[m][getterFunc](index));\n            }\n          }\n        }\n      }\n\n      hashToIndex[hash] = nextIndex;\n      newIndices.push(nextIndex);\n      nextIndex++;\n    }\n  } // Generate typed arrays from new attribute arrays and update\n  // the attributeBuffers\n\n\n  const result = geometry.clone();\n\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    const oldAttribute = geometry.getAttribute(name); //@ts-expect-error  something to do with functions and constructors and new\n\n    const buffer = new oldAttribute.array.constructor(attrArrays[name]);\n    const attribute = new BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized);\n    result.setAttribute(name, attribute); // Update the attribute arrays\n\n    if (name in morphAttrsArrays) {\n      for (let j = 0; j < morphAttrsArrays[name].length; j++) {\n        const oldMorphAttribute = geometry.morphAttributes[name][j]; //@ts-expect-error something to do with functions and constructors and new\n\n        const buffer = new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j]);\n        const morphAttribute = new BufferAttribute(buffer, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);\n        result.morphAttributes[name][j] = morphAttribute;\n      }\n    }\n  } // indices\n\n\n  result.setIndex(newIndices);\n  return result;\n}\n/**\n * @param {BufferGeometry} geometry\n * @param {number} drawMode\n * @return {BufferGeometry}\n */\n\nfunction toTrianglesDrawMode(geometry, drawMode) {\n  if (drawMode === TrianglesDrawMode) {\n    console.warn('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.');\n    return geometry;\n  }\n\n  if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {\n    let index = geometry.getIndex(); // generate index if not present\n\n    if (index === null) {\n      const indices = [];\n      const position = geometry.getAttribute('position');\n\n      if (position !== undefined) {\n        for (let i = 0; i < position.count; i++) {\n          indices.push(i);\n        }\n\n        geometry.setIndex(indices);\n        index = geometry.getIndex();\n      } else {\n        console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.');\n        return geometry;\n      }\n    } //\n\n\n    const numberOfTriangles = index.count - 2;\n    const newIndices = [];\n\n    if (index) {\n      if (drawMode === TriangleFanDrawMode) {\n        // gl.TRIANGLE_FAN\n        for (let i = 1; i <= numberOfTriangles; i++) {\n          newIndices.push(index.getX(0));\n          newIndices.push(index.getX(i));\n          newIndices.push(index.getX(i + 1));\n        }\n      } else {\n        // gl.TRIANGLE_STRIP\n        for (let i = 0; i < numberOfTriangles; i++) {\n          if (i % 2 === 0) {\n            newIndices.push(index.getX(i));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i + 2));\n          } else {\n            newIndices.push(index.getX(i + 2));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i));\n          }\n        }\n      }\n    }\n\n    if (newIndices.length / 3 !== numberOfTriangles) {\n      console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.');\n    } // build final geometry\n\n\n    const newGeometry = geometry.clone();\n    newGeometry.setIndex(newIndices);\n    newGeometry.clearGroups();\n    return newGeometry;\n  } else {\n    console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode);\n    return geometry;\n  }\n}\n/**\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n * Helpful for Raytracing or Decals.\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n * @return {Object} An Object with original position/normal attributes and morphed ones.\n */\n\nfunction computeMorphedAttributes(object) {\n  if (object.geometry.isBufferGeometry !== true) {\n    console.error('THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.');\n    return null;\n  }\n\n  const _vA = new Vector3();\n\n  const _vB = new Vector3();\n\n  const _vC = new Vector3();\n\n  const _tempA = new Vector3();\n\n  const _tempB = new Vector3();\n\n  const _tempC = new Vector3();\n\n  const _morphA = new Vector3();\n\n  const _morphB = new Vector3();\n\n  const _morphC = new Vector3();\n\n  function _calculateMorphedAttributeData(object, material, attribute, morphAttribute, morphTargetsRelative, a, b, c, modifiedAttributeArray) {\n    _vA.fromBufferAttribute(attribute, a);\n\n    _vB.fromBufferAttribute(attribute, b);\n\n    _vC.fromBufferAttribute(attribute, c);\n\n    const morphInfluences = object.morphTargetInfluences;\n\n    if ( // @ts-expect-error\n    material.morphTargets && morphAttribute && morphInfluences) {\n      _morphA.set(0, 0, 0);\n\n      _morphB.set(0, 0, 0);\n\n      _morphC.set(0, 0, 0);\n\n      for (let i = 0, il = morphAttribute.length; i < il; i++) {\n        const influence = morphInfluences[i];\n        const morph = morphAttribute[i];\n        if (influence === 0) continue;\n\n        _tempA.fromBufferAttribute(morph, a);\n\n        _tempB.fromBufferAttribute(morph, b);\n\n        _tempC.fromBufferAttribute(morph, c);\n\n        if (morphTargetsRelative) {\n          _morphA.addScaledVector(_tempA, influence);\n\n          _morphB.addScaledVector(_tempB, influence);\n\n          _morphC.addScaledVector(_tempC, influence);\n        } else {\n          _morphA.addScaledVector(_tempA.sub(_vA), influence);\n\n          _morphB.addScaledVector(_tempB.sub(_vB), influence);\n\n          _morphC.addScaledVector(_tempC.sub(_vC), influence);\n        }\n      }\n\n      _vA.add(_morphA);\n\n      _vB.add(_morphB);\n\n      _vC.add(_morphC);\n    }\n\n    if (object.isSkinnedMesh) {\n      // @ts-expect-error – https://github.com/three-types/three-ts-types/issues/37\n      object.boneTransform(a, _vA); // @ts-expect-error – https://github.com/three-types/three-ts-types/issues/37\n\n      object.boneTransform(b, _vB); // @ts-expect-error – https://github.com/three-types/three-ts-types/issues/37\n\n      object.boneTransform(c, _vC);\n    }\n\n    modifiedAttributeArray[a * 3 + 0] = _vA.x;\n    modifiedAttributeArray[a * 3 + 1] = _vA.y;\n    modifiedAttributeArray[a * 3 + 2] = _vA.z;\n    modifiedAttributeArray[b * 3 + 0] = _vB.x;\n    modifiedAttributeArray[b * 3 + 1] = _vB.y;\n    modifiedAttributeArray[b * 3 + 2] = _vB.z;\n    modifiedAttributeArray[c * 3 + 0] = _vC.x;\n    modifiedAttributeArray[c * 3 + 1] = _vC.y;\n    modifiedAttributeArray[c * 3 + 2] = _vC.z;\n  }\n\n  const geometry = object.geometry;\n  const material = object.material;\n  let a, b, c;\n  const index = geometry.index;\n  const positionAttribute = geometry.attributes.position;\n  const morphPosition = geometry.morphAttributes.position;\n  const morphTargetsRelative = geometry.morphTargetsRelative;\n  const normalAttribute = geometry.attributes.normal;\n  const morphNormal = geometry.morphAttributes.position;\n  const groups = geometry.groups;\n  const drawRange = geometry.drawRange;\n  let i, j, il, jl;\n  let group, groupMaterial;\n  let start, end;\n  const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);\n  const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);\n\n  if (index !== null) {\n    // indexed buffer geometry\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = index.getX(j);\n          b = index.getX(j + 1);\n          c = index.getX(j + 2);\n\n          _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n\n          _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(index.count, drawRange.start + drawRange.count);\n\n      for (i = start, il = end; i < il; i += 3) {\n        a = index.getX(i);\n        b = index.getX(i + 1);\n        c = index.getX(i + 2);\n\n        _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n\n        _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n      }\n    }\n  } else if (positionAttribute !== undefined) {\n    // non-indexed buffer geometry\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = j;\n          b = j + 1;\n          c = j + 2;\n\n          _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n\n          _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n\n      for (i = start, il = end; i < il; i += 3) {\n        a = i;\n        b = i + 1;\n        c = i + 2;\n\n        _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n\n        _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n      }\n    }\n  }\n\n  const morphedPositionAttribute = new Float32BufferAttribute(modifiedPosition, 3);\n  const morphedNormalAttribute = new Float32BufferAttribute(modifiedNormal, 3);\n  return {\n    positionAttribute: positionAttribute,\n    normalAttribute: normalAttribute,\n    morphedPositionAttribute: morphedPositionAttribute,\n    morphedNormalAttribute: morphedNormalAttribute\n  };\n} // Creates a new, non-indexed geometry with smooth normals everywhere except faces that meet at\n// an angle greater than the crease angle.\n\nfunction toCreasedNormals(geometry, creaseAngle = Math.PI / 3\n/* 60 degrees */\n) {\n  const creaseDot = Math.cos(creaseAngle);\n  const hashMultiplier = (1 + 1e-10) * 1e2; // reusable vertors\n\n  const verts = [new Vector3(), new Vector3(), new Vector3()];\n  const tempVec1 = new Vector3();\n  const tempVec2 = new Vector3();\n  const tempNorm = new Vector3();\n  const tempNorm2 = new Vector3(); // hashes a vector\n\n  function hashVertex(v) {\n    const x = ~~(v.x * hashMultiplier);\n    const y = ~~(v.y * hashMultiplier);\n    const z = ~~(v.z * hashMultiplier);\n    return `${x},${y},${z}`;\n  }\n\n  const resultGeometry = geometry.toNonIndexed();\n  const posAttr = resultGeometry.attributes.position;\n  const vertexMap = {}; // find all the normals shared by commonly located vertices\n\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i;\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n    tempVec1.subVectors(c, b);\n    tempVec2.subVectors(a, b); // add the normal to the map for all vertices\n\n    const normal = new Vector3().crossVectors(tempVec1, tempVec2).normalize();\n\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n];\n      const hash = hashVertex(vert);\n\n      if (!(hash in vertexMap)) {\n        vertexMap[hash] = [];\n      }\n\n      vertexMap[hash].push(normal);\n    }\n  } // average normals from all vertices that share a common location if they are within the\n  // provided crease threshold\n\n\n  const normalArray = new Float32Array(posAttr.count * 3);\n  const normAttr = new BufferAttribute(normalArray, 3, false);\n\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    // get the face normal for this vertex\n    const i3 = 3 * i;\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n    tempVec1.subVectors(c, b);\n    tempVec2.subVectors(a, b);\n    tempNorm.crossVectors(tempVec1, tempVec2).normalize(); // average all normals that meet the threshold and set the normal value\n\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n];\n      const hash = hashVertex(vert);\n      const otherNormals = vertexMap[hash];\n      tempNorm2.set(0, 0, 0);\n\n      for (let k = 0, lk = otherNormals.length; k < lk; k++) {\n        const otherNorm = otherNormals[k];\n\n        if (tempNorm.dot(otherNorm) > creaseDot) {\n          tempNorm2.add(otherNorm);\n        }\n      }\n\n      tempNorm2.normalize();\n      normAttr.setXYZ(i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z);\n    }\n  }\n\n  resultGeometry.setAttribute('normal', normAttr);\n  return resultGeometry;\n}\n\nexport { computeMorphedAttributes, estimateBytesUsed, interleaveAttributes, mergeBufferAttributes, mergeBufferGeometries, mergeVertices, toCreasedNormals, toTrianglesDrawMode };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}