{"ast":null,"code":"\"use strict\";\n\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LLkLookaheadStrategy = void 0;\nvar flatMap_1 = __importDefault(require(\"lodash/flatMap\"));\nvar isEmpty_1 = __importDefault(require(\"lodash/isEmpty\"));\nvar errors_public_1 = require(\"../errors_public\");\nvar parser_1 = require(\"../parser/parser\");\nvar checks_1 = require(\"./checks\");\nvar lookahead_1 = require(\"./lookahead\");\nvar LLkLookaheadStrategy = /** @class */function () {\n  function LLkLookaheadStrategy(options) {\n    var _a;\n    this.maxLookahead = (_a = options === null || options === void 0 ? void 0 : options.maxLookahead) !== null && _a !== void 0 ? _a : parser_1.DEFAULT_PARSER_CONFIG.maxLookahead;\n  }\n  LLkLookaheadStrategy.prototype.validate = function (options) {\n    var leftRecursionErrors = this.validateNoLeftRecursion(options.rules);\n    if ((0, isEmpty_1.default)(leftRecursionErrors)) {\n      var emptyAltErrors = this.validateEmptyOrAlternatives(options.rules);\n      var ambiguousAltsErrors = this.validateAmbiguousAlternationAlternatives(options.rules, this.maxLookahead);\n      var emptyRepetitionErrors = this.validateSomeNonEmptyLookaheadPath(options.rules, this.maxLookahead);\n      var allErrors = __spreadArray(__spreadArray(__spreadArray(__spreadArray([], leftRecursionErrors, true), emptyAltErrors, true), ambiguousAltsErrors, true), emptyRepetitionErrors, true);\n      return allErrors;\n    }\n    return leftRecursionErrors;\n  };\n  LLkLookaheadStrategy.prototype.validateNoLeftRecursion = function (rules) {\n    return (0, flatMap_1.default)(rules, function (currTopRule) {\n      return (0, checks_1.validateNoLeftRecursion)(currTopRule, currTopRule, errors_public_1.defaultGrammarValidatorErrorProvider);\n    });\n  };\n  LLkLookaheadStrategy.prototype.validateEmptyOrAlternatives = function (rules) {\n    return (0, flatMap_1.default)(rules, function (currTopRule) {\n      return (0, checks_1.validateEmptyOrAlternative)(currTopRule, errors_public_1.defaultGrammarValidatorErrorProvider);\n    });\n  };\n  LLkLookaheadStrategy.prototype.validateAmbiguousAlternationAlternatives = function (rules, maxLookahead) {\n    return (0, flatMap_1.default)(rules, function (currTopRule) {\n      return (0, checks_1.validateAmbiguousAlternationAlternatives)(currTopRule, maxLookahead, errors_public_1.defaultGrammarValidatorErrorProvider);\n    });\n  };\n  LLkLookaheadStrategy.prototype.validateSomeNonEmptyLookaheadPath = function (rules, maxLookahead) {\n    return (0, checks_1.validateSomeNonEmptyLookaheadPath)(rules, maxLookahead, errors_public_1.defaultGrammarValidatorErrorProvider);\n  };\n  LLkLookaheadStrategy.prototype.buildLookaheadForAlternation = function (options) {\n    return (0, lookahead_1.buildLookaheadFuncForOr)(options.prodOccurrence, options.rule, options.maxLookahead, options.hasPredicates, options.dynamicTokensEnabled, lookahead_1.buildAlternativesLookAheadFunc);\n  };\n  LLkLookaheadStrategy.prototype.buildLookaheadForOptional = function (options) {\n    return (0, lookahead_1.buildLookaheadFuncForOptionalProd)(options.prodOccurrence, options.rule, options.maxLookahead, options.dynamicTokensEnabled, (0, lookahead_1.getProdType)(options.prodType), lookahead_1.buildSingleAlternativeLookaheadFunction);\n  };\n  return LLkLookaheadStrategy;\n}();\nexports.LLkLookaheadStrategy = LLkLookaheadStrategy;","map":{"version":3,"names":["flatMap_1","__importDefault","require","isEmpty_1","errors_public_1","parser_1","checks_1","lookahead_1","LLkLookaheadStrategy","options","maxLookahead","_a","DEFAULT_PARSER_CONFIG","prototype","validate","leftRecursionErrors","validateNoLeftRecursion","rules","default","emptyAltErrors","validateEmptyOrAlternatives","ambiguousAltsErrors","validateAmbiguousAlternationAlternatives","emptyRepetitionErrors","validateSomeNonEmptyLookaheadPath","allErrors","__spreadArray","currTopRule","defaultGrammarValidatorErrorProvider","validateEmptyOrAlternative","buildLookaheadForAlternation","buildLookaheadFuncForOr","prodOccurrence","rule","hasPredicates","dynamicTokensEnabled","buildAlternativesLookAheadFunc","buildLookaheadForOptional","buildLookaheadFuncForOptionalProd","getProdType","prodType","buildSingleAlternativeLookaheadFunction","exports"],"sources":["/Users/rociopichardo/Desktop/PFhenryFront/restaurante-pf-front/node_modules/chevrotain/src/parse/grammar/llk_lookahead.ts"],"sourcesContent":["import {\n  ILookaheadStrategy,\n  ILookaheadValidationError,\n  IOrAlt,\n  Rule,\n  TokenType,\n  OptionalProductionType\n} from \"@chevrotain/types\"\nimport flatMap from \"lodash/flatMap\"\nimport isEmpty from \"lodash/isEmpty\"\nimport { defaultGrammarValidatorErrorProvider } from \"../errors_public\"\nimport { DEFAULT_PARSER_CONFIG } from \"../parser/parser\"\nimport {\n  validateAmbiguousAlternationAlternatives,\n  validateEmptyOrAlternative,\n  validateNoLeftRecursion,\n  validateSomeNonEmptyLookaheadPath\n} from \"./checks\"\nimport {\n  buildAlternativesLookAheadFunc,\n  buildLookaheadFuncForOptionalProd,\n  buildLookaheadFuncForOr,\n  buildSingleAlternativeLookaheadFunction,\n  getProdType\n} from \"./lookahead\"\nimport { IParserDefinitionError } from \"./types\"\n\nexport class LLkLookaheadStrategy implements ILookaheadStrategy {\n  readonly maxLookahead: number\n\n  constructor(options?: { maxLookahead?: number }) {\n    this.maxLookahead =\n      options?.maxLookahead ?? DEFAULT_PARSER_CONFIG.maxLookahead\n  }\n\n  validate(options: {\n    rules: Rule[]\n    tokenTypes: TokenType[]\n    grammarName: string\n  }): ILookaheadValidationError[] {\n    const leftRecursionErrors = this.validateNoLeftRecursion(options.rules)\n\n    if (isEmpty(leftRecursionErrors)) {\n      const emptyAltErrors = this.validateEmptyOrAlternatives(options.rules)\n      const ambiguousAltsErrors = this.validateAmbiguousAlternationAlternatives(\n        options.rules,\n        this.maxLookahead\n      )\n      const emptyRepetitionErrors = this.validateSomeNonEmptyLookaheadPath(\n        options.rules,\n        this.maxLookahead\n      )\n      const allErrors = [\n        ...leftRecursionErrors,\n        ...emptyAltErrors,\n        ...ambiguousAltsErrors,\n        ...emptyRepetitionErrors\n      ]\n      return allErrors\n    }\n    return leftRecursionErrors\n  }\n\n  validateNoLeftRecursion(rules: Rule[]): IParserDefinitionError[] {\n    return flatMap(rules, (currTopRule) =>\n      validateNoLeftRecursion(\n        currTopRule,\n        currTopRule,\n        defaultGrammarValidatorErrorProvider\n      )\n    )\n  }\n\n  validateEmptyOrAlternatives(rules: Rule[]): IParserDefinitionError[] {\n    return flatMap(rules, (currTopRule) =>\n      validateEmptyOrAlternative(\n        currTopRule,\n        defaultGrammarValidatorErrorProvider\n      )\n    )\n  }\n\n  validateAmbiguousAlternationAlternatives(\n    rules: Rule[],\n    maxLookahead: number\n  ): IParserDefinitionError[] {\n    return flatMap(rules, (currTopRule) =>\n      validateAmbiguousAlternationAlternatives(\n        currTopRule,\n        maxLookahead,\n        defaultGrammarValidatorErrorProvider\n      )\n    )\n  }\n\n  validateSomeNonEmptyLookaheadPath(\n    rules: Rule[],\n    maxLookahead: number\n  ): IParserDefinitionError[] {\n    return validateSomeNonEmptyLookaheadPath(\n      rules,\n      maxLookahead,\n      defaultGrammarValidatorErrorProvider\n    )\n  }\n\n  buildLookaheadForAlternation(options: {\n    prodOccurrence: number\n    rule: Rule\n    maxLookahead: number\n    hasPredicates: boolean\n    dynamicTokensEnabled: boolean\n  }): (orAlts?: IOrAlt<any>[] | undefined) => number | undefined {\n    return buildLookaheadFuncForOr(\n      options.prodOccurrence,\n      options.rule,\n      options.maxLookahead,\n      options.hasPredicates,\n      options.dynamicTokensEnabled,\n      buildAlternativesLookAheadFunc\n    )\n  }\n\n  buildLookaheadForOptional(options: {\n    prodOccurrence: number\n    prodType: OptionalProductionType\n    rule: Rule\n    maxLookahead: number\n    dynamicTokensEnabled: boolean\n  }): () => boolean {\n    return buildLookaheadFuncForOptionalProd(\n      options.prodOccurrence,\n      options.rule,\n      options.maxLookahead,\n      options.dynamicTokensEnabled,\n      getProdType(options.prodType),\n      buildSingleAlternativeLookaheadFunction\n    )\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAQA,IAAAA,SAAA,GAAAC,eAAA,CAAAC,OAAA;AACA,IAAAC,SAAA,GAAAF,eAAA,CAAAC,OAAA;AACA,IAAAE,eAAA,GAAAF,OAAA;AACA,IAAAG,QAAA,GAAAH,OAAA;AACA,IAAAI,QAAA,GAAAJ,OAAA;AAMA,IAAAK,WAAA,GAAAL,OAAA;AASA,IAAAM,oBAAA;EAGE,SAAAA,qBAAYC,OAAmC;;IAC7C,IAAI,CAACC,YAAY,GACf,CAAAC,EAAA,GAAAF,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEC,YAAY,cAAAC,EAAA,cAAAA,EAAA,GAAIN,QAAA,CAAAO,qBAAqB,CAACF,YAAY;EAC/D;EAEAF,oBAAA,CAAAK,SAAA,CAAAC,QAAQ,GAAR,UAASL,OAIR;IACC,IAAMM,mBAAmB,GAAG,IAAI,CAACC,uBAAuB,CAACP,OAAO,CAACQ,KAAK,CAAC;IAEvE,IAAI,IAAAd,SAAA,CAAAe,OAAO,EAACH,mBAAmB,CAAC,EAAE;MAChC,IAAMI,cAAc,GAAG,IAAI,CAACC,2BAA2B,CAACX,OAAO,CAACQ,KAAK,CAAC;MACtE,IAAMI,mBAAmB,GAAG,IAAI,CAACC,wCAAwC,CACvEb,OAAO,CAACQ,KAAK,EACb,IAAI,CAACP,YAAY,CAClB;MACD,IAAMa,qBAAqB,GAAG,IAAI,CAACC,iCAAiC,CAClEf,OAAO,CAACQ,KAAK,EACb,IAAI,CAACP,YAAY,CAClB;MACD,IAAMe,SAAS,GAAAC,aAAA,CAAAA,aAAA,CAAAA,aAAA,CAAAA,aAAA,KACVX,mBAAmB,SACnBI,cAAc,SACdE,mBAAmB,SACnBE,qBAAqB,OACzB;MACD,OAAOE,SAAS;;IAElB,OAAOV,mBAAmB;EAC5B,CAAC;EAEDP,oBAAA,CAAAK,SAAA,CAAAG,uBAAuB,GAAvB,UAAwBC,KAAa;IACnC,OAAO,IAAAjB,SAAA,CAAAkB,OAAO,EAACD,KAAK,EAAE,UAACU,WAAW;MAChC,WAAArB,QAAA,CAAAU,uBAAuB,EACrBW,WAAW,EACXA,WAAW,EACXvB,eAAA,CAAAwB,oCAAoC,CACrC;IAJD,CAIC,CACF;EACH,CAAC;EAEDpB,oBAAA,CAAAK,SAAA,CAAAO,2BAA2B,GAA3B,UAA4BH,KAAa;IACvC,OAAO,IAAAjB,SAAA,CAAAkB,OAAO,EAACD,KAAK,EAAE,UAACU,WAAW;MAChC,WAAArB,QAAA,CAAAuB,0BAA0B,EACxBF,WAAW,EACXvB,eAAA,CAAAwB,oCAAoC,CACrC;IAHD,CAGC,CACF;EACH,CAAC;EAEDpB,oBAAA,CAAAK,SAAA,CAAAS,wCAAwC,GAAxC,UACEL,KAAa,EACbP,YAAoB;IAEpB,OAAO,IAAAV,SAAA,CAAAkB,OAAO,EAACD,KAAK,EAAE,UAACU,WAAW;MAChC,WAAArB,QAAA,CAAAgB,wCAAwC,EACtCK,WAAW,EACXjB,YAAY,EACZN,eAAA,CAAAwB,oCAAoC,CACrC;IAJD,CAIC,CACF;EACH,CAAC;EAEDpB,oBAAA,CAAAK,SAAA,CAAAW,iCAAiC,GAAjC,UACEP,KAAa,EACbP,YAAoB;IAEpB,OAAO,IAAAJ,QAAA,CAAAkB,iCAAiC,EACtCP,KAAK,EACLP,YAAY,EACZN,eAAA,CAAAwB,oCAAoC,CACrC;EACH,CAAC;EAEDpB,oBAAA,CAAAK,SAAA,CAAAiB,4BAA4B,GAA5B,UAA6BrB,OAM5B;IACC,OAAO,IAAAF,WAAA,CAAAwB,uBAAuB,EAC5BtB,OAAO,CAACuB,cAAc,EACtBvB,OAAO,CAACwB,IAAI,EACZxB,OAAO,CAACC,YAAY,EACpBD,OAAO,CAACyB,aAAa,EACrBzB,OAAO,CAAC0B,oBAAoB,EAC5B5B,WAAA,CAAA6B,8BAA8B,CAC/B;EACH,CAAC;EAED5B,oBAAA,CAAAK,SAAA,CAAAwB,yBAAyB,GAAzB,UAA0B5B,OAMzB;IACC,OAAO,IAAAF,WAAA,CAAA+B,iCAAiC,EACtC7B,OAAO,CAACuB,cAAc,EACtBvB,OAAO,CAACwB,IAAI,EACZxB,OAAO,CAACC,YAAY,EACpBD,OAAO,CAAC0B,oBAAoB,EAC5B,IAAA5B,WAAA,CAAAgC,WAAW,EAAC9B,OAAO,CAAC+B,QAAQ,CAAC,EAC7BjC,WAAA,CAAAkC,uCAAuC,CACxC;EACH,CAAC;EACH,OAAAjC,oBAAC;AAAD,CAAC,EAhHD;AAAakC,OAAA,CAAAlC,oBAAA,GAAAA,oBAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}