{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.areTokenCategoriesNotUsed = exports.isStrictPrefixOfPath = exports.containsPath = exports.getLookaheadPathsForOptionalProd = exports.getLookaheadPathsForOr = exports.lookAheadSequenceFromAlternatives = exports.buildSingleAlternativeLookaheadFunction = exports.buildAlternativesLookAheadFunc = exports.buildLookaheadFuncForOptionalProd = exports.buildLookaheadFuncForOr = exports.getLookaheadPaths = exports.getProdType = exports.PROD_TYPE = void 0;\nvar isEmpty_1 = __importDefault(require(\"lodash/isEmpty\"));\nvar flatten_1 = __importDefault(require(\"lodash/flatten\"));\nvar every_1 = __importDefault(require(\"lodash/every\"));\nvar map_1 = __importDefault(require(\"lodash/map\"));\nvar forEach_1 = __importDefault(require(\"lodash/forEach\"));\nvar has_1 = __importDefault(require(\"lodash/has\"));\nvar reduce_1 = __importDefault(require(\"lodash/reduce\"));\nvar interpreter_1 = require(\"./interpreter\");\nvar rest_1 = require(\"./rest\");\nvar tokens_1 = require(\"../../scan/tokens\");\nvar gast_1 = require(\"@chevrotain/gast\");\nvar gast_2 = require(\"@chevrotain/gast\");\nvar PROD_TYPE;\n(function (PROD_TYPE) {\n  PROD_TYPE[PROD_TYPE[\"OPTION\"] = 0] = \"OPTION\";\n  PROD_TYPE[PROD_TYPE[\"REPETITION\"] = 1] = \"REPETITION\";\n  PROD_TYPE[PROD_TYPE[\"REPETITION_MANDATORY\"] = 2] = \"REPETITION_MANDATORY\";\n  PROD_TYPE[PROD_TYPE[\"REPETITION_MANDATORY_WITH_SEPARATOR\"] = 3] = \"REPETITION_MANDATORY_WITH_SEPARATOR\";\n  PROD_TYPE[PROD_TYPE[\"REPETITION_WITH_SEPARATOR\"] = 4] = \"REPETITION_WITH_SEPARATOR\";\n  PROD_TYPE[PROD_TYPE[\"ALTERNATION\"] = 5] = \"ALTERNATION\";\n})(PROD_TYPE = exports.PROD_TYPE || (exports.PROD_TYPE = {}));\nfunction getProdType(prod) {\n  /* istanbul ignore else */\n  if (prod instanceof gast_1.Option || prod === \"Option\") {\n    return PROD_TYPE.OPTION;\n  } else if (prod instanceof gast_1.Repetition || prod === \"Repetition\") {\n    return PROD_TYPE.REPETITION;\n  } else if (prod instanceof gast_1.RepetitionMandatory || prod === \"RepetitionMandatory\") {\n    return PROD_TYPE.REPETITION_MANDATORY;\n  } else if (prod instanceof gast_1.RepetitionMandatoryWithSeparator || prod === \"RepetitionMandatoryWithSeparator\") {\n    return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR;\n  } else if (prod instanceof gast_1.RepetitionWithSeparator || prod === \"RepetitionWithSeparator\") {\n    return PROD_TYPE.REPETITION_WITH_SEPARATOR;\n  } else if (prod instanceof gast_1.Alternation || prod === \"Alternation\") {\n    return PROD_TYPE.ALTERNATION;\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\nexports.getProdType = getProdType;\nfunction getLookaheadPaths(options) {\n  var occurrence = options.occurrence,\n    rule = options.rule,\n    prodType = options.prodType,\n    maxLookahead = options.maxLookahead;\n  var type = getProdType(prodType);\n  if (type === PROD_TYPE.ALTERNATION) {\n    return getLookaheadPathsForOr(occurrence, rule, maxLookahead);\n  } else {\n    return getLookaheadPathsForOptionalProd(occurrence, rule, type, maxLookahead);\n  }\n}\nexports.getLookaheadPaths = getLookaheadPaths;\nfunction buildLookaheadFuncForOr(occurrence, ruleGrammar, maxLookahead, hasPredicates, dynamicTokensEnabled, laFuncBuilder) {\n  var lookAheadPaths = getLookaheadPathsForOr(occurrence, ruleGrammar, maxLookahead);\n  var tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths) ? tokens_1.tokenStructuredMatcherNoCategories : tokens_1.tokenStructuredMatcher;\n  return laFuncBuilder(lookAheadPaths, hasPredicates, tokenMatcher, dynamicTokensEnabled);\n}\nexports.buildLookaheadFuncForOr = buildLookaheadFuncForOr;\n/**\n *  When dealing with an Optional production (OPTION/MANY/2nd iteration of AT_LEAST_ONE/...) we need to compare\n *  the lookahead \"inside\" the production and the lookahead immediately \"after\" it in the same top level rule (context free).\n *\n *  Example: given a production:\n *  ABC(DE)?DF\n *\n *  The optional '(DE)?' should only be entered if we see 'DE'. a single Token 'D' is not sufficient to distinguish between the two\n *  alternatives.\n *\n *  @returns A Lookahead function which will return true IFF the parser should parse the Optional production.\n */\nfunction buildLookaheadFuncForOptionalProd(occurrence, ruleGrammar, k, dynamicTokensEnabled, prodType, lookaheadBuilder) {\n  var lookAheadPaths = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k);\n  var tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths) ? tokens_1.tokenStructuredMatcherNoCategories : tokens_1.tokenStructuredMatcher;\n  return lookaheadBuilder(lookAheadPaths[0], tokenMatcher, dynamicTokensEnabled);\n}\nexports.buildLookaheadFuncForOptionalProd = buildLookaheadFuncForOptionalProd;\nfunction buildAlternativesLookAheadFunc(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled) {\n  var numOfAlts = alts.length;\n  var areAllOneTokenLookahead = (0, every_1.default)(alts, function (currAlt) {\n    return (0, every_1.default)(currAlt, function (currPath) {\n      return currPath.length === 1;\n    });\n  });\n  // This version takes into account the predicates as well.\n  if (hasPredicates) {\n    /**\n     * @returns {number} - The chosen alternative index\n     */\n    return function (orAlts) {\n      // unfortunately the predicates must be extracted every single time\n      // as they cannot be cached due to references to parameters(vars) which are no longer valid.\n      // note that in the common case of no predicates, no cpu time will be wasted on this (see else block)\n      var predicates = (0, map_1.default)(orAlts, function (currAlt) {\n        return currAlt.GATE;\n      });\n      for (var t = 0; t < numOfAlts; t++) {\n        var currAlt = alts[t];\n        var currNumOfPaths = currAlt.length;\n        var currPredicate = predicates[t];\n        if (currPredicate !== undefined && currPredicate.call(this) === false) {\n          // if the predicate does not match there is no point in checking the paths\n          continue;\n        }\n        nextPath: for (var j = 0; j < currNumOfPaths; j++) {\n          var currPath = currAlt[j];\n          var currPathLength = currPath.length;\n          for (var i = 0; i < currPathLength; i++) {\n            var nextToken = this.LA(i + 1);\n            if (tokenMatcher(nextToken, currPath[i]) === false) {\n              // mismatch in current path\n              // try the next pth\n              continue nextPath;\n            }\n          }\n          // found a full path that matches.\n          // this will also work for an empty ALT as the loop will be skipped\n          return t;\n        }\n        // none of the paths for the current alternative matched\n        // try the next alternative\n      }\n      // none of the alternatives could be matched\n      return undefined;\n    };\n  } else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n    // optimized (common) case of all the lookaheads paths requiring only\n    // a single token lookahead. These Optimizations cannot work if dynamically defined Tokens are used.\n    var singleTokenAlts = (0, map_1.default)(alts, function (currAlt) {\n      return (0, flatten_1.default)(currAlt);\n    });\n    var choiceToAlt_1 = (0, reduce_1.default)(singleTokenAlts, function (result, currAlt, idx) {\n      (0, forEach_1.default)(currAlt, function (currTokType) {\n        if (!(0, has_1.default)(result, currTokType.tokenTypeIdx)) {\n          result[currTokType.tokenTypeIdx] = idx;\n        }\n        (0, forEach_1.default)(currTokType.categoryMatches, function (currExtendingType) {\n          if (!(0, has_1.default)(result, currExtendingType)) {\n            result[currExtendingType] = idx;\n          }\n        });\n      });\n      return result;\n    }, {});\n    /**\n     * @returns {number} - The chosen alternative index\n     */\n    return function () {\n      var nextToken = this.LA(1);\n      return choiceToAlt_1[nextToken.tokenTypeIdx];\n    };\n  } else {\n    // optimized lookahead without needing to check the predicates at all.\n    // this causes code duplication which is intentional to improve performance.\n    /**\n     * @returns {number} - The chosen alternative index\n     */\n    return function () {\n      for (var t = 0; t < numOfAlts; t++) {\n        var currAlt = alts[t];\n        var currNumOfPaths = currAlt.length;\n        nextPath: for (var j = 0; j < currNumOfPaths; j++) {\n          var currPath = currAlt[j];\n          var currPathLength = currPath.length;\n          for (var i = 0; i < currPathLength; i++) {\n            var nextToken = this.LA(i + 1);\n            if (tokenMatcher(nextToken, currPath[i]) === false) {\n              // mismatch in current path\n              // try the next pth\n              continue nextPath;\n            }\n          }\n          // found a full path that matches.\n          // this will also work for an empty ALT as the loop will be skipped\n          return t;\n        }\n        // none of the paths for the current alternative matched\n        // try the next alternative\n      }\n      // none of the alternatives could be matched\n      return undefined;\n    };\n  }\n}\nexports.buildAlternativesLookAheadFunc = buildAlternativesLookAheadFunc;\nfunction buildSingleAlternativeLookaheadFunction(alt, tokenMatcher, dynamicTokensEnabled) {\n  var areAllOneTokenLookahead = (0, every_1.default)(alt, function (currPath) {\n    return currPath.length === 1;\n  });\n  var numOfPaths = alt.length;\n  // optimized (common) case of all the lookaheads paths requiring only\n  // a single token lookahead.\n  if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n    var singleTokensTypes = (0, flatten_1.default)(alt);\n    if (singleTokensTypes.length === 1 && (0, isEmpty_1.default)(singleTokensTypes[0].categoryMatches)) {\n      var expectedTokenType = singleTokensTypes[0];\n      var expectedTokenUniqueKey_1 = expectedTokenType.tokenTypeIdx;\n      return function () {\n        return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey_1;\n      };\n    } else {\n      var choiceToAlt_2 = (0, reduce_1.default)(singleTokensTypes, function (result, currTokType, idx) {\n        result[currTokType.tokenTypeIdx] = true;\n        (0, forEach_1.default)(currTokType.categoryMatches, function (currExtendingType) {\n          result[currExtendingType] = true;\n        });\n        return result;\n      }, []);\n      return function () {\n        var nextToken = this.LA(1);\n        return choiceToAlt_2[nextToken.tokenTypeIdx] === true;\n      };\n    }\n  } else {\n    return function () {\n      nextPath: for (var j = 0; j < numOfPaths; j++) {\n        var currPath = alt[j];\n        var currPathLength = currPath.length;\n        for (var i = 0; i < currPathLength; i++) {\n          var nextToken = this.LA(i + 1);\n          if (tokenMatcher(nextToken, currPath[i]) === false) {\n            // mismatch in current path\n            // try the next pth\n            continue nextPath;\n          }\n        }\n        // found a full path that matches.\n        return true;\n      }\n      // none of the paths matched\n      return false;\n    };\n  }\n}\nexports.buildSingleAlternativeLookaheadFunction = buildSingleAlternativeLookaheadFunction;\nvar RestDefinitionFinderWalker = /** @class */function (_super) {\n  __extends(RestDefinitionFinderWalker, _super);\n  function RestDefinitionFinderWalker(topProd, targetOccurrence, targetProdType) {\n    var _this = _super.call(this) || this;\n    _this.topProd = topProd;\n    _this.targetOccurrence = targetOccurrence;\n    _this.targetProdType = targetProdType;\n    return _this;\n  }\n  RestDefinitionFinderWalker.prototype.startWalking = function () {\n    this.walk(this.topProd);\n    return this.restDef;\n  };\n  RestDefinitionFinderWalker.prototype.checkIsTarget = function (node, expectedProdType, currRest, prevRest) {\n    if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdType) {\n      this.restDef = currRest.concat(prevRest);\n      return true;\n    }\n    // performance optimization, do not iterate over the entire Grammar ast after we have found the target\n    return false;\n  };\n  RestDefinitionFinderWalker.prototype.walkOption = function (optionProd, currRest, prevRest) {\n    if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {\n      _super.prototype.walkOption.call(this, optionProd, currRest, prevRest);\n    }\n  };\n  RestDefinitionFinderWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {\n    if (!this.checkIsTarget(atLeastOneProd, PROD_TYPE.REPETITION_MANDATORY, currRest, prevRest)) {\n      _super.prototype.walkOption.call(this, atLeastOneProd, currRest, prevRest);\n    }\n  };\n  RestDefinitionFinderWalker.prototype.walkAtLeastOneSep = function (atLeastOneSepProd, currRest, prevRest) {\n    if (!this.checkIsTarget(atLeastOneSepProd, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currRest, prevRest)) {\n      _super.prototype.walkOption.call(this, atLeastOneSepProd, currRest, prevRest);\n    }\n  };\n  RestDefinitionFinderWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {\n    if (!this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)) {\n      _super.prototype.walkOption.call(this, manyProd, currRest, prevRest);\n    }\n  };\n  RestDefinitionFinderWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {\n    if (!this.checkIsTarget(manySepProd, PROD_TYPE.REPETITION_WITH_SEPARATOR, currRest, prevRest)) {\n      _super.prototype.walkOption.call(this, manySepProd, currRest, prevRest);\n    }\n  };\n  return RestDefinitionFinderWalker;\n}(rest_1.RestWalker);\n/**\n * Returns the definition of a target production in a top level level rule.\n */\nvar InsideDefinitionFinderVisitor = /** @class */function (_super) {\n  __extends(InsideDefinitionFinderVisitor, _super);\n  function InsideDefinitionFinderVisitor(targetOccurrence, targetProdType, targetRef) {\n    var _this = _super.call(this) || this;\n    _this.targetOccurrence = targetOccurrence;\n    _this.targetProdType = targetProdType;\n    _this.targetRef = targetRef;\n    _this.result = [];\n    return _this;\n  }\n  InsideDefinitionFinderVisitor.prototype.checkIsTarget = function (node, expectedProdName) {\n    if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdName && (this.targetRef === undefined || node === this.targetRef)) {\n      this.result = node.definition;\n    }\n  };\n  InsideDefinitionFinderVisitor.prototype.visitOption = function (node) {\n    this.checkIsTarget(node, PROD_TYPE.OPTION);\n  };\n  InsideDefinitionFinderVisitor.prototype.visitRepetition = function (node) {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION);\n  };\n  InsideDefinitionFinderVisitor.prototype.visitRepetitionMandatory = function (node) {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY);\n  };\n  InsideDefinitionFinderVisitor.prototype.visitRepetitionMandatoryWithSeparator = function (node) {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR);\n  };\n  InsideDefinitionFinderVisitor.prototype.visitRepetitionWithSeparator = function (node) {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR);\n  };\n  InsideDefinitionFinderVisitor.prototype.visitAlternation = function (node) {\n    this.checkIsTarget(node, PROD_TYPE.ALTERNATION);\n  };\n  return InsideDefinitionFinderVisitor;\n}(gast_2.GAstVisitor);\nfunction initializeArrayOfArrays(size) {\n  var result = new Array(size);\n  for (var i = 0; i < size; i++) {\n    result[i] = [];\n  }\n  return result;\n}\n/**\n * A sort of hash function between a Path in the grammar and a string.\n * Note that this returns multiple \"hashes\" to support the scenario of token categories.\n * -  A single path with categories may match multiple **actual** paths.\n */\nfunction pathToHashKeys(path) {\n  var keys = [\"\"];\n  for (var i = 0; i < path.length; i++) {\n    var tokType = path[i];\n    var longerKeys = [];\n    for (var j = 0; j < keys.length; j++) {\n      var currShorterKey = keys[j];\n      longerKeys.push(currShorterKey + \"_\" + tokType.tokenTypeIdx);\n      for (var t = 0; t < tokType.categoryMatches.length; t++) {\n        var categoriesKeySuffix = \"_\" + tokType.categoryMatches[t];\n        longerKeys.push(currShorterKey + categoriesKeySuffix);\n      }\n    }\n    keys = longerKeys;\n  }\n  return keys;\n}\n/**\n * Imperative style due to being called from a hot spot\n */\nfunction isUniquePrefixHash(altKnownPathsKeys, searchPathKeys, idx) {\n  for (var currAltIdx = 0; currAltIdx < altKnownPathsKeys.length; currAltIdx++) {\n    // We only want to test vs the other alternatives\n    if (currAltIdx === idx) {\n      continue;\n    }\n    var otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx];\n    for (var searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++) {\n      var searchKey = searchPathKeys[searchIdx];\n      if (otherAltKnownPathsKeys[searchKey] === true) {\n        return false;\n      }\n    }\n  }\n  // None of the SearchPathKeys were found in any of the other alternatives\n  return true;\n}\nfunction lookAheadSequenceFromAlternatives(altsDefs, k) {\n  var partialAlts = (0, map_1.default)(altsDefs, function (currAlt) {\n    return (0, interpreter_1.possiblePathsFrom)([currAlt], 1);\n  });\n  var finalResult = initializeArrayOfArrays(partialAlts.length);\n  var altsHashes = (0, map_1.default)(partialAlts, function (currAltPaths) {\n    var dict = {};\n    (0, forEach_1.default)(currAltPaths, function (item) {\n      var keys = pathToHashKeys(item.partialPath);\n      (0, forEach_1.default)(keys, function (currKey) {\n        dict[currKey] = true;\n      });\n    });\n    return dict;\n  });\n  var newData = partialAlts;\n  // maxLookahead loop\n  for (var pathLength = 1; pathLength <= k; pathLength++) {\n    var currDataset = newData;\n    newData = initializeArrayOfArrays(currDataset.length);\n    var _loop_1 = function (altIdx) {\n      var currAltPathsAndSuffixes = currDataset[altIdx];\n      // paths in current alternative loop\n      for (var currPathIdx = 0; currPathIdx < currAltPathsAndSuffixes.length; currPathIdx++) {\n        var currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath;\n        var suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef;\n        var prefixKeys = pathToHashKeys(currPathPrefix);\n        var isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx);\n        // End of the line for this path.\n        if (isUnique || (0, isEmpty_1.default)(suffixDef) || currPathPrefix.length === k) {\n          var currAltResult = finalResult[altIdx];\n          // TODO: Can we implement a containsPath using Maps/Dictionaries?\n          if (containsPath(currAltResult, currPathPrefix) === false) {\n            currAltResult.push(currPathPrefix);\n            // Update all new  keys for the current path.\n            for (var j = 0; j < prefixKeys.length; j++) {\n              var currKey = prefixKeys[j];\n              altsHashes[altIdx][currKey] = true;\n            }\n          }\n        }\n        // Expand longer paths\n        else {\n          var newPartialPathsAndSuffixes = (0, interpreter_1.possiblePathsFrom)(suffixDef, pathLength + 1, currPathPrefix);\n          newData[altIdx] = newData[altIdx].concat(newPartialPathsAndSuffixes);\n          // Update keys for new known paths\n          (0, forEach_1.default)(newPartialPathsAndSuffixes, function (item) {\n            var prefixKeys = pathToHashKeys(item.partialPath);\n            (0, forEach_1.default)(prefixKeys, function (key) {\n              altsHashes[altIdx][key] = true;\n            });\n          });\n        }\n      }\n    };\n    // alternatives loop\n    for (var altIdx = 0; altIdx < currDataset.length; altIdx++) {\n      _loop_1(altIdx);\n    }\n  }\n  return finalResult;\n}\nexports.lookAheadSequenceFromAlternatives = lookAheadSequenceFromAlternatives;\nfunction getLookaheadPathsForOr(occurrence, ruleGrammar, k, orProd) {\n  var visitor = new InsideDefinitionFinderVisitor(occurrence, PROD_TYPE.ALTERNATION, orProd);\n  ruleGrammar.accept(visitor);\n  return lookAheadSequenceFromAlternatives(visitor.result, k);\n}\nexports.getLookaheadPathsForOr = getLookaheadPathsForOr;\nfunction getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k) {\n  var insideDefVisitor = new InsideDefinitionFinderVisitor(occurrence, prodType);\n  ruleGrammar.accept(insideDefVisitor);\n  var insideDef = insideDefVisitor.result;\n  var afterDefWalker = new RestDefinitionFinderWalker(ruleGrammar, occurrence, prodType);\n  var afterDef = afterDefWalker.startWalking();\n  var insideFlat = new gast_1.Alternative({\n    definition: insideDef\n  });\n  var afterFlat = new gast_1.Alternative({\n    definition: afterDef\n  });\n  return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k);\n}\nexports.getLookaheadPathsForOptionalProd = getLookaheadPathsForOptionalProd;\nfunction containsPath(alternative, searchPath) {\n  compareOtherPath: for (var i = 0; i < alternative.length; i++) {\n    var otherPath = alternative[i];\n    if (otherPath.length !== searchPath.length) {\n      continue;\n    }\n    for (var j = 0; j < otherPath.length; j++) {\n      var searchTok = searchPath[j];\n      var otherTok = otherPath[j];\n      var matchingTokens = searchTok === otherTok || otherTok.categoryMatchesMap[searchTok.tokenTypeIdx] !== undefined;\n      if (matchingTokens === false) {\n        continue compareOtherPath;\n      }\n    }\n    return true;\n  }\n  return false;\n}\nexports.containsPath = containsPath;\nfunction isStrictPrefixOfPath(prefix, other) {\n  return prefix.length < other.length && (0, every_1.default)(prefix, function (tokType, idx) {\n    var otherTokType = other[idx];\n    return tokType === otherTokType || otherTokType.categoryMatchesMap[tokType.tokenTypeIdx];\n  });\n}\nexports.isStrictPrefixOfPath = isStrictPrefixOfPath;\nfunction areTokenCategoriesNotUsed(lookAheadPaths) {\n  return (0, every_1.default)(lookAheadPaths, function (singleAltPaths) {\n    return (0, every_1.default)(singleAltPaths, function (singlePath) {\n      return (0, every_1.default)(singlePath, function (token) {\n        return (0, isEmpty_1.default)(token.categoryMatches);\n      });\n    });\n  });\n}\nexports.areTokenCategoriesNotUsed = areTokenCategoriesNotUsed;","map":{"version":3,"names":["isEmpty_1","__importDefault","require","flatten_1","every_1","map_1","forEach_1","has_1","reduce_1","interpreter_1","rest_1","tokens_1","gast_1","gast_2","PROD_TYPE","exports","getProdType","prod","Option","OPTION","Repetition","REPETITION","RepetitionMandatory","REPETITION_MANDATORY","RepetitionMandatoryWithSeparator","REPETITION_MANDATORY_WITH_SEPARATOR","RepetitionWithSeparator","REPETITION_WITH_SEPARATOR","Alternation","ALTERNATION","Error","getLookaheadPaths","options","occurrence","rule","prodType","maxLookahead","type","getLookaheadPathsForOr","getLookaheadPathsForOptionalProd","buildLookaheadFuncForOr","ruleGrammar","hasPredicates","dynamicTokensEnabled","laFuncBuilder","lookAheadPaths","tokenMatcher","areTokenCategoriesNotUsed","tokenStructuredMatcherNoCategories","tokenStructuredMatcher","buildLookaheadFuncForOptionalProd","k","lookaheadBuilder","buildAlternativesLookAheadFunc","alts","numOfAlts","length","areAllOneTokenLookahead","default","currAlt","currPath","orAlts","predicates","GATE","t","currNumOfPaths","currPredicate","undefined","call","nextPath","j","currPathLength","i","nextToken","LA","singleTokenAlts","choiceToAlt_1","result","idx","currTokType","tokenTypeIdx","categoryMatches","currExtendingType","buildSingleAlternativeLookaheadFunction","alt","numOfPaths","singleTokensTypes","expectedTokenType","expectedTokenUniqueKey_1","choiceToAlt_2","RestDefinitionFinderWalker","_super","__extends","topProd","targetOccurrence","targetProdType","_this","prototype","startWalking","walk","restDef","checkIsTarget","node","expectedProdType","currRest","prevRest","concat","walkOption","optionProd","walkAtLeastOne","atLeastOneProd","walkAtLeastOneSep","atLeastOneSepProd","walkMany","manyProd","walkManySep","manySepProd","RestWalker","InsideDefinitionFinderVisitor","targetRef","expectedProdName","definition","visitOption","visitRepetition","visitRepetitionMandatory","visitRepetitionMandatoryWithSeparator","visitRepetitionWithSeparator","visitAlternation","GAstVisitor","initializeArrayOfArrays","size","Array","pathToHashKeys","path","keys","tokType","longerKeys","currShorterKey","push","categoriesKeySuffix","isUniquePrefixHash","altKnownPathsKeys","searchPathKeys","currAltIdx","otherAltKnownPathsKeys","searchIdx","searchKey","lookAheadSequenceFromAlternatives","altsDefs","partialAlts","possiblePathsFrom","finalResult","altsHashes","currAltPaths","dict","item","partialPath","currKey","newData","pathLength","currDataset","altIdx","currAltPathsAndSuffixes","currPathIdx","currPathPrefix","suffixDef","prefixKeys","isUnique","currAltResult","containsPath","newPartialPathsAndSuffixes","key","orProd","visitor","accept","insideDefVisitor","insideDef","afterDefWalker","afterDef","insideFlat","Alternative","afterFlat","alternative","searchPath","compareOtherPath","otherPath","searchTok","otherTok","matchingTokens","categoryMatchesMap","isStrictPrefixOfPath","prefix","other","otherTokType","singleAltPaths","singlePath","token"],"sources":["/Users/rociopichardo/Desktop/PFhenryFront/restaurante-pf-front/node_modules/chevrotain/src/parse/grammar/lookahead.ts"],"sourcesContent":["import isEmpty from \"lodash/isEmpty\"\nimport flatten from \"lodash/flatten\"\nimport every from \"lodash/every\"\nimport map from \"lodash/map\"\nimport forEach from \"lodash/forEach\"\nimport has from \"lodash/has\"\nimport reduce from \"lodash/reduce\"\nimport { possiblePathsFrom } from \"./interpreter\"\nimport { RestWalker } from \"./rest\"\nimport { Predicate, TokenMatcher } from \"../parser/parser\"\nimport {\n  tokenStructuredMatcher,\n  tokenStructuredMatcherNoCategories\n} from \"../../scan/tokens\"\nimport {\n  Alternation,\n  Alternative as AlternativeGAST,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator\n} from \"@chevrotain/gast\"\nimport { GAstVisitor } from \"@chevrotain/gast\"\nimport {\n  IOrAlt,\n  IProduction,\n  IProductionWithOccurrence,\n  LookaheadSequence,\n  LookaheadProductionType,\n  Rule,\n  TokenType,\n  BaseParser\n} from \"@chevrotain/types\"\n\nexport enum PROD_TYPE {\n  OPTION,\n  REPETITION,\n  REPETITION_MANDATORY,\n  REPETITION_MANDATORY_WITH_SEPARATOR,\n  REPETITION_WITH_SEPARATOR,\n  ALTERNATION\n}\n\nexport function getProdType(\n  prod: IProduction | LookaheadProductionType\n): PROD_TYPE {\n  /* istanbul ignore else */\n  if (prod instanceof Option || prod === \"Option\") {\n    return PROD_TYPE.OPTION\n  } else if (prod instanceof Repetition || prod === \"Repetition\") {\n    return PROD_TYPE.REPETITION\n  } else if (\n    prod instanceof RepetitionMandatory ||\n    prod === \"RepetitionMandatory\"\n  ) {\n    return PROD_TYPE.REPETITION_MANDATORY\n  } else if (\n    prod instanceof RepetitionMandatoryWithSeparator ||\n    prod === \"RepetitionMandatoryWithSeparator\"\n  ) {\n    return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR\n  } else if (\n    prod instanceof RepetitionWithSeparator ||\n    prod === \"RepetitionWithSeparator\"\n  ) {\n    return PROD_TYPE.REPETITION_WITH_SEPARATOR\n  } else if (prod instanceof Alternation || prod === \"Alternation\") {\n    return PROD_TYPE.ALTERNATION\n  } else {\n    throw Error(\"non exhaustive match\")\n  }\n}\n\nexport function getLookaheadPaths(options: {\n  occurrence: number\n  rule: Rule\n  prodType: LookaheadProductionType\n  maxLookahead: number\n}): LookaheadSequence[] {\n  const { occurrence, rule, prodType, maxLookahead } = options\n  const type = getProdType(prodType)\n  if (type === PROD_TYPE.ALTERNATION) {\n    return getLookaheadPathsForOr(occurrence, rule, maxLookahead)\n  } else {\n    return getLookaheadPathsForOptionalProd(\n      occurrence,\n      rule,\n      type,\n      maxLookahead\n    )\n  }\n}\n\nexport function buildLookaheadFuncForOr(\n  occurrence: number,\n  ruleGrammar: Rule,\n  maxLookahead: number,\n  hasPredicates: boolean,\n  dynamicTokensEnabled: boolean,\n  laFuncBuilder: Function\n): (orAlts?: IOrAlt<any>[]) => number | undefined {\n  const lookAheadPaths = getLookaheadPathsForOr(\n    occurrence,\n    ruleGrammar,\n    maxLookahead\n  )\n\n  const tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)\n    ? tokenStructuredMatcherNoCategories\n    : tokenStructuredMatcher\n\n  return laFuncBuilder(\n    lookAheadPaths,\n    hasPredicates,\n    tokenMatcher,\n    dynamicTokensEnabled\n  )\n}\n\n/**\n *  When dealing with an Optional production (OPTION/MANY/2nd iteration of AT_LEAST_ONE/...) we need to compare\n *  the lookahead \"inside\" the production and the lookahead immediately \"after\" it in the same top level rule (context free).\n *\n *  Example: given a production:\n *  ABC(DE)?DF\n *\n *  The optional '(DE)?' should only be entered if we see 'DE'. a single Token 'D' is not sufficient to distinguish between the two\n *  alternatives.\n *\n *  @returns A Lookahead function which will return true IFF the parser should parse the Optional production.\n */\nexport function buildLookaheadFuncForOptionalProd(\n  occurrence: number,\n  ruleGrammar: Rule,\n  k: number,\n  dynamicTokensEnabled: boolean,\n  prodType: PROD_TYPE,\n  lookaheadBuilder: (\n    lookAheadSequence: LookaheadSequence,\n    tokenMatcher: TokenMatcher,\n    dynamicTokensEnabled: boolean\n  ) => () => boolean\n): () => boolean {\n  const lookAheadPaths = getLookaheadPathsForOptionalProd(\n    occurrence,\n    ruleGrammar,\n    prodType,\n    k\n  )\n\n  const tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)\n    ? tokenStructuredMatcherNoCategories\n    : tokenStructuredMatcher\n\n  return lookaheadBuilder(lookAheadPaths[0], tokenMatcher, dynamicTokensEnabled)\n}\n\nexport type Alternative = TokenType[][]\n\nexport function buildAlternativesLookAheadFunc(\n  alts: LookaheadSequence[],\n  hasPredicates: boolean,\n  tokenMatcher: TokenMatcher,\n  dynamicTokensEnabled: boolean\n): (orAlts: IOrAlt<any>[]) => number | undefined {\n  const numOfAlts = alts.length\n  const areAllOneTokenLookahead = every(alts, (currAlt) => {\n    return every(currAlt, (currPath) => {\n      return currPath.length === 1\n    })\n  })\n\n  // This version takes into account the predicates as well.\n  if (hasPredicates) {\n    /**\n     * @returns {number} - The chosen alternative index\n     */\n    return function (\n      this: BaseParser,\n      orAlts: IOrAlt<any>[]\n    ): number | undefined {\n      // unfortunately the predicates must be extracted every single time\n      // as they cannot be cached due to references to parameters(vars) which are no longer valid.\n      // note that in the common case of no predicates, no cpu time will be wasted on this (see else block)\n      const predicates: (Predicate | undefined)[] = map(\n        orAlts,\n        (currAlt) => currAlt.GATE\n      )\n\n      for (let t = 0; t < numOfAlts; t++) {\n        const currAlt = alts[t]\n        const currNumOfPaths = currAlt.length\n\n        const currPredicate = predicates[t]\n        if (currPredicate !== undefined && currPredicate.call(this) === false) {\n          // if the predicate does not match there is no point in checking the paths\n          continue\n        }\n        nextPath: for (let j = 0; j < currNumOfPaths; j++) {\n          const currPath = currAlt[j]\n          const currPathLength = currPath.length\n          for (let i = 0; i < currPathLength; i++) {\n            const nextToken = this.LA(i + 1)\n            if (tokenMatcher(nextToken, currPath[i]) === false) {\n              // mismatch in current path\n              // try the next pth\n              continue nextPath\n            }\n          }\n          // found a full path that matches.\n          // this will also work for an empty ALT as the loop will be skipped\n          return t\n        }\n        // none of the paths for the current alternative matched\n        // try the next alternative\n      }\n      // none of the alternatives could be matched\n      return undefined\n    }\n  } else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n    // optimized (common) case of all the lookaheads paths requiring only\n    // a single token lookahead. These Optimizations cannot work if dynamically defined Tokens are used.\n    const singleTokenAlts = map(alts, (currAlt) => {\n      return flatten(currAlt)\n    })\n\n    const choiceToAlt = reduce(\n      singleTokenAlts,\n      (result, currAlt, idx) => {\n        forEach(currAlt, (currTokType) => {\n          if (!has(result, currTokType.tokenTypeIdx!)) {\n            result[currTokType.tokenTypeIdx!] = idx\n          }\n          forEach(currTokType.categoryMatches!, (currExtendingType) => {\n            if (!has(result, currExtendingType)) {\n              result[currExtendingType] = idx\n            }\n          })\n        })\n        return result\n      },\n      {} as Record<number, number>\n    )\n\n    /**\n     * @returns {number} - The chosen alternative index\n     */\n    return function (this: BaseParser): number {\n      const nextToken = this.LA(1)\n      return choiceToAlt[nextToken.tokenTypeIdx]\n    }\n  } else {\n    // optimized lookahead without needing to check the predicates at all.\n    // this causes code duplication which is intentional to improve performance.\n    /**\n     * @returns {number} - The chosen alternative index\n     */\n    return function (this: BaseParser): number | undefined {\n      for (let t = 0; t < numOfAlts; t++) {\n        const currAlt = alts[t]\n        const currNumOfPaths = currAlt.length\n        nextPath: for (let j = 0; j < currNumOfPaths; j++) {\n          const currPath = currAlt[j]\n          const currPathLength = currPath.length\n          for (let i = 0; i < currPathLength; i++) {\n            const nextToken = this.LA(i + 1)\n            if (tokenMatcher(nextToken, currPath[i]) === false) {\n              // mismatch in current path\n              // try the next pth\n              continue nextPath\n            }\n          }\n          // found a full path that matches.\n          // this will also work for an empty ALT as the loop will be skipped\n          return t\n        }\n        // none of the paths for the current alternative matched\n        // try the next alternative\n      }\n      // none of the alternatives could be matched\n      return undefined\n    }\n  }\n}\n\nexport function buildSingleAlternativeLookaheadFunction(\n  alt: LookaheadSequence,\n  tokenMatcher: TokenMatcher,\n  dynamicTokensEnabled: boolean\n): () => boolean {\n  const areAllOneTokenLookahead = every(alt, (currPath) => {\n    return currPath.length === 1\n  })\n\n  const numOfPaths = alt.length\n\n  // optimized (common) case of all the lookaheads paths requiring only\n  // a single token lookahead.\n  if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n    const singleTokensTypes = flatten(alt)\n\n    if (\n      singleTokensTypes.length === 1 &&\n      isEmpty((<any>singleTokensTypes[0]).categoryMatches)\n    ) {\n      const expectedTokenType = singleTokensTypes[0]\n      const expectedTokenUniqueKey = (<any>expectedTokenType).tokenTypeIdx\n\n      return function (this: BaseParser): boolean {\n        return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey\n      }\n    } else {\n      const choiceToAlt = reduce(\n        singleTokensTypes,\n        (result, currTokType, idx) => {\n          result[currTokType.tokenTypeIdx!] = true\n          forEach(currTokType.categoryMatches!, (currExtendingType) => {\n            result[currExtendingType] = true\n          })\n          return result\n        },\n        [] as boolean[]\n      )\n\n      return function (this: BaseParser): boolean {\n        const nextToken = this.LA(1)\n        return choiceToAlt[nextToken.tokenTypeIdx] === true\n      }\n    }\n  } else {\n    return function (this: BaseParser): boolean {\n      nextPath: for (let j = 0; j < numOfPaths; j++) {\n        const currPath = alt[j]\n        const currPathLength = currPath.length\n        for (let i = 0; i < currPathLength; i++) {\n          const nextToken = this.LA(i + 1)\n          if (tokenMatcher(nextToken, currPath[i]) === false) {\n            // mismatch in current path\n            // try the next pth\n            continue nextPath\n          }\n        }\n        // found a full path that matches.\n        return true\n      }\n\n      // none of the paths matched\n      return false\n    }\n  }\n}\n\nclass RestDefinitionFinderWalker extends RestWalker {\n  private restDef: IProduction[]\n\n  constructor(\n    private topProd: Rule,\n    private targetOccurrence: number,\n    private targetProdType: PROD_TYPE\n  ) {\n    super()\n  }\n\n  startWalking(): IProduction[] {\n    this.walk(this.topProd)\n    return this.restDef\n  }\n\n  private checkIsTarget(\n    node: IProductionWithOccurrence,\n    expectedProdType: PROD_TYPE,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): boolean {\n    if (\n      node.idx === this.targetOccurrence &&\n      this.targetProdType === expectedProdType\n    ) {\n      this.restDef = currRest.concat(prevRest)\n      return true\n    }\n    // performance optimization, do not iterate over the entire Grammar ast after we have found the target\n    return false\n  }\n\n  walkOption(\n    optionProd: Option,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {\n      super.walkOption(optionProd, currRest, prevRest)\n    }\n  }\n\n  walkAtLeastOne(\n    atLeastOneProd: RepetitionMandatory,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    if (\n      !this.checkIsTarget(\n        atLeastOneProd,\n        PROD_TYPE.REPETITION_MANDATORY,\n        currRest,\n        prevRest\n      )\n    ) {\n      super.walkOption(atLeastOneProd, currRest, prevRest)\n    }\n  }\n\n  walkAtLeastOneSep(\n    atLeastOneSepProd: RepetitionMandatoryWithSeparator,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    if (\n      !this.checkIsTarget(\n        atLeastOneSepProd,\n        PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR,\n        currRest,\n        prevRest\n      )\n    ) {\n      super.walkOption(atLeastOneSepProd, currRest, prevRest)\n    }\n  }\n\n  walkMany(\n    manyProd: Repetition,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    if (\n      !this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)\n    ) {\n      super.walkOption(manyProd, currRest, prevRest)\n    }\n  }\n\n  walkManySep(\n    manySepProd: RepetitionWithSeparator,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    if (\n      !this.checkIsTarget(\n        manySepProd,\n        PROD_TYPE.REPETITION_WITH_SEPARATOR,\n        currRest,\n        prevRest\n      )\n    ) {\n      super.walkOption(manySepProd, currRest, prevRest)\n    }\n  }\n}\n\n/**\n * Returns the definition of a target production in a top level level rule.\n */\nclass InsideDefinitionFinderVisitor extends GAstVisitor {\n  public result: IProduction[] = []\n\n  constructor(\n    private targetOccurrence: number,\n    private targetProdType: PROD_TYPE,\n    private targetRef?: any\n  ) {\n    super()\n  }\n\n  private checkIsTarget(\n    node: { definition: IProduction[] } & IProductionWithOccurrence,\n    expectedProdName: PROD_TYPE\n  ): void {\n    if (\n      node.idx === this.targetOccurrence &&\n      this.targetProdType === expectedProdName &&\n      (this.targetRef === undefined || node === this.targetRef)\n    ) {\n      this.result = node.definition\n    }\n  }\n\n  public visitOption(node: Option): void {\n    this.checkIsTarget(node, PROD_TYPE.OPTION)\n  }\n\n  public visitRepetition(node: Repetition): void {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION)\n  }\n\n  public visitRepetitionMandatory(node: RepetitionMandatory): void {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY)\n  }\n\n  public visitRepetitionMandatoryWithSeparator(\n    node: RepetitionMandatoryWithSeparator\n  ): void {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR)\n  }\n\n  public visitRepetitionWithSeparator(node: RepetitionWithSeparator): void {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR)\n  }\n\n  public visitAlternation(node: Alternation): void {\n    this.checkIsTarget(node, PROD_TYPE.ALTERNATION)\n  }\n}\n\nfunction initializeArrayOfArrays(size: number): any[][] {\n  const result = new Array(size)\n  for (let i = 0; i < size; i++) {\n    result[i] = []\n  }\n  return result\n}\n\n/**\n * A sort of hash function between a Path in the grammar and a string.\n * Note that this returns multiple \"hashes\" to support the scenario of token categories.\n * -  A single path with categories may match multiple **actual** paths.\n */\nfunction pathToHashKeys(path: TokenType[]): string[] {\n  let keys = [\"\"]\n  for (let i = 0; i < path.length; i++) {\n    const tokType = path[i]\n    const longerKeys = []\n    for (let j = 0; j < keys.length; j++) {\n      const currShorterKey = keys[j]\n      longerKeys.push(currShorterKey + \"_\" + tokType.tokenTypeIdx)\n      for (let t = 0; t < tokType.categoryMatches!.length; t++) {\n        const categoriesKeySuffix = \"_\" + tokType.categoryMatches![t]\n        longerKeys.push(currShorterKey + categoriesKeySuffix)\n      }\n    }\n    keys = longerKeys\n  }\n  return keys\n}\n\n/**\n * Imperative style due to being called from a hot spot\n */\nfunction isUniquePrefixHash(\n  altKnownPathsKeys: Record<string, boolean>[],\n  searchPathKeys: string[],\n  idx: number\n): boolean {\n  for (\n    let currAltIdx = 0;\n    currAltIdx < altKnownPathsKeys.length;\n    currAltIdx++\n  ) {\n    // We only want to test vs the other alternatives\n    if (currAltIdx === idx) {\n      continue\n    }\n    const otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx]\n    for (let searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++) {\n      const searchKey = searchPathKeys[searchIdx]\n      if (otherAltKnownPathsKeys[searchKey] === true) {\n        return false\n      }\n    }\n  }\n  // None of the SearchPathKeys were found in any of the other alternatives\n  return true\n}\n\nexport function lookAheadSequenceFromAlternatives(\n  altsDefs: IProduction[],\n  k: number\n): LookaheadSequence[] {\n  const partialAlts = map(altsDefs, (currAlt) =>\n    possiblePathsFrom([currAlt], 1)\n  )\n  const finalResult = initializeArrayOfArrays(partialAlts.length)\n  const altsHashes = map(partialAlts, (currAltPaths) => {\n    const dict: { [key: string]: boolean } = {}\n    forEach(currAltPaths, (item) => {\n      const keys = pathToHashKeys(item.partialPath)\n      forEach(keys, (currKey) => {\n        dict[currKey] = true\n      })\n    })\n    return dict\n  })\n  let newData = partialAlts\n\n  // maxLookahead loop\n  for (let pathLength = 1; pathLength <= k; pathLength++) {\n    const currDataset = newData\n    newData = initializeArrayOfArrays(currDataset.length)\n\n    // alternatives loop\n    for (let altIdx = 0; altIdx < currDataset.length; altIdx++) {\n      const currAltPathsAndSuffixes = currDataset[altIdx]\n      // paths in current alternative loop\n      for (\n        let currPathIdx = 0;\n        currPathIdx < currAltPathsAndSuffixes.length;\n        currPathIdx++\n      ) {\n        const currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath\n        const suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef\n        const prefixKeys = pathToHashKeys(currPathPrefix)\n        const isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx)\n        // End of the line for this path.\n        if (isUnique || isEmpty(suffixDef) || currPathPrefix.length === k) {\n          const currAltResult = finalResult[altIdx]\n          // TODO: Can we implement a containsPath using Maps/Dictionaries?\n          if (containsPath(currAltResult, currPathPrefix) === false) {\n            currAltResult.push(currPathPrefix)\n            // Update all new  keys for the current path.\n            for (let j = 0; j < prefixKeys.length; j++) {\n              const currKey = prefixKeys[j]\n              altsHashes[altIdx][currKey] = true\n            }\n          }\n        }\n        // Expand longer paths\n        else {\n          const newPartialPathsAndSuffixes = possiblePathsFrom(\n            suffixDef,\n            pathLength + 1,\n            currPathPrefix\n          )\n          newData[altIdx] = newData[altIdx].concat(newPartialPathsAndSuffixes)\n\n          // Update keys for new known paths\n          forEach(newPartialPathsAndSuffixes, (item) => {\n            const prefixKeys = pathToHashKeys(item.partialPath)\n            forEach(prefixKeys, (key) => {\n              altsHashes[altIdx][key] = true\n            })\n          })\n        }\n      }\n    }\n  }\n\n  return finalResult\n}\n\nexport function getLookaheadPathsForOr(\n  occurrence: number,\n  ruleGrammar: Rule,\n  k: number,\n  orProd?: Alternation\n): LookaheadSequence[] {\n  const visitor = new InsideDefinitionFinderVisitor(\n    occurrence,\n    PROD_TYPE.ALTERNATION,\n    orProd\n  )\n  ruleGrammar.accept(visitor)\n  return lookAheadSequenceFromAlternatives(visitor.result, k)\n}\n\nexport function getLookaheadPathsForOptionalProd(\n  occurrence: number,\n  ruleGrammar: Rule,\n  prodType: PROD_TYPE,\n  k: number\n): LookaheadSequence[] {\n  const insideDefVisitor = new InsideDefinitionFinderVisitor(\n    occurrence,\n    prodType\n  )\n  ruleGrammar.accept(insideDefVisitor)\n  const insideDef = insideDefVisitor.result\n\n  const afterDefWalker = new RestDefinitionFinderWalker(\n    ruleGrammar,\n    occurrence,\n    prodType\n  )\n  const afterDef = afterDefWalker.startWalking()\n\n  const insideFlat = new AlternativeGAST({ definition: insideDef })\n  const afterFlat = new AlternativeGAST({ definition: afterDef })\n\n  return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k)\n}\n\nexport function containsPath(\n  alternative: Alternative,\n  searchPath: TokenType[]\n): boolean {\n  compareOtherPath: for (let i = 0; i < alternative.length; i++) {\n    const otherPath = alternative[i]\n    if (otherPath.length !== searchPath.length) {\n      continue\n    }\n    for (let j = 0; j < otherPath.length; j++) {\n      const searchTok = searchPath[j]\n      const otherTok = otherPath[j]\n\n      const matchingTokens =\n        searchTok === otherTok ||\n        otherTok.categoryMatchesMap![searchTok.tokenTypeIdx!] !== undefined\n      if (matchingTokens === false) {\n        continue compareOtherPath\n      }\n    }\n    return true\n  }\n\n  return false\n}\n\nexport function isStrictPrefixOfPath(\n  prefix: TokenType[],\n  other: TokenType[]\n): boolean {\n  return (\n    prefix.length < other.length &&\n    every(prefix, (tokType, idx) => {\n      const otherTokType = other[idx]\n      return (\n        tokType === otherTokType ||\n        otherTokType.categoryMatchesMap![tokType.tokenTypeIdx!]\n      )\n    })\n  )\n}\n\nexport function areTokenCategoriesNotUsed(\n  lookAheadPaths: LookaheadSequence[]\n): boolean {\n  return every(lookAheadPaths, (singleAltPaths) =>\n    every(singleAltPaths, (singlePath) =>\n      every(singlePath, (token) => isEmpty(token.categoryMatches!))\n    )\n  )\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}