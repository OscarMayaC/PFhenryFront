{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isTokenType = exports.hasExtendingTokensTypesMapProperty = exports.hasExtendingTokensTypesProperty = exports.hasCategoriesProperty = exports.hasShortKeyProperty = exports.singleAssignCategoriesToksMap = exports.assignCategoriesMapProp = exports.assignCategoriesTokensProp = exports.assignTokenDefaultProps = exports.expandCategories = exports.augmentTokenTypes = exports.tokenIdxToClass = exports.tokenShortNameIdx = exports.tokenStructuredMatcherNoCategories = exports.tokenStructuredMatcher = void 0;\nvar isEmpty_1 = __importDefault(require(\"lodash/isEmpty\"));\nvar compact_1 = __importDefault(require(\"lodash/compact\"));\nvar isArray_1 = __importDefault(require(\"lodash/isArray\"));\nvar flatten_1 = __importDefault(require(\"lodash/flatten\"));\nvar difference_1 = __importDefault(require(\"lodash/difference\"));\nvar map_1 = __importDefault(require(\"lodash/map\"));\nvar forEach_1 = __importDefault(require(\"lodash/forEach\"));\nvar has_1 = __importDefault(require(\"lodash/has\"));\nvar includes_1 = __importDefault(require(\"lodash/includes\"));\nvar clone_1 = __importDefault(require(\"lodash/clone\"));\nfunction tokenStructuredMatcher(tokInstance, tokConstructor) {\n  var instanceType = tokInstance.tokenTypeIdx;\n  if (instanceType === tokConstructor.tokenTypeIdx) {\n    return true;\n  } else {\n    return tokConstructor.isParent === true && tokConstructor.categoryMatchesMap[instanceType] === true;\n  }\n}\nexports.tokenStructuredMatcher = tokenStructuredMatcher;\n// Optimized tokenMatcher in case our grammar does not use token categories\n// Being so tiny it is much more likely to be in-lined and this avoid the function call overhead\nfunction tokenStructuredMatcherNoCategories(token, tokType) {\n  return token.tokenTypeIdx === tokType.tokenTypeIdx;\n}\nexports.tokenStructuredMatcherNoCategories = tokenStructuredMatcherNoCategories;\nexports.tokenShortNameIdx = 1;\nexports.tokenIdxToClass = {};\nfunction augmentTokenTypes(tokenTypes) {\n  // collect the parent Token Types as well.\n  var tokenTypesAndParents = expandCategories(tokenTypes);\n  // add required tokenType and categoryMatches properties\n  assignTokenDefaultProps(tokenTypesAndParents);\n  // fill up the categoryMatches\n  assignCategoriesMapProp(tokenTypesAndParents);\n  assignCategoriesTokensProp(tokenTypesAndParents);\n  (0, forEach_1.default)(tokenTypesAndParents, function (tokType) {\n    tokType.isParent = tokType.categoryMatches.length > 0;\n  });\n}\nexports.augmentTokenTypes = augmentTokenTypes;\nfunction expandCategories(tokenTypes) {\n  var result = (0, clone_1.default)(tokenTypes);\n  var categories = tokenTypes;\n  var searching = true;\n  while (searching) {\n    categories = (0, compact_1.default)((0, flatten_1.default)((0, map_1.default)(categories, function (currTokType) {\n      return currTokType.CATEGORIES;\n    })));\n    var newCategories = (0, difference_1.default)(categories, result);\n    result = result.concat(newCategories);\n    if ((0, isEmpty_1.default)(newCategories)) {\n      searching = false;\n    } else {\n      categories = newCategories;\n    }\n  }\n  return result;\n}\nexports.expandCategories = expandCategories;\nfunction assignTokenDefaultProps(tokenTypes) {\n  (0, forEach_1.default)(tokenTypes, function (currTokType) {\n    if (!hasShortKeyProperty(currTokType)) {\n      exports.tokenIdxToClass[exports.tokenShortNameIdx] = currTokType;\n      currTokType.tokenTypeIdx = exports.tokenShortNameIdx++;\n    }\n    // CATEGORIES? : TokenType | TokenType[]\n    if (hasCategoriesProperty(currTokType) && !(0, isArray_1.default)(currTokType.CATEGORIES)\n    // &&\n    // !isUndefined(currTokType.CATEGORIES.PATTERN)\n    ) {\n      currTokType.CATEGORIES = [currTokType.CATEGORIES];\n    }\n    if (!hasCategoriesProperty(currTokType)) {\n      currTokType.CATEGORIES = [];\n    }\n    if (!hasExtendingTokensTypesProperty(currTokType)) {\n      currTokType.categoryMatches = [];\n    }\n    if (!hasExtendingTokensTypesMapProperty(currTokType)) {\n      currTokType.categoryMatchesMap = {};\n    }\n  });\n}\nexports.assignTokenDefaultProps = assignTokenDefaultProps;\nfunction assignCategoriesTokensProp(tokenTypes) {\n  (0, forEach_1.default)(tokenTypes, function (currTokType) {\n    // avoid duplications\n    currTokType.categoryMatches = [];\n    (0, forEach_1.default)(currTokType.categoryMatchesMap, function (val, key) {\n      currTokType.categoryMatches.push(exports.tokenIdxToClass[key].tokenTypeIdx);\n    });\n  });\n}\nexports.assignCategoriesTokensProp = assignCategoriesTokensProp;\nfunction assignCategoriesMapProp(tokenTypes) {\n  (0, forEach_1.default)(tokenTypes, function (currTokType) {\n    singleAssignCategoriesToksMap([], currTokType);\n  });\n}\nexports.assignCategoriesMapProp = assignCategoriesMapProp;\nfunction singleAssignCategoriesToksMap(path, nextNode) {\n  (0, forEach_1.default)(path, function (pathNode) {\n    nextNode.categoryMatchesMap[pathNode.tokenTypeIdx] = true;\n  });\n  (0, forEach_1.default)(nextNode.CATEGORIES, function (nextCategory) {\n    var newPath = path.concat(nextNode);\n    // avoids infinite loops due to cyclic categories.\n    if (!(0, includes_1.default)(newPath, nextCategory)) {\n      singleAssignCategoriesToksMap(newPath, nextCategory);\n    }\n  });\n}\nexports.singleAssignCategoriesToksMap = singleAssignCategoriesToksMap;\nfunction hasShortKeyProperty(tokType) {\n  return (0, has_1.default)(tokType, \"tokenTypeIdx\");\n}\nexports.hasShortKeyProperty = hasShortKeyProperty;\nfunction hasCategoriesProperty(tokType) {\n  return (0, has_1.default)(tokType, \"CATEGORIES\");\n}\nexports.hasCategoriesProperty = hasCategoriesProperty;\nfunction hasExtendingTokensTypesProperty(tokType) {\n  return (0, has_1.default)(tokType, \"categoryMatches\");\n}\nexports.hasExtendingTokensTypesProperty = hasExtendingTokensTypesProperty;\nfunction hasExtendingTokensTypesMapProperty(tokType) {\n  return (0, has_1.default)(tokType, \"categoryMatchesMap\");\n}\nexports.hasExtendingTokensTypesMapProperty = hasExtendingTokensTypesMapProperty;\nfunction isTokenType(tokType) {\n  return (0, has_1.default)(tokType, \"tokenTypeIdx\");\n}\nexports.isTokenType = isTokenType;","map":{"version":3,"names":["isEmpty_1","__importDefault","require","compact_1","isArray_1","flatten_1","difference_1","map_1","forEach_1","has_1","includes_1","clone_1","tokenStructuredMatcher","tokInstance","tokConstructor","instanceType","tokenTypeIdx","isParent","categoryMatchesMap","exports","tokenStructuredMatcherNoCategories","token","tokType","tokenShortNameIdx","tokenIdxToClass","augmentTokenTypes","tokenTypes","tokenTypesAndParents","expandCategories","assignTokenDefaultProps","assignCategoriesMapProp","assignCategoriesTokensProp","default","categoryMatches","length","result","categories","searching","currTokType","CATEGORIES","newCategories","concat","hasShortKeyProperty","hasCategoriesProperty","hasExtendingTokensTypesProperty","hasExtendingTokensTypesMapProperty","val","key","push","singleAssignCategoriesToksMap","path","nextNode","pathNode","nextCategory","newPath","isTokenType"],"sources":["/Users/rociopichardo/Desktop/PFhenryFront/node_modules/chevrotain/src/scan/tokens.ts"],"sourcesContent":["import isEmpty from \"lodash/isEmpty\"\nimport compact from \"lodash/compact\"\nimport isArray from \"lodash/isArray\"\nimport flatten from \"lodash/flatten\"\nimport difference from \"lodash/difference\"\nimport map from \"lodash/map\"\nimport forEach from \"lodash/forEach\"\nimport has from \"lodash/has\"\nimport includes from \"lodash/includes\"\nimport clone from \"lodash/clone\"\nimport { IToken, TokenType } from \"@chevrotain/types\"\n\nexport function tokenStructuredMatcher(\n  tokInstance: IToken,\n  tokConstructor: TokenType\n) {\n  const instanceType = tokInstance.tokenTypeIdx\n  if (instanceType === tokConstructor.tokenTypeIdx) {\n    return true\n  } else {\n    return (\n      tokConstructor.isParent === true &&\n      tokConstructor.categoryMatchesMap![instanceType] === true\n    )\n  }\n}\n\n// Optimized tokenMatcher in case our grammar does not use token categories\n// Being so tiny it is much more likely to be in-lined and this avoid the function call overhead\nexport function tokenStructuredMatcherNoCategories(\n  token: IToken,\n  tokType: TokenType\n) {\n  return token.tokenTypeIdx === tokType.tokenTypeIdx\n}\n\nexport let tokenShortNameIdx = 1\nexport const tokenIdxToClass: { [tokenIdx: number]: TokenType } = {}\n\nexport function augmentTokenTypes(tokenTypes: TokenType[]): void {\n  // collect the parent Token Types as well.\n  const tokenTypesAndParents = expandCategories(tokenTypes)\n\n  // add required tokenType and categoryMatches properties\n  assignTokenDefaultProps(tokenTypesAndParents)\n\n  // fill up the categoryMatches\n  assignCategoriesMapProp(tokenTypesAndParents)\n  assignCategoriesTokensProp(tokenTypesAndParents)\n\n  forEach(tokenTypesAndParents, (tokType) => {\n    tokType.isParent = tokType.categoryMatches!.length > 0\n  })\n}\n\nexport function expandCategories(tokenTypes: TokenType[]): TokenType[] {\n  let result = clone(tokenTypes)\n\n  let categories = tokenTypes\n  let searching = true\n  while (searching) {\n    categories = compact(\n      flatten(map(categories, (currTokType) => currTokType.CATEGORIES))\n    )\n\n    const newCategories = difference(categories, result)\n\n    result = result.concat(newCategories)\n\n    if (isEmpty(newCategories)) {\n      searching = false\n    } else {\n      categories = newCategories\n    }\n  }\n  return result\n}\n\nexport function assignTokenDefaultProps(tokenTypes: TokenType[]): void {\n  forEach(tokenTypes, (currTokType) => {\n    if (!hasShortKeyProperty(currTokType)) {\n      tokenIdxToClass[tokenShortNameIdx] = currTokType\n      ;(<any>currTokType).tokenTypeIdx = tokenShortNameIdx++\n    }\n\n    // CATEGORIES? : TokenType | TokenType[]\n    if (\n      hasCategoriesProperty(currTokType) &&\n      !isArray(currTokType.CATEGORIES)\n      // &&\n      // !isUndefined(currTokType.CATEGORIES.PATTERN)\n    ) {\n      currTokType.CATEGORIES = [currTokType.CATEGORIES as unknown as TokenType]\n    }\n\n    if (!hasCategoriesProperty(currTokType)) {\n      currTokType.CATEGORIES = []\n    }\n\n    if (!hasExtendingTokensTypesProperty(currTokType)) {\n      currTokType.categoryMatches = []\n    }\n\n    if (!hasExtendingTokensTypesMapProperty(currTokType)) {\n      currTokType.categoryMatchesMap = {}\n    }\n  })\n}\n\nexport function assignCategoriesTokensProp(tokenTypes: TokenType[]): void {\n  forEach(tokenTypes, (currTokType) => {\n    // avoid duplications\n    currTokType.categoryMatches = []\n    forEach(currTokType.categoryMatchesMap!, (val, key) => {\n      currTokType.categoryMatches!.push(\n        tokenIdxToClass[key as unknown as number].tokenTypeIdx!\n      )\n    })\n  })\n}\n\nexport function assignCategoriesMapProp(tokenTypes: TokenType[]): void {\n  forEach(tokenTypes, (currTokType) => {\n    singleAssignCategoriesToksMap([], currTokType)\n  })\n}\n\nexport function singleAssignCategoriesToksMap(\n  path: TokenType[],\n  nextNode: TokenType\n): void {\n  forEach(path, (pathNode) => {\n    nextNode.categoryMatchesMap![pathNode.tokenTypeIdx!] = true\n  })\n\n  forEach(nextNode.CATEGORIES, (nextCategory) => {\n    const newPath = path.concat(nextNode)\n    // avoids infinite loops due to cyclic categories.\n    if (!includes(newPath, nextCategory)) {\n      singleAssignCategoriesToksMap(newPath, nextCategory)\n    }\n  })\n}\n\nexport function hasShortKeyProperty(tokType: TokenType): boolean {\n  return has(tokType, \"tokenTypeIdx\")\n}\n\nexport function hasCategoriesProperty(tokType: TokenType): boolean {\n  return has(tokType, \"CATEGORIES\")\n}\n\nexport function hasExtendingTokensTypesProperty(tokType: TokenType): boolean {\n  return has(tokType, \"categoryMatches\")\n}\n\nexport function hasExtendingTokensTypesMapProperty(\n  tokType: TokenType\n): boolean {\n  return has(tokType, \"categoryMatchesMap\")\n}\n\nexport function isTokenType(tokType: TokenType): boolean {\n  return has(tokType, \"tokenTypeIdx\")\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}