{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.checkPrefixAlternativesAmbiguities = exports.validateSomeNonEmptyLookaheadPath = exports.validateTooManyAlts = exports.RepetitionCollector = exports.validateAmbiguousAlternationAlternatives = exports.validateEmptyOrAlternative = exports.getFirstNoneTerminal = exports.validateNoLeftRecursion = exports.validateRuleIsOverridden = exports.validateRuleDoesNotAlreadyExist = exports.OccurrenceValidationCollector = exports.identifyProductionForDuplicates = exports.validateGrammar = exports.validateLookahead = void 0;\nvar first_1 = __importDefault(require(\"lodash/first\"));\nvar isEmpty_1 = __importDefault(require(\"lodash/isEmpty\"));\nvar drop_1 = __importDefault(require(\"lodash/drop\"));\nvar flatten_1 = __importDefault(require(\"lodash/flatten\"));\nvar filter_1 = __importDefault(require(\"lodash/filter\"));\nvar reject_1 = __importDefault(require(\"lodash/reject\"));\nvar difference_1 = __importDefault(require(\"lodash/difference\"));\nvar map_1 = __importDefault(require(\"lodash/map\"));\nvar forEach_1 = __importDefault(require(\"lodash/forEach\"));\nvar groupBy_1 = __importDefault(require(\"lodash/groupBy\"));\nvar reduce_1 = __importDefault(require(\"lodash/reduce\"));\nvar pickBy_1 = __importDefault(require(\"lodash/pickBy\"));\nvar values_1 = __importDefault(require(\"lodash/values\"));\nvar includes_1 = __importDefault(require(\"lodash/includes\"));\nvar flatMap_1 = __importDefault(require(\"lodash/flatMap\"));\nvar clone_1 = __importDefault(require(\"lodash/clone\"));\nvar parser_1 = require(\"../parser/parser\");\nvar gast_1 = require(\"@chevrotain/gast\");\nvar lookahead_1 = require(\"./lookahead\");\nvar interpreter_1 = require(\"./interpreter\");\nvar gast_2 = require(\"@chevrotain/gast\");\nvar gast_3 = require(\"@chevrotain/gast\");\nvar dropRight_1 = __importDefault(require(\"lodash/dropRight\"));\nvar compact_1 = __importDefault(require(\"lodash/compact\"));\nvar tokens_1 = require(\"../../scan/tokens\");\nfunction validateLookahead(options) {\n  var lookaheadValidationErrorMessages = options.lookaheadStrategy.validate({\n    rules: options.rules,\n    tokenTypes: options.tokenTypes,\n    grammarName: options.grammarName\n  });\n  return (0, map_1.default)(lookaheadValidationErrorMessages, function (errorMessage) {\n    return __assign({\n      type: parser_1.ParserDefinitionErrorType.CUSTOM_LOOKAHEAD_VALIDATION\n    }, errorMessage);\n  });\n}\nexports.validateLookahead = validateLookahead;\nfunction validateGrammar(topLevels, tokenTypes, errMsgProvider, grammarName) {\n  var duplicateErrors = (0, flatMap_1.default)(topLevels, function (currTopLevel) {\n    return validateDuplicateProductions(currTopLevel, errMsgProvider);\n  });\n  var termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);\n  var tooManyAltsErrors = (0, flatMap_1.default)(topLevels, function (curRule) {\n    return validateTooManyAlts(curRule, errMsgProvider);\n  });\n  var duplicateRulesError = (0, flatMap_1.default)(topLevels, function (curRule) {\n    return validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider);\n  });\n  return duplicateErrors.concat(termsNamespaceConflictErrors, tooManyAltsErrors, duplicateRulesError);\n}\nexports.validateGrammar = validateGrammar;\nfunction validateDuplicateProductions(topLevelRule, errMsgProvider) {\n  var collectorVisitor = new OccurrenceValidationCollector();\n  topLevelRule.accept(collectorVisitor);\n  var allRuleProductions = collectorVisitor.allProductions;\n  var productionGroups = (0, groupBy_1.default)(allRuleProductions, identifyProductionForDuplicates);\n  var duplicates = (0, pickBy_1.default)(productionGroups, function (currGroup) {\n    return currGroup.length > 1;\n  });\n  var errors = (0, map_1.default)((0, values_1.default)(duplicates), function (currDuplicates) {\n    var firstProd = (0, first_1.default)(currDuplicates);\n    var msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);\n    var dslName = (0, gast_1.getProductionDslName)(firstProd);\n    var defError = {\n      message: msg,\n      type: parser_1.ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\n      ruleName: topLevelRule.name,\n      dslName: dslName,\n      occurrence: firstProd.idx\n    };\n    var param = getExtraProductionArgument(firstProd);\n    if (param) {\n      defError.parameter = param;\n    }\n    return defError;\n  });\n  return errors;\n}\nfunction identifyProductionForDuplicates(prod) {\n  return \"\".concat((0, gast_1.getProductionDslName)(prod), \"_#_\").concat(prod.idx, \"_#_\").concat(getExtraProductionArgument(prod));\n}\nexports.identifyProductionForDuplicates = identifyProductionForDuplicates;\nfunction getExtraProductionArgument(prod) {\n  if (prod instanceof gast_2.Terminal) {\n    return prod.terminalType.name;\n  } else if (prod instanceof gast_2.NonTerminal) {\n    return prod.nonTerminalName;\n  } else {\n    return \"\";\n  }\n}\nvar OccurrenceValidationCollector = /** @class */function (_super) {\n  __extends(OccurrenceValidationCollector, _super);\n  function OccurrenceValidationCollector() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.allProductions = [];\n    return _this;\n  }\n  OccurrenceValidationCollector.prototype.visitNonTerminal = function (subrule) {\n    this.allProductions.push(subrule);\n  };\n  OccurrenceValidationCollector.prototype.visitOption = function (option) {\n    this.allProductions.push(option);\n  };\n  OccurrenceValidationCollector.prototype.visitRepetitionWithSeparator = function (manySep) {\n    this.allProductions.push(manySep);\n  };\n  OccurrenceValidationCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {\n    this.allProductions.push(atLeastOne);\n  };\n  OccurrenceValidationCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\n    this.allProductions.push(atLeastOneSep);\n  };\n  OccurrenceValidationCollector.prototype.visitRepetition = function (many) {\n    this.allProductions.push(many);\n  };\n  OccurrenceValidationCollector.prototype.visitAlternation = function (or) {\n    this.allProductions.push(or);\n  };\n  OccurrenceValidationCollector.prototype.visitTerminal = function (terminal) {\n    this.allProductions.push(terminal);\n  };\n  return OccurrenceValidationCollector;\n}(gast_3.GAstVisitor);\nexports.OccurrenceValidationCollector = OccurrenceValidationCollector;\nfunction validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {\n  var errors = [];\n  var occurrences = (0, reduce_1.default)(allRules, function (result, curRule) {\n    if (curRule.name === rule.name) {\n      return result + 1;\n    }\n    return result;\n  }, 0);\n  if (occurrences > 1) {\n    var errMsg = errMsgProvider.buildDuplicateRuleNameError({\n      topLevelRule: rule,\n      grammarName: className\n    });\n    errors.push({\n      message: errMsg,\n      type: parser_1.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n      ruleName: rule.name\n    });\n  }\n  return errors;\n}\nexports.validateRuleDoesNotAlreadyExist = validateRuleDoesNotAlreadyExist;\n// TODO: is there anyway to get only the rule names of rules inherited from the super grammars?\n// This is not part of the IGrammarErrorProvider because the validation cannot be performed on\n// The grammar structure, only at runtime.\nfunction validateRuleIsOverridden(ruleName, definedRulesNames, className) {\n  var errors = [];\n  var errMsg;\n  if (!(0, includes_1.default)(definedRulesNames, ruleName)) {\n    errMsg = \"Invalid rule override, rule: ->\".concat(ruleName, \"<- cannot be overridden in the grammar: ->\").concat(className, \"<-\") + \"as it is not defined in any of the super grammars \";\n    errors.push({\n      message: errMsg,\n      type: parser_1.ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\n      ruleName: ruleName\n    });\n  }\n  return errors;\n}\nexports.validateRuleIsOverridden = validateRuleIsOverridden;\nfunction validateNoLeftRecursion(topRule, currRule, errMsgProvider, path) {\n  if (path === void 0) {\n    path = [];\n  }\n  var errors = [];\n  var nextNonTerminals = getFirstNoneTerminal(currRule.definition);\n  if ((0, isEmpty_1.default)(nextNonTerminals)) {\n    return [];\n  } else {\n    var ruleName = topRule.name;\n    var foundLeftRecursion = (0, includes_1.default)(nextNonTerminals, topRule);\n    if (foundLeftRecursion) {\n      errors.push({\n        message: errMsgProvider.buildLeftRecursionError({\n          topLevelRule: topRule,\n          leftRecursionPath: path\n        }),\n        type: parser_1.ParserDefinitionErrorType.LEFT_RECURSION,\n        ruleName: ruleName\n      });\n    }\n    // we are only looking for cyclic paths leading back to the specific topRule\n    // other cyclic paths are ignored, we still need this difference to avoid infinite loops...\n    var validNextSteps = (0, difference_1.default)(nextNonTerminals, path.concat([topRule]));\n    var errorsFromNextSteps = (0, flatMap_1.default)(validNextSteps, function (currRefRule) {\n      var newPath = (0, clone_1.default)(path);\n      newPath.push(currRefRule);\n      return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);\n    });\n    return errors.concat(errorsFromNextSteps);\n  }\n}\nexports.validateNoLeftRecursion = validateNoLeftRecursion;\nfunction getFirstNoneTerminal(definition) {\n  var result = [];\n  if ((0, isEmpty_1.default)(definition)) {\n    return result;\n  }\n  var firstProd = (0, first_1.default)(definition);\n  /* istanbul ignore else */\n  if (firstProd instanceof gast_2.NonTerminal) {\n    result.push(firstProd.referencedRule);\n  } else if (firstProd instanceof gast_2.Alternative || firstProd instanceof gast_2.Option || firstProd instanceof gast_2.RepetitionMandatory || firstProd instanceof gast_2.RepetitionMandatoryWithSeparator || firstProd instanceof gast_2.RepetitionWithSeparator || firstProd instanceof gast_2.Repetition) {\n    result = result.concat(getFirstNoneTerminal(firstProd.definition));\n  } else if (firstProd instanceof gast_2.Alternation) {\n    // each sub definition in alternation is a FLAT\n    result = (0, flatten_1.default)((0, map_1.default)(firstProd.definition, function (currSubDef) {\n      return getFirstNoneTerminal(currSubDef.definition);\n    }));\n  } else if (firstProd instanceof gast_2.Terminal) {\n    // nothing to see, move along\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n  var isFirstOptional = (0, gast_1.isOptionalProd)(firstProd);\n  var hasMore = definition.length > 1;\n  if (isFirstOptional && hasMore) {\n    var rest = (0, drop_1.default)(definition);\n    return result.concat(getFirstNoneTerminal(rest));\n  } else {\n    return result;\n  }\n}\nexports.getFirstNoneTerminal = getFirstNoneTerminal;\nvar OrCollector = /** @class */function (_super) {\n  __extends(OrCollector, _super);\n  function OrCollector() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.alternations = [];\n    return _this;\n  }\n  OrCollector.prototype.visitAlternation = function (node) {\n    this.alternations.push(node);\n  };\n  return OrCollector;\n}(gast_3.GAstVisitor);\nfunction validateEmptyOrAlternative(topLevelRule, errMsgProvider) {\n  var orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  var ors = orCollector.alternations;\n  var errors = (0, flatMap_1.default)(ors, function (currOr) {\n    var exceptLast = (0, dropRight_1.default)(currOr.definition);\n    return (0, flatMap_1.default)(exceptLast, function (currAlternative, currAltIdx) {\n      var possibleFirstInAlt = (0, interpreter_1.nextPossibleTokensAfter)([currAlternative], [], tokens_1.tokenStructuredMatcher, 1);\n      if ((0, isEmpty_1.default)(possibleFirstInAlt)) {\n        return [{\n          message: errMsgProvider.buildEmptyAlternationError({\n            topLevelRule: topLevelRule,\n            alternation: currOr,\n            emptyChoiceIdx: currAltIdx\n          }),\n          type: parser_1.ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\n          ruleName: topLevelRule.name,\n          occurrence: currOr.idx,\n          alternative: currAltIdx + 1\n        }];\n      } else {\n        return [];\n      }\n    });\n  });\n  return errors;\n}\nexports.validateEmptyOrAlternative = validateEmptyOrAlternative;\nfunction validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, errMsgProvider) {\n  var orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  var ors = orCollector.alternations;\n  // New Handling of ignoring ambiguities\n  // - https://github.com/chevrotain/chevrotain/issues/869\n  ors = (0, reject_1.default)(ors, function (currOr) {\n    return currOr.ignoreAmbiguities === true;\n  });\n  var errors = (0, flatMap_1.default)(ors, function (currOr) {\n    var currOccurrence = currOr.idx;\n    var actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;\n    var alternatives = (0, lookahead_1.getLookaheadPathsForOr)(currOccurrence, topLevelRule, actualMaxLookahead, currOr);\n    var altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n    var altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n    return altsAmbiguityErrors.concat(altsPrefixAmbiguityErrors);\n  });\n  return errors;\n}\nexports.validateAmbiguousAlternationAlternatives = validateAmbiguousAlternationAlternatives;\nvar RepetitionCollector = /** @class */function (_super) {\n  __extends(RepetitionCollector, _super);\n  function RepetitionCollector() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.allProductions = [];\n    return _this;\n  }\n  RepetitionCollector.prototype.visitRepetitionWithSeparator = function (manySep) {\n    this.allProductions.push(manySep);\n  };\n  RepetitionCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {\n    this.allProductions.push(atLeastOne);\n  };\n  RepetitionCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\n    this.allProductions.push(atLeastOneSep);\n  };\n  RepetitionCollector.prototype.visitRepetition = function (many) {\n    this.allProductions.push(many);\n  };\n  return RepetitionCollector;\n}(gast_3.GAstVisitor);\nexports.RepetitionCollector = RepetitionCollector;\nfunction validateTooManyAlts(topLevelRule, errMsgProvider) {\n  var orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  var ors = orCollector.alternations;\n  var errors = (0, flatMap_1.default)(ors, function (currOr) {\n    if (currOr.definition.length > 255) {\n      return [{\n        message: errMsgProvider.buildTooManyAlternativesError({\n          topLevelRule: topLevelRule,\n          alternation: currOr\n        }),\n        type: parser_1.ParserDefinitionErrorType.TOO_MANY_ALTS,\n        ruleName: topLevelRule.name,\n        occurrence: currOr.idx\n      }];\n    } else {\n      return [];\n    }\n  });\n  return errors;\n}\nexports.validateTooManyAlts = validateTooManyAlts;\nfunction validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {\n  var errors = [];\n  (0, forEach_1.default)(topLevelRules, function (currTopRule) {\n    var collectorVisitor = new RepetitionCollector();\n    currTopRule.accept(collectorVisitor);\n    var allRuleProductions = collectorVisitor.allProductions;\n    (0, forEach_1.default)(allRuleProductions, function (currProd) {\n      var prodType = (0, lookahead_1.getProdType)(currProd);\n      var actualMaxLookahead = currProd.maxLookahead || maxLookahead;\n      var currOccurrence = currProd.idx;\n      var paths = (0, lookahead_1.getLookaheadPathsForOptionalProd)(currOccurrence, currTopRule, prodType, actualMaxLookahead);\n      var pathsInsideProduction = paths[0];\n      if ((0, isEmpty_1.default)((0, flatten_1.default)(pathsInsideProduction))) {\n        var errMsg = errMsgProvider.buildEmptyRepetitionError({\n          topLevelRule: currTopRule,\n          repetition: currProd\n        });\n        errors.push({\n          message: errMsg,\n          type: parser_1.ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\n          ruleName: currTopRule.name\n        });\n      }\n    });\n  });\n  return errors;\n}\nexports.validateSomeNonEmptyLookaheadPath = validateSomeNonEmptyLookaheadPath;\nfunction checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n  var foundAmbiguousPaths = [];\n  var identicalAmbiguities = (0, reduce_1.default)(alternatives, function (result, currAlt, currAltIdx) {\n    // ignore (skip) ambiguities with this alternative\n    if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {\n      return result;\n    }\n    (0, forEach_1.default)(currAlt, function (currPath) {\n      var altsCurrPathAppearsIn = [currAltIdx];\n      (0, forEach_1.default)(alternatives, function (currOtherAlt, currOtherAltIdx) {\n        if (currAltIdx !== currOtherAltIdx && (0, lookahead_1.containsPath)(currOtherAlt, currPath) &&\n        // ignore (skip) ambiguities with this \"other\" alternative\n        alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true) {\n          altsCurrPathAppearsIn.push(currOtherAltIdx);\n        }\n      });\n      if (altsCurrPathAppearsIn.length > 1 && !(0, lookahead_1.containsPath)(foundAmbiguousPaths, currPath)) {\n        foundAmbiguousPaths.push(currPath);\n        result.push({\n          alts: altsCurrPathAppearsIn,\n          path: currPath\n        });\n      }\n    });\n    return result;\n  }, []);\n  var currErrors = (0, map_1.default)(identicalAmbiguities, function (currAmbDescriptor) {\n    var ambgIndices = (0, map_1.default)(currAmbDescriptor.alts, function (currAltIdx) {\n      return currAltIdx + 1;\n    });\n    var currMessage = errMsgProvider.buildAlternationAmbiguityError({\n      topLevelRule: rule,\n      alternation: alternation,\n      ambiguityIndices: ambgIndices,\n      prefixPath: currAmbDescriptor.path\n    });\n    return {\n      message: currMessage,\n      type: parser_1.ParserDefinitionErrorType.AMBIGUOUS_ALTS,\n      ruleName: rule.name,\n      occurrence: alternation.idx,\n      alternatives: currAmbDescriptor.alts\n    };\n  });\n  return currErrors;\n}\nfunction checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n  // flatten\n  var pathsAndIndices = (0, reduce_1.default)(alternatives, function (result, currAlt, idx) {\n    var currPathsAndIdx = (0, map_1.default)(currAlt, function (currPath) {\n      return {\n        idx: idx,\n        path: currPath\n      };\n    });\n    return result.concat(currPathsAndIdx);\n  }, []);\n  var errors = (0, compact_1.default)((0, flatMap_1.default)(pathsAndIndices, function (currPathAndIdx) {\n    var alternativeGast = alternation.definition[currPathAndIdx.idx];\n    // ignore (skip) ambiguities with this alternative\n    if (alternativeGast.ignoreAmbiguities === true) {\n      return [];\n    }\n    var targetIdx = currPathAndIdx.idx;\n    var targetPath = currPathAndIdx.path;\n    var prefixAmbiguitiesPathsAndIndices = (0, filter_1.default)(pathsAndIndices, function (searchPathAndIdx) {\n      // prefix ambiguity can only be created from lower idx (higher priority) path\n      return (\n        // ignore (skip) ambiguities with this \"other\" alternative\n        alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !== true && searchPathAndIdx.idx < targetIdx &&\n        // checking for strict prefix because identical lookaheads\n        // will be be detected using a different validation.\n        (0, lookahead_1.isStrictPrefixOfPath)(searchPathAndIdx.path, targetPath)\n      );\n    });\n    var currPathPrefixErrors = (0, map_1.default)(prefixAmbiguitiesPathsAndIndices, function (currAmbPathAndIdx) {\n      var ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];\n      var occurrence = alternation.idx === 0 ? \"\" : alternation.idx;\n      var message = errMsgProvider.buildAlternationPrefixAmbiguityError({\n        topLevelRule: rule,\n        alternation: alternation,\n        ambiguityIndices: ambgIndices,\n        prefixPath: currAmbPathAndIdx.path\n      });\n      return {\n        message: message,\n        type: parser_1.ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\n        ruleName: rule.name,\n        occurrence: occurrence,\n        alternatives: ambgIndices\n      };\n    });\n    return currPathPrefixErrors;\n  }));\n  return errors;\n}\nexports.checkPrefixAlternativesAmbiguities = checkPrefixAlternativesAmbiguities;\nfunction checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {\n  var errors = [];\n  var tokenNames = (0, map_1.default)(tokenTypes, function (currToken) {\n    return currToken.name;\n  });\n  (0, forEach_1.default)(topLevels, function (currRule) {\n    var currRuleName = currRule.name;\n    if ((0, includes_1.default)(tokenNames, currRuleName)) {\n      var errMsg = errMsgProvider.buildNamespaceConflictError(currRule);\n      errors.push({\n        message: errMsg,\n        type: parser_1.ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\n        ruleName: currRuleName\n      });\n    }\n  });\n  return errors;\n}","map":{"version":3,"names":["first_1","__importDefault","require","isEmpty_1","drop_1","flatten_1","filter_1","reject_1","difference_1","map_1","forEach_1","groupBy_1","reduce_1","pickBy_1","values_1","includes_1","flatMap_1","clone_1","parser_1","gast_1","lookahead_1","interpreter_1","gast_2","gast_3","dropRight_1","compact_1","tokens_1","validateLookahead","options","lookaheadValidationErrorMessages","lookaheadStrategy","validate","rules","tokenTypes","grammarName","default","errorMessage","__assign","type","ParserDefinitionErrorType","CUSTOM_LOOKAHEAD_VALIDATION","exports","validateGrammar","topLevels","errMsgProvider","duplicateErrors","currTopLevel","validateDuplicateProductions","termsNamespaceConflictErrors","checkTerminalAndNoneTerminalsNameSpace","tooManyAltsErrors","curRule","validateTooManyAlts","duplicateRulesError","validateRuleDoesNotAlreadyExist","concat","topLevelRule","collectorVisitor","OccurrenceValidationCollector","accept","allRuleProductions","allProductions","productionGroups","identifyProductionForDuplicates","duplicates","currGroup","length","errors","currDuplicates","firstProd","msg","buildDuplicateFoundError","dslName","getProductionDslName","defError","message","DUPLICATE_PRODUCTIONS","ruleName","name","occurrence","idx","param","getExtraProductionArgument","parameter","prod","Terminal","terminalType","NonTerminal","nonTerminalName","_super","__extends","_this","apply","arguments","prototype","visitNonTerminal","subrule","push","visitOption","option","visitRepetitionWithSeparator","manySep","visitRepetitionMandatory","atLeastOne","visitRepetitionMandatoryWithSeparator","atLeastOneSep","visitRepetition","many","visitAlternation","or","visitTerminal","terminal","GAstVisitor","rule","allRules","className","occurrences","result","errMsg","buildDuplicateRuleNameError","DUPLICATE_RULE_NAME","validateRuleIsOverridden","definedRulesNames","INVALID_RULE_OVERRIDE","validateNoLeftRecursion","topRule","currRule","path","nextNonTerminals","getFirstNoneTerminal","definition","foundLeftRecursion","buildLeftRecursionError","leftRecursionPath","LEFT_RECURSION","validNextSteps","errorsFromNextSteps","currRefRule","newPath","referencedRule","Alternative","Option","RepetitionMandatory","RepetitionMandatoryWithSeparator","RepetitionWithSeparator","Repetition","Alternation","currSubDef","Error","isFirstOptional","isOptionalProd","hasMore","rest","OrCollector","alternations","node","validateEmptyOrAlternative","orCollector","ors","currOr","exceptLast","currAlternative","currAltIdx","possibleFirstInAlt","nextPossibleTokensAfter","tokenStructuredMatcher","buildEmptyAlternationError","alternation","emptyChoiceIdx","NONE_LAST_EMPTY_ALT","alternative","validateAmbiguousAlternationAlternatives","globalMaxLookahead","ignoreAmbiguities","currOccurrence","actualMaxLookahead","maxLookahead","alternatives","getLookaheadPathsForOr","altsAmbiguityErrors","checkAlternativesAmbiguities","altsPrefixAmbiguityErrors","checkPrefixAlternativesAmbiguities","RepetitionCollector","buildTooManyAlternativesError","TOO_MANY_ALTS","validateSomeNonEmptyLookaheadPath","topLevelRules","currTopRule","currProd","prodType","getProdType","paths","getLookaheadPathsForOptionalProd","pathsInsideProduction","buildEmptyRepetitionError","repetition","NO_NON_EMPTY_LOOKAHEAD","foundAmbiguousPaths","identicalAmbiguities","currAlt","currPath","altsCurrPathAppearsIn","currOtherAlt","currOtherAltIdx","containsPath","alts","currErrors","currAmbDescriptor","ambgIndices","currMessage","buildAlternationAmbiguityError","ambiguityIndices","prefixPath","AMBIGUOUS_ALTS","pathsAndIndices","currPathsAndIdx","currPathAndIdx","alternativeGast","targetIdx","targetPath","prefixAmbiguitiesPathsAndIndices","searchPathAndIdx","isStrictPrefixOfPath","currPathPrefixErrors","currAmbPathAndIdx","buildAlternationPrefixAmbiguityError","AMBIGUOUS_PREFIX_ALTS","tokenNames","currToken","currRuleName","buildNamespaceConflictError","CONFLICT_TOKENS_RULES_NAMESPACE"],"sources":["/Users/rociopichardo/Desktop/PFhenryFront/node_modules/chevrotain/src/parse/grammar/checks.ts"],"sourcesContent":["import first from \"lodash/first\"\nimport isEmpty from \"lodash/isEmpty\"\nimport drop from \"lodash/drop\"\nimport flatten from \"lodash/flatten\"\nimport filter from \"lodash/filter\"\nimport reject from \"lodash/reject\"\nimport difference from \"lodash/difference\"\nimport map from \"lodash/map\"\nimport forEach from \"lodash/forEach\"\nimport groupBy from \"lodash/groupBy\"\nimport reduce from \"lodash/reduce\"\nimport pickBy from \"lodash/pickBy\"\nimport values from \"lodash/values\"\nimport includes from \"lodash/includes\"\nimport flatMap from \"lodash/flatMap\"\nimport clone from \"lodash/clone\"\nimport {\n  IParserAmbiguousAlternativesDefinitionError,\n  IParserDuplicatesDefinitionError,\n  IParserEmptyAlternativeDefinitionError,\n  ParserDefinitionErrorType\n} from \"../parser/parser\"\nimport { getProductionDslName, isOptionalProd } from \"@chevrotain/gast\"\nimport {\n  Alternative,\n  containsPath,\n  getLookaheadPathsForOptionalProd,\n  getLookaheadPathsForOr,\n  getProdType,\n  isStrictPrefixOfPath\n} from \"./lookahead\"\nimport { nextPossibleTokensAfter } from \"./interpreter\"\nimport {\n  Alternation,\n  Alternative as AlternativeGAST,\n  NonTerminal,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Terminal\n} from \"@chevrotain/gast\"\nimport { GAstVisitor } from \"@chevrotain/gast\"\nimport {\n  ILookaheadStrategy,\n  IProduction,\n  IProductionWithOccurrence,\n  TokenType,\n  Rule\n} from \"@chevrotain/types\"\nimport {\n  IGrammarValidatorErrorMessageProvider,\n  IParserDefinitionError\n} from \"./types\"\nimport dropRight from \"lodash/dropRight\"\nimport compact from \"lodash/compact\"\nimport { tokenStructuredMatcher } from \"../../scan/tokens\"\n\nexport function validateLookahead(options: {\n  lookaheadStrategy: ILookaheadStrategy\n  rules: Rule[]\n  tokenTypes: TokenType[]\n  grammarName: string\n}): IParserDefinitionError[] {\n  const lookaheadValidationErrorMessages = options.lookaheadStrategy.validate({\n    rules: options.rules,\n    tokenTypes: options.tokenTypes,\n    grammarName: options.grammarName\n  })\n  return map(lookaheadValidationErrorMessages, (errorMessage) => ({\n    type: ParserDefinitionErrorType.CUSTOM_LOOKAHEAD_VALIDATION,\n    ...errorMessage\n  }))\n}\n\nexport function validateGrammar(\n  topLevels: Rule[],\n  tokenTypes: TokenType[],\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\n  grammarName: string\n): IParserDefinitionError[] {\n  const duplicateErrors: IParserDefinitionError[] = flatMap(\n    topLevels,\n    (currTopLevel) => validateDuplicateProductions(currTopLevel, errMsgProvider)\n  )\n\n  const termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(\n    topLevels,\n    tokenTypes,\n    errMsgProvider\n  )\n\n  const tooManyAltsErrors = flatMap(topLevels, (curRule) =>\n    validateTooManyAlts(curRule, errMsgProvider)\n  )\n\n  const duplicateRulesError = flatMap(topLevels, (curRule) =>\n    validateRuleDoesNotAlreadyExist(\n      curRule,\n      topLevels,\n      grammarName,\n      errMsgProvider\n    )\n  )\n\n  return duplicateErrors.concat(\n    termsNamespaceConflictErrors,\n    tooManyAltsErrors,\n    duplicateRulesError\n  )\n}\n\nfunction validateDuplicateProductions(\n  topLevelRule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserDuplicatesDefinitionError[] {\n  const collectorVisitor = new OccurrenceValidationCollector()\n  topLevelRule.accept(collectorVisitor)\n  const allRuleProductions = collectorVisitor.allProductions\n\n  const productionGroups = groupBy(\n    allRuleProductions,\n    identifyProductionForDuplicates\n  )\n\n  const duplicates: any = pickBy(productionGroups, (currGroup) => {\n    return currGroup.length > 1\n  })\n\n  const errors = map(values(duplicates), (currDuplicates: any) => {\n    const firstProd: any = first(currDuplicates)\n    const msg = errMsgProvider.buildDuplicateFoundError(\n      topLevelRule,\n      currDuplicates\n    )\n    const dslName = getProductionDslName(firstProd)\n    const defError: IParserDuplicatesDefinitionError = {\n      message: msg,\n      type: ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\n      ruleName: topLevelRule.name,\n      dslName: dslName,\n      occurrence: firstProd.idx\n    }\n\n    const param = getExtraProductionArgument(firstProd)\n    if (param) {\n      defError.parameter = param\n    }\n\n    return defError\n  })\n  return errors\n}\n\nexport function identifyProductionForDuplicates(\n  prod: IProductionWithOccurrence\n): string {\n  return `${getProductionDslName(prod)}_#_${\n    prod.idx\n  }_#_${getExtraProductionArgument(prod)}`\n}\n\nfunction getExtraProductionArgument(prod: IProductionWithOccurrence): string {\n  if (prod instanceof Terminal) {\n    return prod.terminalType.name\n  } else if (prod instanceof NonTerminal) {\n    return prod.nonTerminalName\n  } else {\n    return \"\"\n  }\n}\n\nexport class OccurrenceValidationCollector extends GAstVisitor {\n  public allProductions: IProductionWithOccurrence[] = []\n\n  public visitNonTerminal(subrule: NonTerminal): void {\n    this.allProductions.push(subrule)\n  }\n\n  public visitOption(option: Option): void {\n    this.allProductions.push(option)\n  }\n\n  public visitRepetitionWithSeparator(manySep: RepetitionWithSeparator): void {\n    this.allProductions.push(manySep)\n  }\n\n  public visitRepetitionMandatory(atLeastOne: RepetitionMandatory): void {\n    this.allProductions.push(atLeastOne)\n  }\n\n  public visitRepetitionMandatoryWithSeparator(\n    atLeastOneSep: RepetitionMandatoryWithSeparator\n  ): void {\n    this.allProductions.push(atLeastOneSep)\n  }\n\n  public visitRepetition(many: Repetition): void {\n    this.allProductions.push(many)\n  }\n\n  public visitAlternation(or: Alternation): void {\n    this.allProductions.push(or)\n  }\n\n  public visitTerminal(terminal: Terminal): void {\n    this.allProductions.push(terminal)\n  }\n}\n\nexport function validateRuleDoesNotAlreadyExist(\n  rule: Rule,\n  allRules: Rule[],\n  className: string,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserDefinitionError[] {\n  const errors = []\n  const occurrences = reduce(\n    allRules,\n    (result, curRule) => {\n      if (curRule.name === rule.name) {\n        return result + 1\n      }\n      return result\n    },\n    0\n  )\n  if (occurrences > 1) {\n    const errMsg = errMsgProvider.buildDuplicateRuleNameError({\n      topLevelRule: rule,\n      grammarName: className\n    })\n    errors.push({\n      message: errMsg,\n      type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n      ruleName: rule.name\n    })\n  }\n\n  return errors\n}\n\n// TODO: is there anyway to get only the rule names of rules inherited from the super grammars?\n// This is not part of the IGrammarErrorProvider because the validation cannot be performed on\n// The grammar structure, only at runtime.\nexport function validateRuleIsOverridden(\n  ruleName: string,\n  definedRulesNames: string[],\n  className: string\n): IParserDefinitionError[] {\n  const errors = []\n  let errMsg\n\n  if (!includes(definedRulesNames, ruleName)) {\n    errMsg =\n      `Invalid rule override, rule: ->${ruleName}<- cannot be overridden in the grammar: ->${className}<-` +\n      `as it is not defined in any of the super grammars `\n    errors.push({\n      message: errMsg,\n      type: ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\n      ruleName: ruleName\n    })\n  }\n\n  return errors\n}\n\nexport function validateNoLeftRecursion(\n  topRule: Rule,\n  currRule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\n  path: Rule[] = []\n): IParserDefinitionError[] {\n  const errors: IParserDefinitionError[] = []\n  const nextNonTerminals = getFirstNoneTerminal(currRule.definition)\n  if (isEmpty(nextNonTerminals)) {\n    return []\n  } else {\n    const ruleName = topRule.name\n    const foundLeftRecursion = includes(nextNonTerminals, topRule)\n    if (foundLeftRecursion) {\n      errors.push({\n        message: errMsgProvider.buildLeftRecursionError({\n          topLevelRule: topRule,\n          leftRecursionPath: path\n        }),\n        type: ParserDefinitionErrorType.LEFT_RECURSION,\n        ruleName: ruleName\n      })\n    }\n\n    // we are only looking for cyclic paths leading back to the specific topRule\n    // other cyclic paths are ignored, we still need this difference to avoid infinite loops...\n    const validNextSteps = difference(nextNonTerminals, path.concat([topRule]))\n    const errorsFromNextSteps = flatMap(validNextSteps, (currRefRule) => {\n      const newPath = clone(path)\n      newPath.push(currRefRule)\n      return validateNoLeftRecursion(\n        topRule,\n        currRefRule,\n        errMsgProvider,\n        newPath\n      )\n    })\n\n    return errors.concat(errorsFromNextSteps)\n  }\n}\n\nexport function getFirstNoneTerminal(definition: IProduction[]): Rule[] {\n  let result: Rule[] = []\n  if (isEmpty(definition)) {\n    return result\n  }\n  const firstProd = first(definition)\n\n  /* istanbul ignore else */\n  if (firstProd instanceof NonTerminal) {\n    result.push(firstProd.referencedRule)\n  } else if (\n    firstProd instanceof AlternativeGAST ||\n    firstProd instanceof Option ||\n    firstProd instanceof RepetitionMandatory ||\n    firstProd instanceof RepetitionMandatoryWithSeparator ||\n    firstProd instanceof RepetitionWithSeparator ||\n    firstProd instanceof Repetition\n  ) {\n    result = result.concat(\n      getFirstNoneTerminal(<IProduction[]>firstProd.definition)\n    )\n  } else if (firstProd instanceof Alternation) {\n    // each sub definition in alternation is a FLAT\n    result = flatten(\n      map(firstProd.definition, (currSubDef) =>\n        getFirstNoneTerminal((<AlternativeGAST>currSubDef).definition)\n      )\n    )\n  } else if (firstProd instanceof Terminal) {\n    // nothing to see, move along\n  } else {\n    throw Error(\"non exhaustive match\")\n  }\n\n  const isFirstOptional = isOptionalProd(firstProd)\n  const hasMore = definition.length > 1\n  if (isFirstOptional && hasMore) {\n    const rest = drop(definition)\n    return result.concat(getFirstNoneTerminal(rest))\n  } else {\n    return result\n  }\n}\n\nclass OrCollector extends GAstVisitor {\n  public alternations: Alternation[] = []\n\n  public visitAlternation(node: Alternation): void {\n    this.alternations.push(node)\n  }\n}\n\nexport function validateEmptyOrAlternative(\n  topLevelRule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserEmptyAlternativeDefinitionError[] {\n  const orCollector = new OrCollector()\n  topLevelRule.accept(orCollector)\n  const ors = orCollector.alternations\n\n  const errors = flatMap<Alternation, IParserEmptyAlternativeDefinitionError>(\n    ors,\n    (currOr) => {\n      const exceptLast = dropRight(currOr.definition)\n      return flatMap(exceptLast, (currAlternative, currAltIdx) => {\n        const possibleFirstInAlt = nextPossibleTokensAfter(\n          [currAlternative],\n          [],\n          tokenStructuredMatcher,\n          1\n        )\n        if (isEmpty(possibleFirstInAlt)) {\n          return [\n            {\n              message: errMsgProvider.buildEmptyAlternationError({\n                topLevelRule: topLevelRule,\n                alternation: currOr,\n                emptyChoiceIdx: currAltIdx\n              }),\n              type: ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\n              ruleName: topLevelRule.name,\n              occurrence: currOr.idx,\n              alternative: currAltIdx + 1\n            }\n          ]\n        } else {\n          return []\n        }\n      })\n    }\n  )\n\n  return errors\n}\n\nexport function validateAmbiguousAlternationAlternatives(\n  topLevelRule: Rule,\n  globalMaxLookahead: number,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserAmbiguousAlternativesDefinitionError[] {\n  const orCollector = new OrCollector()\n  topLevelRule.accept(orCollector)\n  let ors = orCollector.alternations\n\n  // New Handling of ignoring ambiguities\n  // - https://github.com/chevrotain/chevrotain/issues/869\n  ors = reject(ors, (currOr) => currOr.ignoreAmbiguities === true)\n\n  const errors = flatMap(ors, (currOr: Alternation) => {\n    const currOccurrence = currOr.idx\n    const actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead\n    const alternatives = getLookaheadPathsForOr(\n      currOccurrence,\n      topLevelRule,\n      actualMaxLookahead,\n      currOr\n    )\n    const altsAmbiguityErrors = checkAlternativesAmbiguities(\n      alternatives,\n      currOr,\n      topLevelRule,\n      errMsgProvider\n    )\n    const altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(\n      alternatives,\n      currOr,\n      topLevelRule,\n      errMsgProvider\n    )\n\n    return altsAmbiguityErrors.concat(altsPrefixAmbiguityErrors)\n  })\n\n  return errors\n}\n\nexport class RepetitionCollector extends GAstVisitor {\n  public allProductions: (IProductionWithOccurrence & {\n    maxLookahead?: number\n  })[] = []\n\n  public visitRepetitionWithSeparator(manySep: RepetitionWithSeparator): void {\n    this.allProductions.push(manySep)\n  }\n\n  public visitRepetitionMandatory(atLeastOne: RepetitionMandatory): void {\n    this.allProductions.push(atLeastOne)\n  }\n\n  public visitRepetitionMandatoryWithSeparator(\n    atLeastOneSep: RepetitionMandatoryWithSeparator\n  ): void {\n    this.allProductions.push(atLeastOneSep)\n  }\n\n  public visitRepetition(many: Repetition): void {\n    this.allProductions.push(many)\n  }\n}\n\nexport function validateTooManyAlts(\n  topLevelRule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserDefinitionError[] {\n  const orCollector = new OrCollector()\n  topLevelRule.accept(orCollector)\n  const ors = orCollector.alternations\n\n  const errors = flatMap(ors, (currOr) => {\n    if (currOr.definition.length > 255) {\n      return [\n        {\n          message: errMsgProvider.buildTooManyAlternativesError({\n            topLevelRule: topLevelRule,\n            alternation: currOr\n          }),\n          type: ParserDefinitionErrorType.TOO_MANY_ALTS,\n          ruleName: topLevelRule.name,\n          occurrence: currOr.idx\n        }\n      ]\n    } else {\n      return []\n    }\n  })\n\n  return errors\n}\n\nexport function validateSomeNonEmptyLookaheadPath(\n  topLevelRules: Rule[],\n  maxLookahead: number,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserDefinitionError[] {\n  const errors: IParserDefinitionError[] = []\n  forEach(topLevelRules, (currTopRule) => {\n    const collectorVisitor = new RepetitionCollector()\n    currTopRule.accept(collectorVisitor)\n    const allRuleProductions = collectorVisitor.allProductions\n    forEach(allRuleProductions, (currProd) => {\n      const prodType = getProdType(currProd)\n      const actualMaxLookahead = currProd.maxLookahead || maxLookahead\n      const currOccurrence = currProd.idx\n      const paths = getLookaheadPathsForOptionalProd(\n        currOccurrence,\n        currTopRule,\n        prodType,\n        actualMaxLookahead\n      )\n      const pathsInsideProduction = paths[0]\n      if (isEmpty(flatten(pathsInsideProduction))) {\n        const errMsg = errMsgProvider.buildEmptyRepetitionError({\n          topLevelRule: currTopRule,\n          repetition: currProd\n        })\n        errors.push({\n          message: errMsg,\n          type: ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\n          ruleName: currTopRule.name\n        })\n      }\n    })\n  })\n\n  return errors\n}\n\nexport interface IAmbiguityDescriptor {\n  alts: number[]\n  path: TokenType[]\n}\n\nfunction checkAlternativesAmbiguities(\n  alternatives: Alternative[],\n  alternation: Alternation,\n  rule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserAmbiguousAlternativesDefinitionError[] {\n  const foundAmbiguousPaths: Alternative = []\n  const identicalAmbiguities = reduce(\n    alternatives,\n    (result, currAlt, currAltIdx) => {\n      // ignore (skip) ambiguities with this alternative\n      if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {\n        return result\n      }\n\n      forEach(currAlt, (currPath) => {\n        const altsCurrPathAppearsIn = [currAltIdx]\n        forEach(alternatives, (currOtherAlt, currOtherAltIdx) => {\n          if (\n            currAltIdx !== currOtherAltIdx &&\n            containsPath(currOtherAlt, currPath) &&\n            // ignore (skip) ambiguities with this \"other\" alternative\n            alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true\n          ) {\n            altsCurrPathAppearsIn.push(currOtherAltIdx)\n          }\n        })\n\n        if (\n          altsCurrPathAppearsIn.length > 1 &&\n          !containsPath(foundAmbiguousPaths, currPath)\n        ) {\n          foundAmbiguousPaths.push(currPath)\n          result.push({\n            alts: altsCurrPathAppearsIn,\n            path: currPath\n          })\n        }\n      })\n      return result\n    },\n    [] as { alts: number[]; path: TokenType[] }[]\n  )\n\n  const currErrors = map(identicalAmbiguities, (currAmbDescriptor) => {\n    const ambgIndices = map(\n      currAmbDescriptor.alts,\n      (currAltIdx) => currAltIdx + 1\n    )\n\n    const currMessage = errMsgProvider.buildAlternationAmbiguityError({\n      topLevelRule: rule,\n      alternation: alternation,\n      ambiguityIndices: ambgIndices,\n      prefixPath: currAmbDescriptor.path\n    })\n\n    return {\n      message: currMessage,\n      type: ParserDefinitionErrorType.AMBIGUOUS_ALTS,\n      ruleName: rule.name,\n      occurrence: alternation.idx,\n      alternatives: currAmbDescriptor.alts\n    }\n  })\n\n  return currErrors\n}\n\nexport function checkPrefixAlternativesAmbiguities(\n  alternatives: Alternative[],\n  alternation: Alternation,\n  rule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserAmbiguousAlternativesDefinitionError[] {\n  // flatten\n  const pathsAndIndices = reduce(\n    alternatives,\n    (result, currAlt, idx) => {\n      const currPathsAndIdx = map(currAlt, (currPath) => {\n        return { idx: idx, path: currPath }\n      })\n      return result.concat(currPathsAndIdx)\n    },\n    [] as { idx: number; path: TokenType[] }[]\n  )\n\n  const errors = compact(\n    flatMap(pathsAndIndices, (currPathAndIdx) => {\n      const alternativeGast = alternation.definition[currPathAndIdx.idx]\n      // ignore (skip) ambiguities with this alternative\n      if (alternativeGast.ignoreAmbiguities === true) {\n        return []\n      }\n      const targetIdx = currPathAndIdx.idx\n      const targetPath = currPathAndIdx.path\n\n      const prefixAmbiguitiesPathsAndIndices = filter(\n        pathsAndIndices,\n        (searchPathAndIdx) => {\n          // prefix ambiguity can only be created from lower idx (higher priority) path\n          return (\n            // ignore (skip) ambiguities with this \"other\" alternative\n            alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !==\n              true &&\n            searchPathAndIdx.idx < targetIdx &&\n            // checking for strict prefix because identical lookaheads\n            // will be be detected using a different validation.\n            isStrictPrefixOfPath(searchPathAndIdx.path, targetPath)\n          )\n        }\n      )\n\n      const currPathPrefixErrors = map(\n        prefixAmbiguitiesPathsAndIndices,\n        (currAmbPathAndIdx): IParserAmbiguousAlternativesDefinitionError => {\n          const ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1]\n          const occurrence = alternation.idx === 0 ? \"\" : alternation.idx\n\n          const message = errMsgProvider.buildAlternationPrefixAmbiguityError({\n            topLevelRule: rule,\n            alternation: alternation,\n            ambiguityIndices: ambgIndices,\n            prefixPath: currAmbPathAndIdx.path\n          })\n          return {\n            message: message,\n            type: ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\n            ruleName: rule.name,\n            occurrence: occurrence,\n            alternatives: ambgIndices\n          }\n        }\n      )\n\n      return currPathPrefixErrors\n    })\n  )\n\n  return errors\n}\n\nfunction checkTerminalAndNoneTerminalsNameSpace(\n  topLevels: Rule[],\n  tokenTypes: TokenType[],\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserDefinitionError[] {\n  const errors: IParserDefinitionError[] = []\n\n  const tokenNames = map(tokenTypes, (currToken) => currToken.name)\n\n  forEach(topLevels, (currRule) => {\n    const currRuleName = currRule.name\n    if (includes(tokenNames, currRuleName)) {\n      const errMsg = errMsgProvider.buildNamespaceConflictError(currRule)\n\n      errors.push({\n        message: errMsg,\n        type: ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\n        ruleName: currRuleName\n      })\n    }\n  })\n\n  return errors\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAAA,OAAA,GAAAC,eAAA,CAAAC,OAAA;AACA,IAAAC,SAAA,GAAAF,eAAA,CAAAC,OAAA;AACA,IAAAE,MAAA,GAAAH,eAAA,CAAAC,OAAA;AACA,IAAAG,SAAA,GAAAJ,eAAA,CAAAC,OAAA;AACA,IAAAI,QAAA,GAAAL,eAAA,CAAAC,OAAA;AACA,IAAAK,QAAA,GAAAN,eAAA,CAAAC,OAAA;AACA,IAAAM,YAAA,GAAAP,eAAA,CAAAC,OAAA;AACA,IAAAO,KAAA,GAAAR,eAAA,CAAAC,OAAA;AACA,IAAAQ,SAAA,GAAAT,eAAA,CAAAC,OAAA;AACA,IAAAS,SAAA,GAAAV,eAAA,CAAAC,OAAA;AACA,IAAAU,QAAA,GAAAX,eAAA,CAAAC,OAAA;AACA,IAAAW,QAAA,GAAAZ,eAAA,CAAAC,OAAA;AACA,IAAAY,QAAA,GAAAb,eAAA,CAAAC,OAAA;AACA,IAAAa,UAAA,GAAAd,eAAA,CAAAC,OAAA;AACA,IAAAc,SAAA,GAAAf,eAAA,CAAAC,OAAA;AACA,IAAAe,OAAA,GAAAhB,eAAA,CAAAC,OAAA;AACA,IAAAgB,QAAA,GAAAhB,OAAA;AAMA,IAAAiB,MAAA,GAAAjB,OAAA;AACA,IAAAkB,WAAA,GAAAlB,OAAA;AAQA,IAAAmB,aAAA,GAAAnB,OAAA;AACA,IAAAoB,MAAA,GAAApB,OAAA;AAWA,IAAAqB,MAAA,GAAArB,OAAA;AAYA,IAAAsB,WAAA,GAAAvB,eAAA,CAAAC,OAAA;AACA,IAAAuB,SAAA,GAAAxB,eAAA,CAAAC,OAAA;AACA,IAAAwB,QAAA,GAAAxB,OAAA;AAEA,SAAgByB,iBAAiBA,CAACC,OAKjC;EACC,IAAMC,gCAAgC,GAAGD,OAAO,CAACE,iBAAiB,CAACC,QAAQ,CAAC;IAC1EC,KAAK,EAAEJ,OAAO,CAACI,KAAK;IACpBC,UAAU,EAAEL,OAAO,CAACK,UAAU;IAC9BC,WAAW,EAAEN,OAAO,CAACM;GACtB,CAAC;EACF,OAAO,IAAAzB,KAAA,CAAA0B,OAAG,EAACN,gCAAgC,EAAE,UAACO,YAAY;IAAK,OAAAC,QAAA;MAC7DC,IAAI,EAAEpB,QAAA,CAAAqB,yBAAyB,CAACC;IAA2B,GACxDJ,YAAY;EAF8C,CAG7D,CAAC;AACL;AAfAK,OAAA,CAAAd,iBAAA,GAAAA,iBAAA;AAiBA,SAAgBe,eAAeA,CAC7BC,SAAiB,EACjBV,UAAuB,EACvBW,cAAqD,EACrDV,WAAmB;EAEnB,IAAMW,eAAe,GAA6B,IAAA7B,SAAA,CAAAmB,OAAO,EACvDQ,SAAS,EACT,UAACG,YAAY;IAAK,OAAAC,4BAA4B,CAACD,YAAY,EAAEF,cAAc,CAAC;EAA1D,CAA0D,CAC7E;EAED,IAAMI,4BAA4B,GAAGC,sCAAsC,CACzEN,SAAS,EACTV,UAAU,EACVW,cAAc,CACf;EAED,IAAMM,iBAAiB,GAAG,IAAAlC,SAAA,CAAAmB,OAAO,EAACQ,SAAS,EAAE,UAACQ,OAAO;IACnD,OAAAC,mBAAmB,CAACD,OAAO,EAAEP,cAAc,CAAC;EAA5C,CAA4C,CAC7C;EAED,IAAMS,mBAAmB,GAAG,IAAArC,SAAA,CAAAmB,OAAO,EAACQ,SAAS,EAAE,UAACQ,OAAO;IACrD,OAAAG,+BAA+B,CAC7BH,OAAO,EACPR,SAAS,EACTT,WAAW,EACXU,cAAc,CACf;EALD,CAKC,CACF;EAED,OAAOC,eAAe,CAACU,MAAM,CAC3BP,4BAA4B,EAC5BE,iBAAiB,EACjBG,mBAAmB,CACpB;AACH;AAnCAZ,OAAA,CAAAC,eAAA,GAAAA,eAAA;AAqCA,SAASK,4BAA4BA,CACnCS,YAAkB,EAClBZ,cAAqD;EAErD,IAAMa,gBAAgB,GAAG,IAAIC,6BAA6B,EAAE;EAC5DF,YAAY,CAACG,MAAM,CAACF,gBAAgB,CAAC;EACrC,IAAMG,kBAAkB,GAAGH,gBAAgB,CAACI,cAAc;EAE1D,IAAMC,gBAAgB,GAAG,IAAAnD,SAAA,CAAAwB,OAAO,EAC9ByB,kBAAkB,EAClBG,+BAA+B,CAChC;EAED,IAAMC,UAAU,GAAQ,IAAAnD,QAAA,CAAAsB,OAAM,EAAC2B,gBAAgB,EAAE,UAACG,SAAS;IACzD,OAAOA,SAAS,CAACC,MAAM,GAAG,CAAC;EAC7B,CAAC,CAAC;EAEF,IAAMC,MAAM,GAAG,IAAA1D,KAAA,CAAA0B,OAAG,EAAC,IAAArB,QAAA,CAAAqB,OAAM,EAAC6B,UAAU,CAAC,EAAE,UAACI,cAAmB;IACzD,IAAMC,SAAS,GAAQ,IAAArE,OAAA,CAAAmC,OAAK,EAACiC,cAAc,CAAC;IAC5C,IAAME,GAAG,GAAG1B,cAAc,CAAC2B,wBAAwB,CACjDf,YAAY,EACZY,cAAc,CACf;IACD,IAAMI,OAAO,GAAG,IAAArD,MAAA,CAAAsD,oBAAoB,EAACJ,SAAS,CAAC;IAC/C,IAAMK,QAAQ,GAAqC;MACjDC,OAAO,EAAEL,GAAG;MACZhC,IAAI,EAAEpB,QAAA,CAAAqB,yBAAyB,CAACqC,qBAAqB;MACrDC,QAAQ,EAAErB,YAAY,CAACsB,IAAI;MAC3BN,OAAO,EAAEA,OAAO;MAChBO,UAAU,EAAEV,SAAS,CAACW;KACvB;IAED,IAAMC,KAAK,GAAGC,0BAA0B,CAACb,SAAS,CAAC;IACnD,IAAIY,KAAK,EAAE;MACTP,QAAQ,CAACS,SAAS,GAAGF,KAAK;;IAG5B,OAAOP,QAAQ;EACjB,CAAC,CAAC;EACF,OAAOP,MAAM;AACf;AAEA,SAAgBJ,+BAA+BA,CAC7CqB,IAA+B;EAE/B,OAAO,GAAA7B,MAAA,CAAG,IAAApC,MAAA,CAAAsD,oBAAoB,EAACW,IAAI,CAAC,SAAA7B,MAAA,CAClC6B,IAAI,CAACJ,GAAG,SAAAzB,MAAA,CACJ2B,0BAA0B,CAACE,IAAI,CAAC,CAAE;AAC1C;AANA3C,OAAA,CAAAsB,+BAAA,GAAAA,+BAAA;AAQA,SAASmB,0BAA0BA,CAACE,IAA+B;EACjE,IAAIA,IAAI,YAAY9D,MAAA,CAAA+D,QAAQ,EAAE;IAC5B,OAAOD,IAAI,CAACE,YAAY,CAACR,IAAI;GAC9B,MAAM,IAAIM,IAAI,YAAY9D,MAAA,CAAAiE,WAAW,EAAE;IACtC,OAAOH,IAAI,CAACI,eAAe;GAC5B,MAAM;IACL,OAAO,EAAE;;AAEb;AAEA,IAAA9B,6BAAA,0BAAA+B,MAAA;EAAmDC,SAAA,CAAAhC,6BAAA,EAAA+B,MAAA;EAAnD,SAAA/B,8BAAA;IAAA,IAAAiC,KAAA,GAAAF,MAAA,aAAAA,MAAA,CAAAG,KAAA,OAAAC,SAAA;IACSF,KAAA,CAAA9B,cAAc,GAAgC,EAAE;;EAmCzD;EAjCSH,6BAAA,CAAAoC,SAAA,CAAAC,gBAAgB,GAAvB,UAAwBC,OAAoB;IAC1C,IAAI,CAACnC,cAAc,CAACoC,IAAI,CAACD,OAAO,CAAC;EACnC,CAAC;EAEMtC,6BAAA,CAAAoC,SAAA,CAAAI,WAAW,GAAlB,UAAmBC,MAAc;IAC/B,IAAI,CAACtC,cAAc,CAACoC,IAAI,CAACE,MAAM,CAAC;EAClC,CAAC;EAEMzC,6BAAA,CAAAoC,SAAA,CAAAM,4BAA4B,GAAnC,UAAoCC,OAAgC;IAClE,IAAI,CAACxC,cAAc,CAACoC,IAAI,CAACI,OAAO,CAAC;EACnC,CAAC;EAEM3C,6BAAA,CAAAoC,SAAA,CAAAQ,wBAAwB,GAA/B,UAAgCC,UAA+B;IAC7D,IAAI,CAAC1C,cAAc,CAACoC,IAAI,CAACM,UAAU,CAAC;EACtC,CAAC;EAEM7C,6BAAA,CAAAoC,SAAA,CAAAU,qCAAqC,GAA5C,UACEC,aAA+C;IAE/C,IAAI,CAAC5C,cAAc,CAACoC,IAAI,CAACQ,aAAa,CAAC;EACzC,CAAC;EAEM/C,6BAAA,CAAAoC,SAAA,CAAAY,eAAe,GAAtB,UAAuBC,IAAgB;IACrC,IAAI,CAAC9C,cAAc,CAACoC,IAAI,CAACU,IAAI,CAAC;EAChC,CAAC;EAEMjD,6BAAA,CAAAoC,SAAA,CAAAc,gBAAgB,GAAvB,UAAwBC,EAAe;IACrC,IAAI,CAAChD,cAAc,CAACoC,IAAI,CAACY,EAAE,CAAC;EAC9B,CAAC;EAEMnD,6BAAA,CAAAoC,SAAA,CAAAgB,aAAa,GAApB,UAAqBC,QAAkB;IACrC,IAAI,CAAClD,cAAc,CAACoC,IAAI,CAACc,QAAQ,CAAC;EACpC,CAAC;EACH,OAAArD,6BAAC;AAAD,CAAC,CApCkDnC,MAAA,CAAAyF,WAAW;AAAjDvE,OAAA,CAAAiB,6BAAA,GAAAA,6BAAA;AAsCb,SAAgBJ,+BAA+BA,CAC7C2D,IAAU,EACVC,QAAgB,EAChBC,SAAiB,EACjBvE,cAAqD;EAErD,IAAMuB,MAAM,GAAG,EAAE;EACjB,IAAMiD,WAAW,GAAG,IAAAxG,QAAA,CAAAuB,OAAM,EACxB+E,QAAQ,EACR,UAACG,MAAM,EAAElE,OAAO;IACd,IAAIA,OAAO,CAAC2B,IAAI,KAAKmC,IAAI,CAACnC,IAAI,EAAE;MAC9B,OAAOuC,MAAM,GAAG,CAAC;;IAEnB,OAAOA,MAAM;EACf,CAAC,EACD,CAAC,CACF;EACD,IAAID,WAAW,GAAG,CAAC,EAAE;IACnB,IAAME,MAAM,GAAG1E,cAAc,CAAC2E,2BAA2B,CAAC;MACxD/D,YAAY,EAAEyD,IAAI;MAClB/E,WAAW,EAAEiF;KACd,CAAC;IACFhD,MAAM,CAAC8B,IAAI,CAAC;MACVtB,OAAO,EAAE2C,MAAM;MACfhF,IAAI,EAAEpB,QAAA,CAAAqB,yBAAyB,CAACiF,mBAAmB;MACnD3C,QAAQ,EAAEoC,IAAI,CAACnC;KAChB,CAAC;;EAGJ,OAAOX,MAAM;AACf;AA9BA1B,OAAA,CAAAa,+BAAA,GAAAA,+BAAA;AAgCA;AACA;AACA;AACA,SAAgBmE,wBAAwBA,CACtC5C,QAAgB,EAChB6C,iBAA2B,EAC3BP,SAAiB;EAEjB,IAAMhD,MAAM,GAAG,EAAE;EACjB,IAAImD,MAAM;EAEV,IAAI,CAAC,IAAAvG,UAAA,CAAAoB,OAAQ,EAACuF,iBAAiB,EAAE7C,QAAQ,CAAC,EAAE;IAC1CyC,MAAM,GACJ,kCAAA/D,MAAA,CAAkCsB,QAAQ,gDAAAtB,MAAA,CAA6C4D,SAAS,OAAI,GACpG,oDAAoD;IACtDhD,MAAM,CAAC8B,IAAI,CAAC;MACVtB,OAAO,EAAE2C,MAAM;MACfhF,IAAI,EAAEpB,QAAA,CAAAqB,yBAAyB,CAACoF,qBAAqB;MACrD9C,QAAQ,EAAEA;KACX,CAAC;;EAGJ,OAAOV,MAAM;AACf;AApBA1B,OAAA,CAAAgF,wBAAA,GAAAA,wBAAA;AAsBA,SAAgBG,uBAAuBA,CACrCC,OAAa,EACbC,QAAc,EACdlF,cAAqD,EACrDmF,IAAiB;EAAjB,IAAAA,IAAA;IAAAA,IAAA,KAAiB;EAAA;EAEjB,IAAM5D,MAAM,GAA6B,EAAE;EAC3C,IAAM6D,gBAAgB,GAAGC,oBAAoB,CAACH,QAAQ,CAACI,UAAU,CAAC;EAClE,IAAI,IAAA/H,SAAA,CAAAgC,OAAO,EAAC6F,gBAAgB,CAAC,EAAE;IAC7B,OAAO,EAAE;GACV,MAAM;IACL,IAAMnD,QAAQ,GAAGgD,OAAO,CAAC/C,IAAI;IAC7B,IAAMqD,kBAAkB,GAAG,IAAApH,UAAA,CAAAoB,OAAQ,EAAC6F,gBAAgB,EAAEH,OAAO,CAAC;IAC9D,IAAIM,kBAAkB,EAAE;MACtBhE,MAAM,CAAC8B,IAAI,CAAC;QACVtB,OAAO,EAAE/B,cAAc,CAACwF,uBAAuB,CAAC;UAC9C5E,YAAY,EAAEqE,OAAO;UACrBQ,iBAAiB,EAAEN;SACpB,CAAC;QACFzF,IAAI,EAAEpB,QAAA,CAAAqB,yBAAyB,CAAC+F,cAAc;QAC9CzD,QAAQ,EAAEA;OACX,CAAC;;IAGJ;IACA;IACA,IAAM0D,cAAc,GAAG,IAAA/H,YAAA,CAAA2B,OAAU,EAAC6F,gBAAgB,EAAED,IAAI,CAACxE,MAAM,CAAC,CAACsE,OAAO,CAAC,CAAC,CAAC;IAC3E,IAAMW,mBAAmB,GAAG,IAAAxH,SAAA,CAAAmB,OAAO,EAACoG,cAAc,EAAE,UAACE,WAAW;MAC9D,IAAMC,OAAO,GAAG,IAAAzH,OAAA,CAAAkB,OAAK,EAAC4F,IAAI,CAAC;MAC3BW,OAAO,CAACzC,IAAI,CAACwC,WAAW,CAAC;MACzB,OAAOb,uBAAuB,CAC5BC,OAAO,EACPY,WAAW,EACX7F,cAAc,EACd8F,OAAO,CACR;IACH,CAAC,CAAC;IAEF,OAAOvE,MAAM,CAACZ,MAAM,CAACiF,mBAAmB,CAAC;;AAE7C;AAxCA/F,OAAA,CAAAmF,uBAAA,GAAAA,uBAAA;AA0CA,SAAgBK,oBAAoBA,CAACC,UAAyB;EAC5D,IAAIb,MAAM,GAAW,EAAE;EACvB,IAAI,IAAAlH,SAAA,CAAAgC,OAAO,EAAC+F,UAAU,CAAC,EAAE;IACvB,OAAOb,MAAM;;EAEf,IAAMhD,SAAS,GAAG,IAAArE,OAAA,CAAAmC,OAAK,EAAC+F,UAAU,CAAC;EAEnC;EACA,IAAI7D,SAAS,YAAY/C,MAAA,CAAAiE,WAAW,EAAE;IACpC8B,MAAM,CAACpB,IAAI,CAAC5B,SAAS,CAACsE,cAAc,CAAC;GACtC,MAAM,IACLtE,SAAS,YAAY/C,MAAA,CAAAsH,WAAe,IACpCvE,SAAS,YAAY/C,MAAA,CAAAuH,MAAM,IAC3BxE,SAAS,YAAY/C,MAAA,CAAAwH,mBAAmB,IACxCzE,SAAS,YAAY/C,MAAA,CAAAyH,gCAAgC,IACrD1E,SAAS,YAAY/C,MAAA,CAAA0H,uBAAuB,IAC5C3E,SAAS,YAAY/C,MAAA,CAAA2H,UAAU,EAC/B;IACA5B,MAAM,GAAGA,MAAM,CAAC9D,MAAM,CACpB0E,oBAAoB,CAAgB5D,SAAS,CAAC6D,UAAU,CAAC,CAC1D;GACF,MAAM,IAAI7D,SAAS,YAAY/C,MAAA,CAAA4H,WAAW,EAAE;IAC3C;IACA7B,MAAM,GAAG,IAAAhH,SAAA,CAAA8B,OAAO,EACd,IAAA1B,KAAA,CAAA0B,OAAG,EAACkC,SAAS,CAAC6D,UAAU,EAAE,UAACiB,UAAU;MACnC,OAAAlB,oBAAoB,CAAmBkB,UAAW,CAACjB,UAAU,CAAC;IAA9D,CAA8D,CAC/D,CACF;GACF,MAAM,IAAI7D,SAAS,YAAY/C,MAAA,CAAA+D,QAAQ,EAAE;IACxC;EAAA,CACD,MAAM;IACL,MAAM+D,KAAK,CAAC,sBAAsB,CAAC;;EAGrC,IAAMC,eAAe,GAAG,IAAAlI,MAAA,CAAAmI,cAAc,EAACjF,SAAS,CAAC;EACjD,IAAMkF,OAAO,GAAGrB,UAAU,CAAChE,MAAM,GAAG,CAAC;EACrC,IAAImF,eAAe,IAAIE,OAAO,EAAE;IAC9B,IAAMC,IAAI,GAAG,IAAApJ,MAAA,CAAA+B,OAAI,EAAC+F,UAAU,CAAC;IAC7B,OAAOb,MAAM,CAAC9D,MAAM,CAAC0E,oBAAoB,CAACuB,IAAI,CAAC,CAAC;GACjD,MAAM;IACL,OAAOnC,MAAM;;AAEjB;AA1CA5E,OAAA,CAAAwF,oBAAA,GAAAA,oBAAA;AA4CA,IAAAwB,WAAA,0BAAAhE,MAAA;EAA0BC,SAAA,CAAA+D,WAAA,EAAAhE,MAAA;EAA1B,SAAAgE,YAAA;IAAA,IAAA9D,KAAA,GAAAF,MAAA,aAAAA,MAAA,CAAAG,KAAA,OAAAC,SAAA;IACSF,KAAA,CAAA+D,YAAY,GAAkB,EAAE;;EAKzC;EAHSD,WAAA,CAAA3D,SAAA,CAAAc,gBAAgB,GAAvB,UAAwB+C,IAAiB;IACvC,IAAI,CAACD,YAAY,CAACzD,IAAI,CAAC0D,IAAI,CAAC;EAC9B,CAAC;EACH,OAAAF,WAAC;AAAD,CAAC,CANyBlI,MAAA,CAAAyF,WAAW;AAQrC,SAAgB4C,0BAA0BA,CACxCpG,YAAkB,EAClBZ,cAAqD;EAErD,IAAMiH,WAAW,GAAG,IAAIJ,WAAW,EAAE;EACrCjG,YAAY,CAACG,MAAM,CAACkG,WAAW,CAAC;EAChC,IAAMC,GAAG,GAAGD,WAAW,CAACH,YAAY;EAEpC,IAAMvF,MAAM,GAAG,IAAAnD,SAAA,CAAAmB,OAAO,EACpB2H,GAAG,EACH,UAACC,MAAM;IACL,IAAMC,UAAU,GAAG,IAAAxI,WAAA,CAAAW,OAAS,EAAC4H,MAAM,CAAC7B,UAAU,CAAC;IAC/C,OAAO,IAAAlH,SAAA,CAAAmB,OAAO,EAAC6H,UAAU,EAAE,UAACC,eAAe,EAAEC,UAAU;MACrD,IAAMC,kBAAkB,GAAG,IAAA9I,aAAA,CAAA+I,uBAAuB,EAChD,CAACH,eAAe,CAAC,EACjB,EAAE,EACFvI,QAAA,CAAA2I,sBAAsB,EACtB,CAAC,CACF;MACD,IAAI,IAAAlK,SAAA,CAAAgC,OAAO,EAACgI,kBAAkB,CAAC,EAAE;QAC/B,OAAO,CACL;UACExF,OAAO,EAAE/B,cAAc,CAAC0H,0BAA0B,CAAC;YACjD9G,YAAY,EAAEA,YAAY;YAC1B+G,WAAW,EAAER,MAAM;YACnBS,cAAc,EAAEN;WACjB,CAAC;UACF5H,IAAI,EAAEpB,QAAA,CAAAqB,yBAAyB,CAACkI,mBAAmB;UACnD5F,QAAQ,EAAErB,YAAY,CAACsB,IAAI;UAC3BC,UAAU,EAAEgF,MAAM,CAAC/E,GAAG;UACtB0F,WAAW,EAAER,UAAU,GAAG;SAC3B,CACF;OACF,MAAM;QACL,OAAO,EAAE;;IAEb,CAAC,CAAC;EACJ,CAAC,CACF;EAED,OAAO/F,MAAM;AACf;AAzCA1B,OAAA,CAAAmH,0BAAA,GAAAA,0BAAA;AA2CA,SAAgBe,wCAAwCA,CACtDnH,YAAkB,EAClBoH,kBAA0B,EAC1BhI,cAAqD;EAErD,IAAMiH,WAAW,GAAG,IAAIJ,WAAW,EAAE;EACrCjG,YAAY,CAACG,MAAM,CAACkG,WAAW,CAAC;EAChC,IAAIC,GAAG,GAAGD,WAAW,CAACH,YAAY;EAElC;EACA;EACAI,GAAG,GAAG,IAAAvJ,QAAA,CAAA4B,OAAM,EAAC2H,GAAG,EAAE,UAACC,MAAM;IAAK,OAAAA,MAAM,CAACc,iBAAiB,KAAK,IAAI;EAAjC,CAAiC,CAAC;EAEhE,IAAM1G,MAAM,GAAG,IAAAnD,SAAA,CAAAmB,OAAO,EAAC2H,GAAG,EAAE,UAACC,MAAmB;IAC9C,IAAMe,cAAc,GAAGf,MAAM,CAAC/E,GAAG;IACjC,IAAM+F,kBAAkB,GAAGhB,MAAM,CAACiB,YAAY,IAAIJ,kBAAkB;IACpE,IAAMK,YAAY,GAAG,IAAA7J,WAAA,CAAA8J,sBAAsB,EACzCJ,cAAc,EACdtH,YAAY,EACZuH,kBAAkB,EAClBhB,MAAM,CACP;IACD,IAAMoB,mBAAmB,GAAGC,4BAA4B,CACtDH,YAAY,EACZlB,MAAM,EACNvG,YAAY,EACZZ,cAAc,CACf;IACD,IAAMyI,yBAAyB,GAAGC,kCAAkC,CAClEL,YAAY,EACZlB,MAAM,EACNvG,YAAY,EACZZ,cAAc,CACf;IAED,OAAOuI,mBAAmB,CAAC5H,MAAM,CAAC8H,yBAAyB,CAAC;EAC9D,CAAC,CAAC;EAEF,OAAOlH,MAAM;AACf;AAvCA1B,OAAA,CAAAkI,wCAAA,GAAAA,wCAAA;AAyCA,IAAAY,mBAAA,0BAAA9F,MAAA;EAAyCC,SAAA,CAAA6F,mBAAA,EAAA9F,MAAA;EAAzC,SAAA8F,oBAAA;IAAA,IAAA5F,KAAA,GAAAF,MAAA,aAAAA,MAAA,CAAAG,KAAA,OAAAC,SAAA;IACSF,KAAA,CAAA9B,cAAc,GAEd,EAAE;;EAmBX;EAjBS0H,mBAAA,CAAAzF,SAAA,CAAAM,4BAA4B,GAAnC,UAAoCC,OAAgC;IAClE,IAAI,CAACxC,cAAc,CAACoC,IAAI,CAACI,OAAO,CAAC;EACnC,CAAC;EAEMkF,mBAAA,CAAAzF,SAAA,CAAAQ,wBAAwB,GAA/B,UAAgCC,UAA+B;IAC7D,IAAI,CAAC1C,cAAc,CAACoC,IAAI,CAACM,UAAU,CAAC;EACtC,CAAC;EAEMgF,mBAAA,CAAAzF,SAAA,CAAAU,qCAAqC,GAA5C,UACEC,aAA+C;IAE/C,IAAI,CAAC5C,cAAc,CAACoC,IAAI,CAACQ,aAAa,CAAC;EACzC,CAAC;EAEM8E,mBAAA,CAAAzF,SAAA,CAAAY,eAAe,GAAtB,UAAuBC,IAAgB;IACrC,IAAI,CAAC9C,cAAc,CAACoC,IAAI,CAACU,IAAI,CAAC;EAChC,CAAC;EACH,OAAA4E,mBAAC;AAAD,CAAC,CAtBwChK,MAAA,CAAAyF,WAAW;AAAvCvE,OAAA,CAAA8I,mBAAA,GAAAA,mBAAA;AAwBb,SAAgBnI,mBAAmBA,CACjCI,YAAkB,EAClBZ,cAAqD;EAErD,IAAMiH,WAAW,GAAG,IAAIJ,WAAW,EAAE;EACrCjG,YAAY,CAACG,MAAM,CAACkG,WAAW,CAAC;EAChC,IAAMC,GAAG,GAAGD,WAAW,CAACH,YAAY;EAEpC,IAAMvF,MAAM,GAAG,IAAAnD,SAAA,CAAAmB,OAAO,EAAC2H,GAAG,EAAE,UAACC,MAAM;IACjC,IAAIA,MAAM,CAAC7B,UAAU,CAAChE,MAAM,GAAG,GAAG,EAAE;MAClC,OAAO,CACL;QACES,OAAO,EAAE/B,cAAc,CAAC4I,6BAA6B,CAAC;UACpDhI,YAAY,EAAEA,YAAY;UAC1B+G,WAAW,EAAER;SACd,CAAC;QACFzH,IAAI,EAAEpB,QAAA,CAAAqB,yBAAyB,CAACkJ,aAAa;QAC7C5G,QAAQ,EAAErB,YAAY,CAACsB,IAAI;QAC3BC,UAAU,EAAEgF,MAAM,CAAC/E;OACpB,CACF;KACF,MAAM;MACL,OAAO,EAAE;;EAEb,CAAC,CAAC;EAEF,OAAOb,MAAM;AACf;AA3BA1B,OAAA,CAAAW,mBAAA,GAAAA,mBAAA;AA6BA,SAAgBsI,iCAAiCA,CAC/CC,aAAqB,EACrBX,YAAoB,EACpBpI,cAAqD;EAErD,IAAMuB,MAAM,GAA6B,EAAE;EAC3C,IAAAzD,SAAA,CAAAyB,OAAO,EAACwJ,aAAa,EAAE,UAACC,WAAW;IACjC,IAAMnI,gBAAgB,GAAG,IAAI8H,mBAAmB,EAAE;IAClDK,WAAW,CAACjI,MAAM,CAACF,gBAAgB,CAAC;IACpC,IAAMG,kBAAkB,GAAGH,gBAAgB,CAACI,cAAc;IAC1D,IAAAnD,SAAA,CAAAyB,OAAO,EAACyB,kBAAkB,EAAE,UAACiI,QAAQ;MACnC,IAAMC,QAAQ,GAAG,IAAA1K,WAAA,CAAA2K,WAAW,EAACF,QAAQ,CAAC;MACtC,IAAMd,kBAAkB,GAAGc,QAAQ,CAACb,YAAY,IAAIA,YAAY;MAChE,IAAMF,cAAc,GAAGe,QAAQ,CAAC7G,GAAG;MACnC,IAAMgH,KAAK,GAAG,IAAA5K,WAAA,CAAA6K,gCAAgC,EAC5CnB,cAAc,EACdc,WAAW,EACXE,QAAQ,EACRf,kBAAkB,CACnB;MACD,IAAMmB,qBAAqB,GAAGF,KAAK,CAAC,CAAC,CAAC;MACtC,IAAI,IAAA7L,SAAA,CAAAgC,OAAO,EAAC,IAAA9B,SAAA,CAAA8B,OAAO,EAAC+J,qBAAqB,CAAC,CAAC,EAAE;QAC3C,IAAM5E,MAAM,GAAG1E,cAAc,CAACuJ,yBAAyB,CAAC;UACtD3I,YAAY,EAAEoI,WAAW;UACzBQ,UAAU,EAAEP;SACb,CAAC;QACF1H,MAAM,CAAC8B,IAAI,CAAC;UACVtB,OAAO,EAAE2C,MAAM;UACfhF,IAAI,EAAEpB,QAAA,CAAAqB,yBAAyB,CAAC8J,sBAAsB;UACtDxH,QAAQ,EAAE+G,WAAW,CAAC9G;SACvB,CAAC;;IAEN,CAAC,CAAC;EACJ,CAAC,CAAC;EAEF,OAAOX,MAAM;AACf;AApCA1B,OAAA,CAAAiJ,iCAAA,GAAAA,iCAAA;AA2CA,SAASN,4BAA4BA,CACnCH,YAA2B,EAC3BV,WAAwB,EACxBtD,IAAU,EACVrE,cAAqD;EAErD,IAAM0J,mBAAmB,GAAgB,EAAE;EAC3C,IAAMC,oBAAoB,GAAG,IAAA3L,QAAA,CAAAuB,OAAM,EACjC8I,YAAY,EACZ,UAAC5D,MAAM,EAAEmF,OAAO,EAAEtC,UAAU;IAC1B;IACA,IAAIK,WAAW,CAACrC,UAAU,CAACgC,UAAU,CAAC,CAACW,iBAAiB,KAAK,IAAI,EAAE;MACjE,OAAOxD,MAAM;;IAGf,IAAA3G,SAAA,CAAAyB,OAAO,EAACqK,OAAO,EAAE,UAACC,QAAQ;MACxB,IAAMC,qBAAqB,GAAG,CAACxC,UAAU,CAAC;MAC1C,IAAAxJ,SAAA,CAAAyB,OAAO,EAAC8I,YAAY,EAAE,UAAC0B,YAAY,EAAEC,eAAe;QAClD,IACE1C,UAAU,KAAK0C,eAAe,IAC9B,IAAAxL,WAAA,CAAAyL,YAAY,EAACF,YAAY,EAAEF,QAAQ,CAAC;QACpC;QACAlC,WAAW,CAACrC,UAAU,CAAC0E,eAAe,CAAC,CAAC/B,iBAAiB,KAAK,IAAI,EAClE;UACA6B,qBAAqB,CAACzG,IAAI,CAAC2G,eAAe,CAAC;;MAE/C,CAAC,CAAC;MAEF,IACEF,qBAAqB,CAACxI,MAAM,GAAG,CAAC,IAChC,CAAC,IAAA9C,WAAA,CAAAyL,YAAY,EAACP,mBAAmB,EAAEG,QAAQ,CAAC,EAC5C;QACAH,mBAAmB,CAACrG,IAAI,CAACwG,QAAQ,CAAC;QAClCpF,MAAM,CAACpB,IAAI,CAAC;UACV6G,IAAI,EAAEJ,qBAAqB;UAC3B3E,IAAI,EAAE0E;SACP,CAAC;;IAEN,CAAC,CAAC;IACF,OAAOpF,MAAM;EACf,CAAC,EACD,EAA6C,CAC9C;EAED,IAAM0F,UAAU,GAAG,IAAAtM,KAAA,CAAA0B,OAAG,EAACoK,oBAAoB,EAAE,UAACS,iBAAiB;IAC7D,IAAMC,WAAW,GAAG,IAAAxM,KAAA,CAAA0B,OAAG,EACrB6K,iBAAiB,CAACF,IAAI,EACtB,UAAC5C,UAAU;MAAK,OAAAA,UAAU,GAAG,CAAC;IAAd,CAAc,CAC/B;IAED,IAAMgD,WAAW,GAAGtK,cAAc,CAACuK,8BAA8B,CAAC;MAChE3J,YAAY,EAAEyD,IAAI;MAClBsD,WAAW,EAAEA,WAAW;MACxB6C,gBAAgB,EAAEH,WAAW;MAC7BI,UAAU,EAAEL,iBAAiB,CAACjF;KAC/B,CAAC;IAEF,OAAO;MACLpD,OAAO,EAAEuI,WAAW;MACpB5K,IAAI,EAAEpB,QAAA,CAAAqB,yBAAyB,CAAC+K,cAAc;MAC9CzI,QAAQ,EAAEoC,IAAI,CAACnC,IAAI;MACnBC,UAAU,EAAEwF,WAAW,CAACvF,GAAG;MAC3BiG,YAAY,EAAE+B,iBAAiB,CAACF;KACjC;EACH,CAAC,CAAC;EAEF,OAAOC,UAAU;AACnB;AAEA,SAAgBzB,kCAAkCA,CAChDL,YAA2B,EAC3BV,WAAwB,EACxBtD,IAAU,EACVrE,cAAqD;EAErD;EACA,IAAM2K,eAAe,GAAG,IAAA3M,QAAA,CAAAuB,OAAM,EAC5B8I,YAAY,EACZ,UAAC5D,MAAM,EAAEmF,OAAO,EAAExH,GAAG;IACnB,IAAMwI,eAAe,GAAG,IAAA/M,KAAA,CAAA0B,OAAG,EAACqK,OAAO,EAAE,UAACC,QAAQ;MAC5C,OAAO;QAAEzH,GAAG,EAAEA,GAAG;QAAE+C,IAAI,EAAE0E;MAAQ,CAAE;IACrC,CAAC,CAAC;IACF,OAAOpF,MAAM,CAAC9D,MAAM,CAACiK,eAAe,CAAC;EACvC,CAAC,EACD,EAA0C,CAC3C;EAED,IAAMrJ,MAAM,GAAG,IAAA1C,SAAA,CAAAU,OAAO,EACpB,IAAAnB,SAAA,CAAAmB,OAAO,EAACoL,eAAe,EAAE,UAACE,cAAc;IACtC,IAAMC,eAAe,GAAGnD,WAAW,CAACrC,UAAU,CAACuF,cAAc,CAACzI,GAAG,CAAC;IAClE;IACA,IAAI0I,eAAe,CAAC7C,iBAAiB,KAAK,IAAI,EAAE;MAC9C,OAAO,EAAE;;IAEX,IAAM8C,SAAS,GAAGF,cAAc,CAACzI,GAAG;IACpC,IAAM4I,UAAU,GAAGH,cAAc,CAAC1F,IAAI;IAEtC,IAAM8F,gCAAgC,GAAG,IAAAvN,QAAA,CAAA6B,OAAM,EAC7CoL,eAAe,EACf,UAACO,gBAAgB;MACf;MACA;QACE;QACAvD,WAAW,CAACrC,UAAU,CAAC4F,gBAAgB,CAAC9I,GAAG,CAAC,CAAC6F,iBAAiB,KAC5D,IAAI,IACNiD,gBAAgB,CAAC9I,GAAG,GAAG2I,SAAS;QAChC;QACA;QACA,IAAAvM,WAAA,CAAA2M,oBAAoB,EAACD,gBAAgB,CAAC/F,IAAI,EAAE6F,UAAU;MAAC;IAE3D,CAAC,CACF;IAED,IAAMI,oBAAoB,GAAG,IAAAvN,KAAA,CAAA0B,OAAG,EAC9B0L,gCAAgC,EAChC,UAACI,iBAAiB;MAChB,IAAMhB,WAAW,GAAG,CAACgB,iBAAiB,CAACjJ,GAAG,GAAG,CAAC,EAAE2I,SAAS,GAAG,CAAC,CAAC;MAC9D,IAAM5I,UAAU,GAAGwF,WAAW,CAACvF,GAAG,KAAK,CAAC,GAAG,EAAE,GAAGuF,WAAW,CAACvF,GAAG;MAE/D,IAAML,OAAO,GAAG/B,cAAc,CAACsL,oCAAoC,CAAC;QAClE1K,YAAY,EAAEyD,IAAI;QAClBsD,WAAW,EAAEA,WAAW;QACxB6C,gBAAgB,EAAEH,WAAW;QAC7BI,UAAU,EAAEY,iBAAiB,CAAClG;OAC/B,CAAC;MACF,OAAO;QACLpD,OAAO,EAAEA,OAAO;QAChBrC,IAAI,EAAEpB,QAAA,CAAAqB,yBAAyB,CAAC4L,qBAAqB;QACrDtJ,QAAQ,EAAEoC,IAAI,CAACnC,IAAI;QACnBC,UAAU,EAAEA,UAAU;QACtBkG,YAAY,EAAEgC;OACf;IACH,CAAC,CACF;IAED,OAAOe,oBAAoB;EAC7B,CAAC,CAAC,CACH;EAED,OAAO7J,MAAM;AACf;AAvEA1B,OAAA,CAAA6I,kCAAA,GAAAA,kCAAA;AAyEA,SAASrI,sCAAsCA,CAC7CN,SAAiB,EACjBV,UAAuB,EACvBW,cAAqD;EAErD,IAAMuB,MAAM,GAA6B,EAAE;EAE3C,IAAMiK,UAAU,GAAG,IAAA3N,KAAA,CAAA0B,OAAG,EAACF,UAAU,EAAE,UAACoM,SAAS;IAAK,OAAAA,SAAS,CAACvJ,IAAI;EAAd,CAAc,CAAC;EAEjE,IAAApE,SAAA,CAAAyB,OAAO,EAACQ,SAAS,EAAE,UAACmF,QAAQ;IAC1B,IAAMwG,YAAY,GAAGxG,QAAQ,CAAChD,IAAI;IAClC,IAAI,IAAA/D,UAAA,CAAAoB,OAAQ,EAACiM,UAAU,EAAEE,YAAY,CAAC,EAAE;MACtC,IAAMhH,MAAM,GAAG1E,cAAc,CAAC2L,2BAA2B,CAACzG,QAAQ,CAAC;MAEnE3D,MAAM,CAAC8B,IAAI,CAAC;QACVtB,OAAO,EAAE2C,MAAM;QACfhF,IAAI,EAAEpB,QAAA,CAAAqB,yBAAyB,CAACiM,+BAA+B;QAC/D3J,QAAQ,EAAEyJ;OACX,CAAC;;EAEN,CAAC,CAAC;EAEF,OAAOnK,MAAM;AACf"},"metadata":{},"sourceType":"script","externalDependencies":[]}