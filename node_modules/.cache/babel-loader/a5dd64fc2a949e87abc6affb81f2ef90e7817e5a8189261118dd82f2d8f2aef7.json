{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.nextPossibleTokensAfter = exports.possiblePathsFrom = exports.NextTerminalAfterAtLeastOneSepWalker = exports.NextTerminalAfterAtLeastOneWalker = exports.NextTerminalAfterManySepWalker = exports.NextTerminalAfterManyWalker = exports.AbstractNextTerminalAfterProductionWalker = exports.NextAfterTokenWalker = exports.AbstractNextPossibleTokensWalker = void 0;\nvar rest_1 = require(\"./rest\");\nvar first_1 = __importDefault(require(\"lodash/first\"));\nvar isEmpty_1 = __importDefault(require(\"lodash/isEmpty\"));\nvar dropRight_1 = __importDefault(require(\"lodash/dropRight\"));\nvar drop_1 = __importDefault(require(\"lodash/drop\"));\nvar last_1 = __importDefault(require(\"lodash/last\"));\nvar forEach_1 = __importDefault(require(\"lodash/forEach\"));\nvar clone_1 = __importDefault(require(\"lodash/clone\"));\nvar first_2 = require(\"./first\");\nvar gast_1 = require(\"@chevrotain/gast\");\nvar AbstractNextPossibleTokensWalker = /** @class */function (_super) {\n  __extends(AbstractNextPossibleTokensWalker, _super);\n  function AbstractNextPossibleTokensWalker(topProd, path) {\n    var _this = _super.call(this) || this;\n    _this.topProd = topProd;\n    _this.path = path;\n    _this.possibleTokTypes = [];\n    _this.nextProductionName = \"\";\n    _this.nextProductionOccurrence = 0;\n    _this.found = false;\n    _this.isAtEndOfPath = false;\n    return _this;\n  }\n  AbstractNextPossibleTokensWalker.prototype.startWalking = function () {\n    this.found = false;\n    if (this.path.ruleStack[0] !== this.topProd.name) {\n      throw Error(\"The path does not start with the walker's top Rule!\");\n    }\n    // immutable for the win\n    this.ruleStack = (0, clone_1.default)(this.path.ruleStack).reverse(); // intelij bug requires assertion\n    this.occurrenceStack = (0, clone_1.default)(this.path.occurrenceStack).reverse(); // intelij bug requires assertion\n    // already verified that the first production is valid, we now seek the 2nd production\n    this.ruleStack.pop();\n    this.occurrenceStack.pop();\n    this.updateExpectedNext();\n    this.walk(this.topProd);\n    return this.possibleTokTypes;\n  };\n  AbstractNextPossibleTokensWalker.prototype.walk = function (prod, prevRest) {\n    if (prevRest === void 0) {\n      prevRest = [];\n    }\n    // stop scanning once we found the path\n    if (!this.found) {\n      _super.prototype.walk.call(this, prod, prevRest);\n    }\n  };\n  AbstractNextPossibleTokensWalker.prototype.walkProdRef = function (refProd, currRest, prevRest) {\n    // found the next production, need to keep walking in it\n    if (refProd.referencedRule.name === this.nextProductionName && refProd.idx === this.nextProductionOccurrence) {\n      var fullRest = currRest.concat(prevRest);\n      this.updateExpectedNext();\n      this.walk(refProd.referencedRule, fullRest);\n    }\n  };\n  AbstractNextPossibleTokensWalker.prototype.updateExpectedNext = function () {\n    // need to consume the Terminal\n    if ((0, isEmpty_1.default)(this.ruleStack)) {\n      // must reset nextProductionXXX to avoid walking down another Top Level production while what we are\n      // really seeking is the last Terminal...\n      this.nextProductionName = \"\";\n      this.nextProductionOccurrence = 0;\n      this.isAtEndOfPath = true;\n    } else {\n      this.nextProductionName = this.ruleStack.pop();\n      this.nextProductionOccurrence = this.occurrenceStack.pop();\n    }\n  };\n  return AbstractNextPossibleTokensWalker;\n}(rest_1.RestWalker);\nexports.AbstractNextPossibleTokensWalker = AbstractNextPossibleTokensWalker;\nvar NextAfterTokenWalker = /** @class */function (_super) {\n  __extends(NextAfterTokenWalker, _super);\n  function NextAfterTokenWalker(topProd, path) {\n    var _this = _super.call(this, topProd, path) || this;\n    _this.path = path;\n    _this.nextTerminalName = \"\";\n    _this.nextTerminalOccurrence = 0;\n    _this.nextTerminalName = _this.path.lastTok.name;\n    _this.nextTerminalOccurrence = _this.path.lastTokOccurrence;\n    return _this;\n  }\n  NextAfterTokenWalker.prototype.walkTerminal = function (terminal, currRest, prevRest) {\n    if (this.isAtEndOfPath && terminal.terminalType.name === this.nextTerminalName && terminal.idx === this.nextTerminalOccurrence && !this.found) {\n      var fullRest = currRest.concat(prevRest);\n      var restProd = new gast_1.Alternative({\n        definition: fullRest\n      });\n      this.possibleTokTypes = (0, first_2.first)(restProd);\n      this.found = true;\n    }\n  };\n  return NextAfterTokenWalker;\n}(AbstractNextPossibleTokensWalker);\nexports.NextAfterTokenWalker = NextAfterTokenWalker;\n/**\n * This walker only \"walks\" a single \"TOP\" level in the Grammar Ast, this means\n * it never \"follows\" production refs\n */\nvar AbstractNextTerminalAfterProductionWalker = /** @class */function (_super) {\n  __extends(AbstractNextTerminalAfterProductionWalker, _super);\n  function AbstractNextTerminalAfterProductionWalker(topRule, occurrence) {\n    var _this = _super.call(this) || this;\n    _this.topRule = topRule;\n    _this.occurrence = occurrence;\n    _this.result = {\n      token: undefined,\n      occurrence: undefined,\n      isEndOfRule: undefined\n    };\n    return _this;\n  }\n  AbstractNextTerminalAfterProductionWalker.prototype.startWalking = function () {\n    this.walk(this.topRule);\n    return this.result;\n  };\n  return AbstractNextTerminalAfterProductionWalker;\n}(rest_1.RestWalker);\nexports.AbstractNextTerminalAfterProductionWalker = AbstractNextTerminalAfterProductionWalker;\nvar NextTerminalAfterManyWalker = /** @class */function (_super) {\n  __extends(NextTerminalAfterManyWalker, _super);\n  function NextTerminalAfterManyWalker() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  NextTerminalAfterManyWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {\n    if (manyProd.idx === this.occurrence) {\n      var firstAfterMany = (0, first_1.default)(currRest.concat(prevRest));\n      this.result.isEndOfRule = firstAfterMany === undefined;\n      if (firstAfterMany instanceof gast_1.Terminal) {\n        this.result.token = firstAfterMany.terminalType;\n        this.result.occurrence = firstAfterMany.idx;\n      }\n    } else {\n      _super.prototype.walkMany.call(this, manyProd, currRest, prevRest);\n    }\n  };\n  return NextTerminalAfterManyWalker;\n}(AbstractNextTerminalAfterProductionWalker);\nexports.NextTerminalAfterManyWalker = NextTerminalAfterManyWalker;\nvar NextTerminalAfterManySepWalker = /** @class */function (_super) {\n  __extends(NextTerminalAfterManySepWalker, _super);\n  function NextTerminalAfterManySepWalker() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  NextTerminalAfterManySepWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {\n    if (manySepProd.idx === this.occurrence) {\n      var firstAfterManySep = (0, first_1.default)(currRest.concat(prevRest));\n      this.result.isEndOfRule = firstAfterManySep === undefined;\n      if (firstAfterManySep instanceof gast_1.Terminal) {\n        this.result.token = firstAfterManySep.terminalType;\n        this.result.occurrence = firstAfterManySep.idx;\n      }\n    } else {\n      _super.prototype.walkManySep.call(this, manySepProd, currRest, prevRest);\n    }\n  };\n  return NextTerminalAfterManySepWalker;\n}(AbstractNextTerminalAfterProductionWalker);\nexports.NextTerminalAfterManySepWalker = NextTerminalAfterManySepWalker;\nvar NextTerminalAfterAtLeastOneWalker = /** @class */function (_super) {\n  __extends(NextTerminalAfterAtLeastOneWalker, _super);\n  function NextTerminalAfterAtLeastOneWalker() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  NextTerminalAfterAtLeastOneWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {\n    if (atLeastOneProd.idx === this.occurrence) {\n      var firstAfterAtLeastOne = (0, first_1.default)(currRest.concat(prevRest));\n      this.result.isEndOfRule = firstAfterAtLeastOne === undefined;\n      if (firstAfterAtLeastOne instanceof gast_1.Terminal) {\n        this.result.token = firstAfterAtLeastOne.terminalType;\n        this.result.occurrence = firstAfterAtLeastOne.idx;\n      }\n    } else {\n      _super.prototype.walkAtLeastOne.call(this, atLeastOneProd, currRest, prevRest);\n    }\n  };\n  return NextTerminalAfterAtLeastOneWalker;\n}(AbstractNextTerminalAfterProductionWalker);\nexports.NextTerminalAfterAtLeastOneWalker = NextTerminalAfterAtLeastOneWalker;\n// TODO: reduce code duplication in the AfterWalkers\nvar NextTerminalAfterAtLeastOneSepWalker = /** @class */function (_super) {\n  __extends(NextTerminalAfterAtLeastOneSepWalker, _super);\n  function NextTerminalAfterAtLeastOneSepWalker() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  NextTerminalAfterAtLeastOneSepWalker.prototype.walkAtLeastOneSep = function (atleastOneSepProd, currRest, prevRest) {\n    if (atleastOneSepProd.idx === this.occurrence) {\n      var firstAfterfirstAfterAtLeastOneSep = (0, first_1.default)(currRest.concat(prevRest));\n      this.result.isEndOfRule = firstAfterfirstAfterAtLeastOneSep === undefined;\n      if (firstAfterfirstAfterAtLeastOneSep instanceof gast_1.Terminal) {\n        this.result.token = firstAfterfirstAfterAtLeastOneSep.terminalType;\n        this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx;\n      }\n    } else {\n      _super.prototype.walkAtLeastOneSep.call(this, atleastOneSepProd, currRest, prevRest);\n    }\n  };\n  return NextTerminalAfterAtLeastOneSepWalker;\n}(AbstractNextTerminalAfterProductionWalker);\nexports.NextTerminalAfterAtLeastOneSepWalker = NextTerminalAfterAtLeastOneSepWalker;\nfunction possiblePathsFrom(targetDef, maxLength, currPath) {\n  if (currPath === void 0) {\n    currPath = [];\n  }\n  // avoid side effects\n  currPath = (0, clone_1.default)(currPath);\n  var result = [];\n  var i = 0;\n  // TODO: avoid inner funcs\n  function remainingPathWith(nextDef) {\n    return nextDef.concat((0, drop_1.default)(targetDef, i + 1));\n  }\n  // TODO: avoid inner funcs\n  function getAlternativesForProd(definition) {\n    var alternatives = possiblePathsFrom(remainingPathWith(definition), maxLength, currPath);\n    return result.concat(alternatives);\n  }\n  /**\n   * Mandatory productions will halt the loop as the paths computed from their recursive calls will already contain the\n   * following (rest) of the targetDef.\n   *\n   * For optional productions (Option/Repetition/...) the loop will continue to represent the paths that do not include the\n   * the optional production.\n   */\n  while (currPath.length < maxLength && i < targetDef.length) {\n    var prod = targetDef[i];\n    /* istanbul ignore else */\n    if (prod instanceof gast_1.Alternative) {\n      return getAlternativesForProd(prod.definition);\n    } else if (prod instanceof gast_1.NonTerminal) {\n      return getAlternativesForProd(prod.definition);\n    } else if (prod instanceof gast_1.Option) {\n      result = getAlternativesForProd(prod.definition);\n    } else if (prod instanceof gast_1.RepetitionMandatory) {\n      var newDef = prod.definition.concat([new gast_1.Repetition({\n        definition: prod.definition\n      })]);\n      return getAlternativesForProd(newDef);\n    } else if (prod instanceof gast_1.RepetitionMandatoryWithSeparator) {\n      var newDef = [new gast_1.Alternative({\n        definition: prod.definition\n      }), new gast_1.Repetition({\n        definition: [new gast_1.Terminal({\n          terminalType: prod.separator\n        })].concat(prod.definition)\n      })];\n      return getAlternativesForProd(newDef);\n    } else if (prod instanceof gast_1.RepetitionWithSeparator) {\n      var newDef = prod.definition.concat([new gast_1.Repetition({\n        definition: [new gast_1.Terminal({\n          terminalType: prod.separator\n        })].concat(prod.definition)\n      })]);\n      result = getAlternativesForProd(newDef);\n    } else if (prod instanceof gast_1.Repetition) {\n      var newDef = prod.definition.concat([new gast_1.Repetition({\n        definition: prod.definition\n      })]);\n      result = getAlternativesForProd(newDef);\n    } else if (prod instanceof gast_1.Alternation) {\n      (0, forEach_1.default)(prod.definition, function (currAlt) {\n        // TODO: this is a limited check for empty alternatives\n        //   It would prevent a common case of infinite loops during parser initialization.\n        //   However **in-directly** empty alternatives may still cause issues.\n        if ((0, isEmpty_1.default)(currAlt.definition) === false) {\n          result = getAlternativesForProd(currAlt.definition);\n        }\n      });\n      return result;\n    } else if (prod instanceof gast_1.Terminal) {\n      currPath.push(prod.terminalType);\n    } else {\n      throw Error(\"non exhaustive match\");\n    }\n    i++;\n  }\n  result.push({\n    partialPath: currPath,\n    suffixDef: (0, drop_1.default)(targetDef, i)\n  });\n  return result;\n}\nexports.possiblePathsFrom = possiblePathsFrom;\nfunction nextPossibleTokensAfter(initialDef, tokenVector, tokMatcher, maxLookAhead) {\n  var EXIT_NON_TERMINAL = \"EXIT_NONE_TERMINAL\";\n  // to avoid creating a new Array each time.\n  var EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL];\n  var EXIT_ALTERNATIVE = \"EXIT_ALTERNATIVE\";\n  var foundCompletePath = false;\n  var tokenVectorLength = tokenVector.length;\n  var minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1;\n  var result = [];\n  var possiblePaths = [];\n  possiblePaths.push({\n    idx: -1,\n    def: initialDef,\n    ruleStack: [],\n    occurrenceStack: []\n  });\n  while (!(0, isEmpty_1.default)(possiblePaths)) {\n    var currPath = possiblePaths.pop();\n    // skip alternatives if no more results can be found (assuming deterministic grammar with fixed lookahead)\n    if (currPath === EXIT_ALTERNATIVE) {\n      if (foundCompletePath && (0, last_1.default)(possiblePaths).idx <= minimalAlternativesIndex) {\n        // remove irrelevant alternative\n        possiblePaths.pop();\n      }\n      continue;\n    }\n    var currDef = currPath.def;\n    var currIdx = currPath.idx;\n    var currRuleStack = currPath.ruleStack;\n    var currOccurrenceStack = currPath.occurrenceStack;\n    // For Example: an empty path could exist in a valid grammar in the case of an EMPTY_ALT\n    if ((0, isEmpty_1.default)(currDef)) {\n      continue;\n    }\n    var prod = currDef[0];\n    /* istanbul ignore else */\n    if (prod === EXIT_NON_TERMINAL) {\n      var nextPath = {\n        idx: currIdx,\n        def: (0, drop_1.default)(currDef),\n        ruleStack: (0, dropRight_1.default)(currRuleStack),\n        occurrenceStack: (0, dropRight_1.default)(currOccurrenceStack)\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof gast_1.Terminal) {\n      /* istanbul ignore else */\n      if (currIdx < tokenVectorLength - 1) {\n        var nextIdx = currIdx + 1;\n        var actualToken = tokenVector[nextIdx];\n        if (tokMatcher(actualToken, prod.terminalType)) {\n          var nextPath = {\n            idx: nextIdx,\n            def: (0, drop_1.default)(currDef),\n            ruleStack: currRuleStack,\n            occurrenceStack: currOccurrenceStack\n          };\n          possiblePaths.push(nextPath);\n        }\n        // end of the line\n      } else if (currIdx === tokenVectorLength - 1) {\n        // IGNORE ABOVE ELSE\n        result.push({\n          nextTokenType: prod.terminalType,\n          nextTokenOccurrence: prod.idx,\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack\n        });\n        foundCompletePath = true;\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    } else if (prod instanceof gast_1.NonTerminal) {\n      var newRuleStack = (0, clone_1.default)(currRuleStack);\n      newRuleStack.push(prod.nonTerminalName);\n      var newOccurrenceStack = (0, clone_1.default)(currOccurrenceStack);\n      newOccurrenceStack.push(prod.idx);\n      var nextPath = {\n        idx: currIdx,\n        def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, (0, drop_1.default)(currDef)),\n        ruleStack: newRuleStack,\n        occurrenceStack: newOccurrenceStack\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof gast_1.Option) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      var nextPathWithout = {\n        idx: currIdx,\n        def: (0, drop_1.default)(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWithout);\n      // required marker to avoid backtracking paths whose higher priority alternatives already matched\n      possiblePaths.push(EXIT_ALTERNATIVE);\n      var nextPathWith = {\n        idx: currIdx,\n        def: prod.definition.concat((0, drop_1.default)(currDef)),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWith);\n    } else if (prod instanceof gast_1.RepetitionMandatory) {\n      // TODO:(THE NEW operators here take a while...) (convert once?)\n      var secondIteration = new gast_1.Repetition({\n        definition: prod.definition,\n        idx: prod.idx\n      });\n      var nextDef = prod.definition.concat([secondIteration], (0, drop_1.default)(currDef));\n      var nextPath = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof gast_1.RepetitionMandatoryWithSeparator) {\n      // TODO:(THE NEW operators here take a while...) (convert once?)\n      var separatorGast = new gast_1.Terminal({\n        terminalType: prod.separator\n      });\n      var secondIteration = new gast_1.Repetition({\n        definition: [separatorGast].concat(prod.definition),\n        idx: prod.idx\n      });\n      var nextDef = prod.definition.concat([secondIteration], (0, drop_1.default)(currDef));\n      var nextPath = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof gast_1.RepetitionWithSeparator) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      var nextPathWithout = {\n        idx: currIdx,\n        def: (0, drop_1.default)(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWithout);\n      // required marker to avoid backtracking paths whose higher priority alternatives already matched\n      possiblePaths.push(EXIT_ALTERNATIVE);\n      var separatorGast = new gast_1.Terminal({\n        terminalType: prod.separator\n      });\n      var nthRepetition = new gast_1.Repetition({\n        definition: [separatorGast].concat(prod.definition),\n        idx: prod.idx\n      });\n      var nextDef = prod.definition.concat([nthRepetition], (0, drop_1.default)(currDef));\n      var nextPathWith = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWith);\n    } else if (prod instanceof gast_1.Repetition) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      var nextPathWithout = {\n        idx: currIdx,\n        def: (0, drop_1.default)(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWithout);\n      // required marker to avoid backtracking paths whose higher priority alternatives already matched\n      possiblePaths.push(EXIT_ALTERNATIVE);\n      // TODO: an empty repetition will cause infinite loops here, will the parser detect this in selfAnalysis?\n      var nthRepetition = new gast_1.Repetition({\n        definition: prod.definition,\n        idx: prod.idx\n      });\n      var nextDef = prod.definition.concat([nthRepetition], (0, drop_1.default)(currDef));\n      var nextPathWith = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWith);\n    } else if (prod instanceof gast_1.Alternation) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      for (var i = prod.definition.length - 1; i >= 0; i--) {\n        var currAlt = prod.definition[i];\n        var currAltPath = {\n          idx: currIdx,\n          def: currAlt.definition.concat((0, drop_1.default)(currDef)),\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack\n        };\n        possiblePaths.push(currAltPath);\n        possiblePaths.push(EXIT_ALTERNATIVE);\n      }\n    } else if (prod instanceof gast_1.Alternative) {\n      possiblePaths.push({\n        idx: currIdx,\n        def: prod.definition.concat((0, drop_1.default)(currDef)),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      });\n    } else if (prod instanceof gast_1.Rule) {\n      // last because we should only encounter at most a single one of these per invocation.\n      possiblePaths.push(expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack));\n    } else {\n      throw Error(\"non exhaustive match\");\n    }\n  }\n  return result;\n}\nexports.nextPossibleTokensAfter = nextPossibleTokensAfter;\nfunction expandTopLevelRule(topRule, currIdx, currRuleStack, currOccurrenceStack) {\n  var newRuleStack = (0, clone_1.default)(currRuleStack);\n  newRuleStack.push(topRule.name);\n  var newCurrOccurrenceStack = (0, clone_1.default)(currOccurrenceStack);\n  // top rule is always assumed to have been called with occurrence index 1\n  newCurrOccurrenceStack.push(1);\n  return {\n    idx: currIdx,\n    def: topRule.definition,\n    ruleStack: newRuleStack,\n    occurrenceStack: newCurrOccurrenceStack\n  };\n}","map":{"version":3,"names":["rest_1","require","first_1","__importDefault","isEmpty_1","dropRight_1","drop_1","last_1","forEach_1","clone_1","first_2","gast_1","AbstractNextPossibleTokensWalker","_super","__extends","topProd","path","_this","call","possibleTokTypes","nextProductionName","nextProductionOccurrence","found","isAtEndOfPath","prototype","startWalking","ruleStack","name","Error","default","reverse","occurrenceStack","pop","updateExpectedNext","walk","prod","prevRest","walkProdRef","refProd","currRest","referencedRule","idx","fullRest","concat","RestWalker","exports","NextAfterTokenWalker","nextTerminalName","nextTerminalOccurrence","lastTok","lastTokOccurrence","walkTerminal","terminal","terminalType","restProd","Alternative","definition","first","AbstractNextTerminalAfterProductionWalker","topRule","occurrence","result","token","undefined","isEndOfRule","NextTerminalAfterManyWalker","walkMany","manyProd","firstAfterMany","Terminal","NextTerminalAfterManySepWalker","walkManySep","manySepProd","firstAfterManySep","NextTerminalAfterAtLeastOneWalker","walkAtLeastOne","atLeastOneProd","firstAfterAtLeastOne","NextTerminalAfterAtLeastOneSepWalker","walkAtLeastOneSep","atleastOneSepProd","firstAfterfirstAfterAtLeastOneSep","possiblePathsFrom","targetDef","maxLength","currPath","i","remainingPathWith","nextDef","getAlternativesForProd","alternatives","length","NonTerminal","Option","RepetitionMandatory","newDef","Repetition","RepetitionMandatoryWithSeparator","separator","RepetitionWithSeparator","Alternation","currAlt","push","partialPath","suffixDef","nextPossibleTokensAfter","initialDef","tokenVector","tokMatcher","maxLookAhead","EXIT_NON_TERMINAL","EXIT_NON_TERMINAL_ARR","EXIT_ALTERNATIVE","foundCompletePath","tokenVectorLength","minimalAlternativesIndex","possiblePaths","def","currDef","currIdx","currRuleStack","currOccurrenceStack","nextPath","nextIdx","actualToken","nextTokenType","nextTokenOccurrence","newRuleStack","nonTerminalName","newOccurrenceStack","nextPathWithout","nextPathWith","secondIteration","separatorGast","nthRepetition","currAltPath","Rule","expandTopLevelRule","newCurrOccurrenceStack"],"sources":["/Users/rociopichardo/Desktop/PFhenryFront/node_modules/chevrotain/src/parse/grammar/interpreter.ts"],"sourcesContent":["import { RestWalker } from \"./rest\"\nimport _first from \"lodash/first\"\nimport isEmpty from \"lodash/isEmpty\"\nimport dropRight from \"lodash/dropRight\"\nimport drop from \"lodash/drop\"\nimport last from \"lodash/last\"\nimport forEach from \"lodash/forEach\"\nimport clone from \"lodash/clone\"\nimport { first } from \"./first\"\nimport { TokenMatcher } from \"../parser/parser\"\nimport {\n  Alternation,\n  Alternative,\n  NonTerminal,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Rule,\n  Terminal\n} from \"@chevrotain/gast\"\nimport {\n  IGrammarPath,\n  IProduction,\n  ISyntacticContentAssistPath,\n  IToken,\n  ITokenGrammarPath,\n  TokenType\n} from \"@chevrotain/types\"\n\nexport abstract class AbstractNextPossibleTokensWalker extends RestWalker {\n  protected possibleTokTypes: TokenType[] = []\n  protected ruleStack: string[]\n  protected occurrenceStack: number[]\n\n  protected nextProductionName = \"\"\n  protected nextProductionOccurrence = 0\n  protected found = false\n  protected isAtEndOfPath = false\n\n  constructor(protected topProd: Rule, protected path: IGrammarPath) {\n    super()\n  }\n\n  startWalking(): TokenType[] {\n    this.found = false\n\n    if (this.path.ruleStack[0] !== this.topProd.name) {\n      throw Error(\"The path does not start with the walker's top Rule!\")\n    }\n\n    // immutable for the win\n    this.ruleStack = clone(this.path.ruleStack).reverse() // intelij bug requires assertion\n    this.occurrenceStack = clone(this.path.occurrenceStack).reverse() // intelij bug requires assertion\n\n    // already verified that the first production is valid, we now seek the 2nd production\n    this.ruleStack.pop()\n    this.occurrenceStack.pop()\n\n    this.updateExpectedNext()\n    this.walk(this.topProd)\n\n    return this.possibleTokTypes\n  }\n\n  walk(\n    prod: { definition: IProduction[] },\n    prevRest: IProduction[] = []\n  ): void {\n    // stop scanning once we found the path\n    if (!this.found) {\n      super.walk(prod, prevRest)\n    }\n  }\n\n  walkProdRef(\n    refProd: NonTerminal,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    // found the next production, need to keep walking in it\n    if (\n      refProd.referencedRule.name === this.nextProductionName &&\n      refProd.idx === this.nextProductionOccurrence\n    ) {\n      const fullRest = currRest.concat(prevRest)\n      this.updateExpectedNext()\n      this.walk(refProd.referencedRule, <any>fullRest)\n    }\n  }\n\n  updateExpectedNext(): void {\n    // need to consume the Terminal\n    if (isEmpty(this.ruleStack)) {\n      // must reset nextProductionXXX to avoid walking down another Top Level production while what we are\n      // really seeking is the last Terminal...\n      this.nextProductionName = \"\"\n      this.nextProductionOccurrence = 0\n      this.isAtEndOfPath = true\n    } else {\n      this.nextProductionName = this.ruleStack.pop()!\n      this.nextProductionOccurrence = this.occurrenceStack.pop()!\n    }\n  }\n}\n\nexport class NextAfterTokenWalker extends AbstractNextPossibleTokensWalker {\n  private nextTerminalName = \"\"\n  private nextTerminalOccurrence = 0\n\n  constructor(topProd: Rule, protected path: ITokenGrammarPath) {\n    super(topProd, path)\n    this.nextTerminalName = this.path.lastTok.name\n    this.nextTerminalOccurrence = this.path.lastTokOccurrence\n  }\n\n  walkTerminal(\n    terminal: Terminal,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    if (\n      this.isAtEndOfPath &&\n      terminal.terminalType.name === this.nextTerminalName &&\n      terminal.idx === this.nextTerminalOccurrence &&\n      !this.found\n    ) {\n      const fullRest = currRest.concat(prevRest)\n      const restProd = new Alternative({ definition: fullRest })\n      this.possibleTokTypes = first(restProd)\n      this.found = true\n    }\n  }\n}\n\nexport type AlternativesFirstTokens = TokenType[][]\n\nexport interface IFirstAfterRepetition {\n  token: TokenType | undefined\n  occurrence: number | undefined\n  isEndOfRule: boolean | undefined\n}\n\n/**\n * This walker only \"walks\" a single \"TOP\" level in the Grammar Ast, this means\n * it never \"follows\" production refs\n */\nexport class AbstractNextTerminalAfterProductionWalker extends RestWalker {\n  protected result: IFirstAfterRepetition = {\n    token: undefined,\n    occurrence: undefined,\n    isEndOfRule: undefined\n  }\n\n  constructor(protected topRule: Rule, protected occurrence: number) {\n    super()\n  }\n\n  startWalking(): IFirstAfterRepetition {\n    this.walk(this.topRule)\n    return this.result\n  }\n}\n\nexport class NextTerminalAfterManyWalker extends AbstractNextTerminalAfterProductionWalker {\n  walkMany(\n    manyProd: Repetition,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    if (manyProd.idx === this.occurrence) {\n      const firstAfterMany = _first(currRest.concat(prevRest))\n      this.result.isEndOfRule = firstAfterMany === undefined\n      if (firstAfterMany instanceof Terminal) {\n        this.result.token = firstAfterMany.terminalType\n        this.result.occurrence = firstAfterMany.idx\n      }\n    } else {\n      super.walkMany(manyProd, currRest, prevRest)\n    }\n  }\n}\n\nexport class NextTerminalAfterManySepWalker extends AbstractNextTerminalAfterProductionWalker {\n  walkManySep(\n    manySepProd: RepetitionWithSeparator,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    if (manySepProd.idx === this.occurrence) {\n      const firstAfterManySep = _first(currRest.concat(prevRest))\n      this.result.isEndOfRule = firstAfterManySep === undefined\n      if (firstAfterManySep instanceof Terminal) {\n        this.result.token = firstAfterManySep.terminalType\n        this.result.occurrence = firstAfterManySep.idx\n      }\n    } else {\n      super.walkManySep(manySepProd, currRest, prevRest)\n    }\n  }\n}\n\nexport class NextTerminalAfterAtLeastOneWalker extends AbstractNextTerminalAfterProductionWalker {\n  walkAtLeastOne(\n    atLeastOneProd: RepetitionMandatory,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    if (atLeastOneProd.idx === this.occurrence) {\n      const firstAfterAtLeastOne = _first(currRest.concat(prevRest))\n      this.result.isEndOfRule = firstAfterAtLeastOne === undefined\n      if (firstAfterAtLeastOne instanceof Terminal) {\n        this.result.token = firstAfterAtLeastOne.terminalType\n        this.result.occurrence = firstAfterAtLeastOne.idx\n      }\n    } else {\n      super.walkAtLeastOne(atLeastOneProd, currRest, prevRest)\n    }\n  }\n}\n\n// TODO: reduce code duplication in the AfterWalkers\nexport class NextTerminalAfterAtLeastOneSepWalker extends AbstractNextTerminalAfterProductionWalker {\n  walkAtLeastOneSep(\n    atleastOneSepProd: RepetitionMandatoryWithSeparator,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    if (atleastOneSepProd.idx === this.occurrence) {\n      const firstAfterfirstAfterAtLeastOneSep = _first(\n        currRest.concat(prevRest)\n      )\n      this.result.isEndOfRule = firstAfterfirstAfterAtLeastOneSep === undefined\n      if (firstAfterfirstAfterAtLeastOneSep instanceof Terminal) {\n        this.result.token = firstAfterfirstAfterAtLeastOneSep.terminalType\n        this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx\n      }\n    } else {\n      super.walkAtLeastOneSep(atleastOneSepProd, currRest, prevRest)\n    }\n  }\n}\n\nexport interface PartialPathAndSuffixes {\n  partialPath: TokenType[]\n  suffixDef: IProduction[]\n}\n\nexport function possiblePathsFrom(\n  targetDef: IProduction[],\n  maxLength: number,\n  currPath: TokenType[] = []\n): PartialPathAndSuffixes[] {\n  // avoid side effects\n  currPath = clone(currPath)\n  let result: PartialPathAndSuffixes[] = []\n  let i = 0\n\n  // TODO: avoid inner funcs\n  function remainingPathWith(nextDef: IProduction[]) {\n    return nextDef.concat(drop(targetDef, i + 1))\n  }\n\n  // TODO: avoid inner funcs\n  function getAlternativesForProd(definition: IProduction[]) {\n    const alternatives = possiblePathsFrom(\n      remainingPathWith(definition),\n      maxLength,\n      currPath\n    )\n    return result.concat(alternatives)\n  }\n\n  /**\n   * Mandatory productions will halt the loop as the paths computed from their recursive calls will already contain the\n   * following (rest) of the targetDef.\n   *\n   * For optional productions (Option/Repetition/...) the loop will continue to represent the paths that do not include the\n   * the optional production.\n   */\n  while (currPath.length < maxLength && i < targetDef.length) {\n    const prod = targetDef[i]\n\n    /* istanbul ignore else */\n    if (prod instanceof Alternative) {\n      return getAlternativesForProd(prod.definition)\n    } else if (prod instanceof NonTerminal) {\n      return getAlternativesForProd(prod.definition)\n    } else if (prod instanceof Option) {\n      result = getAlternativesForProd(prod.definition)\n    } else if (prod instanceof RepetitionMandatory) {\n      const newDef = prod.definition.concat([\n        new Repetition({\n          definition: prod.definition\n        })\n      ])\n      return getAlternativesForProd(newDef)\n    } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n      const newDef = [\n        new Alternative({ definition: prod.definition }),\n        new Repetition({\n          definition: [new Terminal({ terminalType: prod.separator })].concat(\n            <any>prod.definition\n          )\n        })\n      ]\n      return getAlternativesForProd(newDef)\n    } else if (prod instanceof RepetitionWithSeparator) {\n      const newDef = prod.definition.concat([\n        new Repetition({\n          definition: [new Terminal({ terminalType: prod.separator })].concat(\n            <any>prod.definition\n          )\n        })\n      ])\n      result = getAlternativesForProd(newDef)\n    } else if (prod instanceof Repetition) {\n      const newDef = prod.definition.concat([\n        new Repetition({\n          definition: prod.definition\n        })\n      ])\n      result = getAlternativesForProd(newDef)\n    } else if (prod instanceof Alternation) {\n      forEach(prod.definition, (currAlt) => {\n        // TODO: this is a limited check for empty alternatives\n        //   It would prevent a common case of infinite loops during parser initialization.\n        //   However **in-directly** empty alternatives may still cause issues.\n        if (isEmpty(currAlt.definition) === false) {\n          result = getAlternativesForProd(currAlt.definition)\n        }\n      })\n      return result\n    } else if (prod instanceof Terminal) {\n      currPath.push(prod.terminalType)\n    } else {\n      throw Error(\"non exhaustive match\")\n    }\n\n    i++\n  }\n  result.push({\n    partialPath: currPath,\n    suffixDef: drop(targetDef, i)\n  })\n\n  return result\n}\n\ninterface IPathToExamine {\n  idx: number\n  def: IProduction[]\n  ruleStack: string[]\n  occurrenceStack: number[]\n}\n\nexport function nextPossibleTokensAfter(\n  initialDef: IProduction[],\n  tokenVector: IToken[],\n  tokMatcher: TokenMatcher,\n  maxLookAhead: number\n): ISyntacticContentAssistPath[] {\n  const EXIT_NON_TERMINAL: any = \"EXIT_NONE_TERMINAL\"\n  // to avoid creating a new Array each time.\n  const EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL]\n  const EXIT_ALTERNATIVE: any = \"EXIT_ALTERNATIVE\"\n  let foundCompletePath = false\n\n  const tokenVectorLength = tokenVector.length\n  const minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1\n\n  const result: ISyntacticContentAssistPath[] = []\n\n  const possiblePaths: IPathToExamine[] = []\n  possiblePaths.push({\n    idx: -1,\n    def: initialDef,\n    ruleStack: [],\n    occurrenceStack: []\n  })\n\n  while (!isEmpty(possiblePaths)) {\n    const currPath = possiblePaths.pop()!\n\n    // skip alternatives if no more results can be found (assuming deterministic grammar with fixed lookahead)\n    if (currPath === EXIT_ALTERNATIVE) {\n      if (\n        foundCompletePath &&\n        last(possiblePaths)!.idx <= minimalAlternativesIndex\n      ) {\n        // remove irrelevant alternative\n        possiblePaths.pop()\n      }\n      continue\n    }\n\n    const currDef = currPath.def\n    const currIdx = currPath.idx\n    const currRuleStack = currPath.ruleStack\n    const currOccurrenceStack = currPath.occurrenceStack\n\n    // For Example: an empty path could exist in a valid grammar in the case of an EMPTY_ALT\n    if (isEmpty(currDef)) {\n      continue\n    }\n\n    const prod = currDef[0]\n    /* istanbul ignore else */\n    if (prod === EXIT_NON_TERMINAL) {\n      const nextPath = {\n        idx: currIdx,\n        def: drop(currDef),\n        ruleStack: dropRight(currRuleStack),\n        occurrenceStack: dropRight(currOccurrenceStack)\n      }\n      possiblePaths.push(nextPath)\n    } else if (prod instanceof Terminal) {\n      /* istanbul ignore else */\n      if (currIdx < tokenVectorLength - 1) {\n        const nextIdx = currIdx + 1\n        const actualToken = tokenVector[nextIdx]\n        if (tokMatcher!(actualToken, prod.terminalType)) {\n          const nextPath = {\n            idx: nextIdx,\n            def: drop(currDef),\n            ruleStack: currRuleStack,\n            occurrenceStack: currOccurrenceStack\n          }\n          possiblePaths.push(nextPath)\n        }\n        // end of the line\n      } else if (currIdx === tokenVectorLength - 1) {\n        // IGNORE ABOVE ELSE\n        result.push({\n          nextTokenType: prod.terminalType,\n          nextTokenOccurrence: prod.idx,\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack\n        })\n        foundCompletePath = true\n      } else {\n        throw Error(\"non exhaustive match\")\n      }\n    } else if (prod instanceof NonTerminal) {\n      const newRuleStack = clone(currRuleStack)\n      newRuleStack.push(prod.nonTerminalName)\n\n      const newOccurrenceStack = clone(currOccurrenceStack)\n      newOccurrenceStack.push(prod.idx)\n\n      const nextPath = {\n        idx: currIdx,\n        def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, drop(currDef)),\n        ruleStack: newRuleStack,\n        occurrenceStack: newOccurrenceStack\n      }\n      possiblePaths.push(nextPath)\n    } else if (prod instanceof Option) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      const nextPathWithout = {\n        idx: currIdx,\n        def: drop(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      }\n      possiblePaths.push(nextPathWithout)\n      // required marker to avoid backtracking paths whose higher priority alternatives already matched\n      possiblePaths.push(EXIT_ALTERNATIVE)\n\n      const nextPathWith = {\n        idx: currIdx,\n        def: prod.definition.concat(drop(currDef)),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      }\n      possiblePaths.push(nextPathWith)\n    } else if (prod instanceof RepetitionMandatory) {\n      // TODO:(THE NEW operators here take a while...) (convert once?)\n      const secondIteration = new Repetition({\n        definition: prod.definition,\n        idx: prod.idx\n      })\n      const nextDef = prod.definition.concat([secondIteration], drop(currDef))\n      const nextPath = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      }\n      possiblePaths.push(nextPath)\n    } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n      // TODO:(THE NEW operators here take a while...) (convert once?)\n      const separatorGast = new Terminal({\n        terminalType: prod.separator\n      })\n      const secondIteration = new Repetition({\n        definition: [<any>separatorGast].concat(prod.definition),\n        idx: prod.idx\n      })\n      const nextDef = prod.definition.concat([secondIteration], drop(currDef))\n      const nextPath = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      }\n      possiblePaths.push(nextPath)\n    } else if (prod instanceof RepetitionWithSeparator) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      const nextPathWithout = {\n        idx: currIdx,\n        def: drop(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      }\n      possiblePaths.push(nextPathWithout)\n      // required marker to avoid backtracking paths whose higher priority alternatives already matched\n      possiblePaths.push(EXIT_ALTERNATIVE)\n\n      const separatorGast = new Terminal({\n        terminalType: prod.separator\n      })\n      const nthRepetition = new Repetition({\n        definition: [<any>separatorGast].concat(prod.definition),\n        idx: prod.idx\n      })\n      const nextDef = prod.definition.concat([nthRepetition], drop(currDef))\n      const nextPathWith = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      }\n      possiblePaths.push(nextPathWith)\n    } else if (prod instanceof Repetition) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      const nextPathWithout = {\n        idx: currIdx,\n        def: drop(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      }\n      possiblePaths.push(nextPathWithout)\n      // required marker to avoid backtracking paths whose higher priority alternatives already matched\n      possiblePaths.push(EXIT_ALTERNATIVE)\n\n      // TODO: an empty repetition will cause infinite loops here, will the parser detect this in selfAnalysis?\n      const nthRepetition = new Repetition({\n        definition: prod.definition,\n        idx: prod.idx\n      })\n      const nextDef = prod.definition.concat([nthRepetition], drop(currDef))\n      const nextPathWith = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      }\n      possiblePaths.push(nextPathWith)\n    } else if (prod instanceof Alternation) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      for (let i = prod.definition.length - 1; i >= 0; i--) {\n        const currAlt: any = prod.definition[i]\n        const currAltPath = {\n          idx: currIdx,\n          def: currAlt.definition.concat(drop(currDef)),\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack\n        }\n        possiblePaths.push(currAltPath)\n        possiblePaths.push(EXIT_ALTERNATIVE)\n      }\n    } else if (prod instanceof Alternative) {\n      possiblePaths.push({\n        idx: currIdx,\n        def: prod.definition.concat(drop(currDef)),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      })\n    } else if (prod instanceof Rule) {\n      // last because we should only encounter at most a single one of these per invocation.\n      possiblePaths.push(\n        expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack)\n      )\n    } else {\n      throw Error(\"non exhaustive match\")\n    }\n  }\n  return result\n}\n\nfunction expandTopLevelRule(\n  topRule: Rule,\n  currIdx: number,\n  currRuleStack: string[],\n  currOccurrenceStack: number[]\n): IPathToExamine {\n  const newRuleStack = clone(currRuleStack)\n  newRuleStack.push(topRule.name)\n\n  const newCurrOccurrenceStack = clone(currOccurrenceStack)\n  // top rule is always assumed to have been called with occurrence index 1\n  newCurrOccurrenceStack.push(1)\n\n  return {\n    idx: currIdx,\n    def: topRule.definition,\n    ruleStack: newRuleStack,\n    occurrenceStack: newCurrOccurrenceStack\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}