import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import _extends from "@babel/runtime/helpers/esm/extends";
import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import * as React from 'react';
import useControlled from '@mui/utils/useControlled';
import { useUtils, useLocaleText, useLocalizationContext } from '../useUtils';
import { addPositionPropertiesToSections, splitFormatIntoSections, clampDaySection, mergeDateIntoReferenceDate, getSectionsBoundaries, validateSections, getDateFromDateSections } from './useField.utils';
export var useFieldState = function useFieldState(params) {
  var _ref;
  var utils = useUtils();
  var localeText = useLocaleText();
  var adapter = useLocalizationContext();
  var valueManager = params.valueManager,
    fieldValueManager = params.fieldValueManager,
    valueType = params.valueType,
    validator = params.validator,
    internalProps = params.internalProps,
    _params$internalProps = params.internalProps,
    valueProp = _params$internalProps.value,
    defaultValue = _params$internalProps.defaultValue,
    onChange = _params$internalProps.onChange,
    format = _params$internalProps.format,
    selectedSectionsProp = _params$internalProps.selectedSections,
    onSelectedSectionsChange = _params$internalProps.onSelectedSectionsChange;
  var firstDefaultValue = React.useRef(defaultValue);
  var valueFromTheOutside = (_ref = valueProp != null ? valueProp : firstDefaultValue.current) != null ? _ref : valueManager.emptyValue;
  var sectionsValueBoundaries = React.useMemo(function () {
    return getSectionsBoundaries(utils);
  }, [utils]);
  var placeholder = React.useMemo(function () {
    return fieldValueManager.getValueStrFromSections(fieldValueManager.getSectionsFromValue(utils, localeText, null, valueManager.emptyValue, format));
  }, [fieldValueManager, format, localeText, utils, valueManager.emptyValue]);
  var _React$useState = React.useState(function () {
      var sections = fieldValueManager.getSectionsFromValue(utils, localeText, null, valueFromTheOutside, format);
      validateSections(sections, valueType);
      return {
        sections: sections,
        value: valueFromTheOutside,
        placeholder: placeholder,
        referenceValue: fieldValueManager.updateReferenceValue(utils, valueFromTheOutside, valueManager.getTodayValue(utils)),
        tempValueStrAndroid: null
      };
    }),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    state = _React$useState2[0],
    setState = _React$useState2[1];
  var _useControlled = useControlled({
      controlled: selectedSectionsProp,
      default: null,
      name: 'useField',
      state: 'selectedSectionIndexes'
    }),
    _useControlled2 = _slicedToArray(_useControlled, 2),
    selectedSections = _useControlled2[0],
    innerSetSelectedSections = _useControlled2[1];
  var setSelectedSections = function setSelectedSections(newSelectedSections) {
    innerSetSelectedSections(newSelectedSections);
    onSelectedSectionsChange == null ? void 0 : onSelectedSectionsChange(newSelectedSections);
    setState(function (prevState) {
      return _extends({}, prevState, {
        selectedSectionQuery: null
      });
    });
  };
  var selectedSectionIndexes = React.useMemo(function () {
    if (selectedSections == null) {
      return null;
    }
    if (selectedSections === 'all') {
      return {
        startIndex: 0,
        endIndex: state.sections.length - 1,
        shouldSelectBoundarySelectors: true
      };
    }
    if (typeof selectedSections === 'number') {
      return {
        startIndex: selectedSections,
        endIndex: selectedSections
      };
    }
    if (typeof selectedSections === 'string') {
      var selectedSectionIndex = state.sections.findIndex(function (section) {
        return section.type === selectedSections;
      });
      return {
        startIndex: selectedSectionIndex,
        endIndex: selectedSectionIndex
      };
    }
    return selectedSections;
  }, [selectedSections, state.sections]);
  var publishValue = function publishValue(_ref2) {
    var value = _ref2.value,
      referenceValue = _ref2.referenceValue;
    var sections = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : state.sections;
    var newSections = fieldValueManager.getSectionsFromValue(utils, localeText, sections, value, format);
    setState(function (prevState) {
      return _extends({}, prevState, {
        sections: newSections,
        value: value,
        referenceValue: referenceValue,
        tempValueStrAndroid: null
      });
    });
    if (onChange) {
      var context = {
        validationError: validator({
          adapter: adapter,
          value: value,
          props: _extends({}, internalProps, {
            value: value
          })
        })
      };
      onChange(value, context);
    }
  };
  var setSectionValue = function setSectionValue(sectionIndex, newSectionValue) {
    var newSections = _toConsumableArray(state.sections);
    newSections[sectionIndex] = _extends({}, newSections[sectionIndex], {
      value: newSectionValue,
      modified: true
    });
    return addPositionPropertiesToSections(newSections);
  };
  var clearValue = function clearValue() {
    if (valueManager.areValuesEqual(utils, state.value, valueManager.emptyValue)) {
      return;
    }
    publishValue({
      value: valueManager.emptyValue,
      referenceValue: state.referenceValue
    }, null);
  };
  var clearActiveSection = function clearActiveSection() {
    if (selectedSectionIndexes == null) {
      return;
    }
    var activeSection = state.sections[selectedSectionIndexes.startIndex];
    if (activeSection.value === '') {
      return;
    }
    var activeDateManager = fieldValueManager.getActiveDateManager(utils, state, activeSection);
    var activeDateSections = fieldValueManager.getActiveDateSections(state.sections, activeSection);
    var nonEmptySectionCountBefore = activeDateSections.filter(function (section) {
      return section.value !== '';
    }).length;
    var isTheOnlyNonEmptySection = nonEmptySectionCountBefore === 1;
    var newSections = setSectionValue(selectedSectionIndexes.startIndex, '');
    var newActiveDate = isTheOnlyNonEmptySection ? null : utils.date(new Date(''));
    var newValue = activeDateManager.getNewValueFromNewActiveDate(newActiveDate);
    if ((newActiveDate != null && !utils.isValid(newActiveDate)) !== (activeDateManager.activeDate != null && !utils.isValid(activeDateManager.activeDate))) {
      publishValue(newValue, newSections);
    } else {
      setState(function (prevState) {
        return _extends({}, prevState, newValue, {
          sections: newSections,
          tempValueStrAndroid: null
        });
      });
    }
  };
  var updateValueFromValueStr = function updateValueFromValueStr(valueStr) {
    var parseDateStr = function parseDateStr(dateStr, referenceDate) {
      var date = utils.parse(dateStr, format);
      if (date == null || !utils.isValid(date)) {
        return null;
      }
      var sections = splitFormatIntoSections(utils, localeText, format, date);
      return mergeDateIntoReferenceDate(utils, date, sections, referenceDate, false);
    };
    var newValue = fieldValueManager.parseValueStr(valueStr, state.referenceValue, parseDateStr);
    var newReferenceValue = fieldValueManager.updateReferenceValue(utils, newValue, state.referenceValue);
    publishValue({
      value: newValue,
      referenceValue: newReferenceValue
    });
  };
  var updateSectionValue = function updateSectionValue(_ref3) {
    var activeSection = _ref3.activeSection,
      newSectionValue = _ref3.newSectionValue,
      shouldGoToNextSection = _ref3.shouldGoToNextSection;
    var commit = function commit(_ref4) {
      var values = _ref4.values,
        sections = _ref4.sections,
        shouldPublish = _ref4.shouldPublish;
      if (shouldGoToNextSection && selectedSectionIndexes && selectedSectionIndexes.startIndex < state.sections.length - 1) {
        setSelectedSections(selectedSectionIndexes.startIndex + 1);
      } else if (selectedSectionIndexes && selectedSectionIndexes.startIndex !== selectedSectionIndexes.endIndex) {
        setSelectedSections(selectedSectionIndexes.startIndex);
      }
      if (shouldPublish) {
        publishValue(values, sections);
      } else {
        setState(function (prevState) {
          return _extends({}, prevState, values, {
            sections: sections != null ? sections : state.sections,
            tempValueStrAndroid: null
          });
        });
      }
    };
    var activeDateManager = fieldValueManager.getActiveDateManager(utils, state, activeSection);
    var newSections = setSectionValue(selectedSectionIndexes.startIndex, newSectionValue);
    var activeDateSections = fieldValueManager.getActiveDateSections(newSections, activeSection);
    var newActiveDate = getDateFromDateSections(utils, activeDateSections);

    // When all the sections are filled but the date is invalid, it can be because the month has fewer days than asked.
    // We can try to set the day to the maximum boundary.
    if (!utils.isValid(newActiveDate) && activeDateSections.every(function (section) {
      return section.type === 'weekDay' || section.value !== '';
    }) && activeDateSections.some(function (section) {
      return section.type === 'day';
    })) {
      var cleanSections = clampDaySection(utils, activeDateSections, sectionsValueBoundaries);
      if (cleanSections != null) {
        newActiveDate = getDateFromDateSections(utils, cleanSections);
      }
    }
    if (newActiveDate != null && utils.isValid(newActiveDate)) {
      var mergedDate = mergeDateIntoReferenceDate(utils, newActiveDate, activeDateSections, activeDateManager.referenceActiveDate, true);
      return commit({
        values: activeDateManager.getNewValueFromNewActiveDate(mergedDate),
        shouldPublish: true
      });
    }
    return commit({
      values: activeDateManager.getNewValueFromNewActiveDate(newActiveDate),
      sections: newSections,
      shouldPublish: (newActiveDate != null && !utils.isValid(newActiveDate)) !== (activeDateManager.activeDate != null && !utils.isValid(activeDateManager.activeDate))
    });
  };
  var setTempAndroidValueStr = function setTempAndroidValueStr(tempValueStrAndroid) {
    return setState(function (prev) {
      return _extends({}, prev, {
        tempValueStrAndroid: tempValueStrAndroid
      });
    });
  };
  React.useEffect(function () {
    if (!valueManager.areValuesEqual(utils, state.value, valueFromTheOutside)) {
      var sections = fieldValueManager.getSectionsFromValue(utils, localeText, null, valueFromTheOutside, format);
      setState(function (prevState) {
        return _extends({}, prevState, {
          value: valueFromTheOutside,
          referenceValue: fieldValueManager.updateReferenceValue(utils, valueFromTheOutside, prevState.referenceValue),
          sections: sections
        });
      });
    }
  }, [valueFromTheOutside]); // eslint-disable-line react-hooks/exhaustive-deps

  React.useEffect(function () {
    var sections = fieldValueManager.getSectionsFromValue(utils, localeText, null, state.value, format);
    validateSections(sections, valueType);
    setState(function (prevState) {
      return _extends({}, prevState, {
        sections: sections,
        placeholder: placeholder
      });
    });
  }, [format, utils.locale, placeholder]); // eslint-disable-line react-hooks/exhaustive-deps

  return {
    state: state,
    selectedSectionIndexes: selectedSectionIndexes,
    setSelectedSections: setSelectedSections,
    clearValue: clearValue,
    clearActiveSection: clearActiveSection,
    updateSectionValue: updateSectionValue,
    updateValueFromValueStr: updateValueFromValueStr,
    setTempAndroidValueStr: setTempAndroidValueStr,
    sectionsValueBoundaries: sectionsValueBoundaries
  };
};