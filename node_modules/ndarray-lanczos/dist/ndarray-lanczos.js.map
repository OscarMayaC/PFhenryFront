{"version":3,"file":"ndarray-lanczos.js","sources":["../src/index.ts","../vendor/filters.ts","../src/convolve.ts"],"sourcesContent":["import ndarray, { NdArray } from 'ndarray';\nimport { filters } from '../vendor/filters';\nimport { convolve } from './convolve';\n\nenum Method {\n\tLANCZOS_3 = 3,\n\tLANCZOS_2 = 2,\n}\n\nfunction resize(src: NdArray, dst: NdArray, method: Method): void {\n\tconst [srcWidth, srcHeight] = src.shape;\n\tconst [dstWidth, dstHeight] = dst.shape;\n\n\tconst ratioX = dstWidth / srcWidth;\n\tconst ratioY = dstHeight / srcHeight;\n\n\tconst filtersX = filters(srcWidth, dstWidth, ratioX, 0, method === Method.LANCZOS_2);\n\tconst filtersY = filters(srcHeight, dstHeight, ratioY, 0, method === Method.LANCZOS_2);\n\n\tconst tmp = ndarray(new Uint8Array(dstWidth * srcHeight * 4), [srcHeight, dstWidth, 4]);\n\tconst tmpTranspose = tmp.transpose(1, 0);\n\tconst dstTranspose = dst.transpose(1, 0);\n\n\tconvolve(src, tmpTranspose, filtersX);\n\tconvolve(tmp, dstTranspose, filtersY);\n}\n\nexport function lanczos3(src: NdArray, dst: NdArray): void {\n\tresize(src, dst, Method.LANCZOS_3);\n}\n\nexport function lanczos2(src: NdArray, dst: NdArray): void {\n\tresize(src, dst, Method.LANCZOS_2);\n}\n","const fixedFracBits = 14\n\nconst filterValue = ( x: number, a: 2 | 3 ) => {\n\tif ( x <= -a || x >= a ) return 0\n\n\t// appears to do nothing?\n\t// if ( x > -1.19209290e-07 && x < 1.19209290e-07 ) return 1\n\n\tconst xPi = x * Math.PI\n\n\treturn ( Math.sin( xPi ) / xPi ) * Math.sin( xPi / a ) / ( xPi / a )\n}\n\nconst toFixedPoint = ( value: number ) =>\nMath.round( value * ( ( 1 << fixedFracBits ) - 1 ) )\n\nexport const filters = ( srcSize: number, destSize: number, scale: number, offset: number, use2: boolean ) => {\n\tconst a = use2 ? 2 : 3\n\tconst scaleInverted = 1 / scale\n\tconst scaleClamped = Math.min( 1, scale ) // For upscale\n\n\t// Filter window (averaging interval), scaled to src image\n\tconst srcWindow = a / scaleClamped\n\n\tconst maxFilterElementSize = Math.floor( ( srcWindow + 1 ) * 2 )\n\tconst packedFilter = new Int16Array( ( maxFilterElementSize + 2 ) * destSize )\n\tlet packedFilterPtr = 0\n\n\t// For each destination pixel calculate source range and built filter values\n\tfor ( let destPixel = 0; destPixel < destSize; destPixel++ ) {\n\n\t\t// Scaling should be done relative to central pixel point\n\t\tconst sourcePixel = ( destPixel + 0.5 ) * scaleInverted + offset\n\t\tconst sourceFirst = Math.max( 0, Math.floor( sourcePixel - srcWindow ) )\n\t\tconst sourceLast = Math.min( srcSize - 1, Math.ceil( sourcePixel + srcWindow ) )\n\n\t\tconst filterElementSize = sourceLast - sourceFirst + 1\n\t\tconst floatFilter = new Float32Array( filterElementSize )\n\t\tconst fxpFilter = new Int16Array( filterElementSize )\n\n\t\tlet total = 0\n\n\t\t// Fill filter values for calculated range\n\t\tlet index = 0\n\t\tfor ( let pixel = sourceFirst; pixel <= sourceLast; pixel++ ) {\n\t\t\tconst floatValue = filterValue( ( ( pixel + 0.5 ) - sourcePixel ) * scaleClamped, a )\n\n\t\t\ttotal += floatValue\n\t\t\tfloatFilter[ index ] = floatValue\n\n\t\t\tindex++\n\t\t}\n\n\t\t// Normalize filter, convert to fixed point and accumulate conversion error\n\t\tlet filterTotal = 0\n\n\t\tfor ( let index = 0; index < floatFilter.length; index++ ) {\n\t\t\tconst filterValue = floatFilter[ index ] / total\n\n\t\t\tfilterTotal += filterValue\n\t\t\tfxpFilter[ index ] = toFixedPoint( filterValue )\n\t\t}\n\n\t\t// Compensate normalization error, to minimize brightness drift\n\t\tfxpFilter[ destSize >> 1 ] += toFixedPoint( 1 - filterTotal )\n\n\t\t//\n\t\t// Now pack filter to useable form\n\t\t//\n\t\t// 1. Trim heading and tailing zero values, and compensate shitf/length\n\t\t// 2. Put all to single array in this format:\n\t\t//\n\t\t//    [ pos shift, data length, value1, value2, value3, ... ]\n\t\t//\n\t\tlet leftNotEmpty = 0\n\t\twhile ( leftNotEmpty < fxpFilter.length && fxpFilter[ leftNotEmpty ] === 0 ) {\n\t\t\tleftNotEmpty++\n\t\t}\n\n\t\tlet rightNotEmpty = fxpFilter.length - 1\n\t\twhile ( rightNotEmpty > 0 && fxpFilter[ rightNotEmpty ] === 0 ) {\n\t\t\trightNotEmpty--\n\t\t}\n\n\t\tconst filterShift = sourceFirst + leftNotEmpty\n\t\tconst filterSize = rightNotEmpty - leftNotEmpty + 1\n\n\t\tpackedFilter[ packedFilterPtr++ ] = filterShift // shift\n\t\tpackedFilter[ packedFilterPtr++ ] = filterSize // size\n\n\t\tpackedFilter.set( fxpFilter.subarray( leftNotEmpty, rightNotEmpty + 1 ), packedFilterPtr )\n\t\tpackedFilterPtr += filterSize\n\t}\n\n\treturn packedFilter\n}\n","import type { NdArray } from 'ndarray';\n\nconst fixedFracBits = 14;\n\nconst clamp = (v: number): number => v < 0 ? 0 : (v > 255 ? 255 : v);\n\nexport const convolve = (src: NdArray, dst: NdArray, filters: Int16Array) => {\n\tconst [_, srcHeight] = src.shape;\n\tconst [dstWidth] = dst.shape;\n\n\t// For each row\n\tfor (let srcY = 0; srcY < srcHeight; srcY++) {\n\t\tconst dstY = srcY;\n\n\t\t// Apply precomputed filters to each destination row point\n\t\tlet filterPtr = 0;\n\t\tfor (let dstX = 0; dstX < dstWidth; dstX++) {\n\t\t\t// Get the filter that determines the current output pixel.\n\t\t\tlet srcX = filters[filterPtr++];\n\n\t\t\tlet r = 0;\n\t\t\tlet g = 0;\n\t\t\tlet b = 0;\n\t\t\tlet a = 0;\n\n\t\t\t// Apply the filter to the row to get the destination pixel r, g, b, a\n\t\t\tfor (let filterSize = filters[filterPtr++]; filterSize > 0; filterSize--) {\n\t\t\t\tconst filterValue = filters[filterPtr++];\n\n\t\t\t\tr = ( r + filterValue * src.get(srcX, srcY, 0) );\n\t\t\t\tg = ( g + filterValue * src.get(srcX, srcY, 1) );\n\t\t\t\tb = ( b + filterValue * src.get(srcX, srcY, 2) );\n\t\t\t\ta = ( a + filterValue * src.get(srcX, srcY, 3) );\n\n\t\t\t\tsrcX++;\n\t\t\t}\n\n\t\t\t// Bring this value back in range. All of the filter scaling factors\n\t\t\t// are in fixed point with fixedFracBits bits of fractional part.\n\t\t\t//\n\t\t\t// (!) Add 1/2 of value before clamping to get proper rounding. In other\n\t\t\t// case brightness loss will be noticeable if you resize image with white\n\t\t\t// border and place it on white background.\n\t\t\tdst.set(dstX, dstY, 0, clamp( ( r + ( 1 << 13 ) ) >> fixedFracBits ) );\n\t\t\tdst.set(dstX, dstY, 1, clamp( ( g + ( 1 << 13 ) ) >> fixedFracBits ) );\n\t\t\tdst.set(dstX, dstY, 2, clamp( ( b + ( 1 << 13 ) ) >> fixedFracBits ) );\n\t\t\tdst.set(dstX, dstY, 3, clamp( ( a + ( 1 << 13 ) ) >> fixedFracBits ) );\n\t\t}\n\t}\n}\n"],"names":["Method","filterValue","x","a","xPi","Math","PI","sin","toFixedPoint","value","round","filters","srcSize","destSize","scale","offset","use2","scaleInverted","scaleClamped","min","srcWindow","maxFilterElementSize","floor","packedFilter","Int16Array","packedFilterPtr","destPixel","sourcePixel","sourceFirst","max","sourceLast","ceil","filterElementSize","floatFilter","Float32Array","fxpFilter","total","index","pixel","floatValue","filterTotal","length","leftNotEmpty","rightNotEmpty","filterSize","set","subarray","clamp","v","convolve","src","dst","srcHeight","shape","dstWidth","srcY","dstY","filterPtr","dstX","srcX","r","g","b","get","resize","method","srcWidth","dstHeight","ratioY","filtersX","LANCZOS_2","filtersY","tmp","ndarray","Uint8Array","tmpTranspose","transpose","dstTranspose","LANCZOS_3"],"mappings":"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"}